---
phase: 08-real-time-and-notifications
plan: 02
type: execute
wave: 2
depends_on: ["08-01"]
files_modified:
  - src/GlobCRM.Api/Hubs/CrmHub.cs
  - src/GlobCRM.Infrastructure/DependencyInjection.cs
  - src/GlobCRM.Api/Program.cs
  - src/GlobCRM.Infrastructure/Notifications/NotificationRepository.cs
  - src/GlobCRM.Infrastructure/Notifications/NotificationServiceExtensions.cs
  - src/GlobCRM.Infrastructure/Notifications/NotificationDispatcher.cs
  - src/GlobCRM.Infrastructure/Feed/FeedRepository.cs
  - src/GlobCRM.Infrastructure/Feed/FeedServiceExtensions.cs
  - src/GlobCRM.Application/Common/IEmailService.cs
  - src/GlobCRM.Infrastructure/Email/SendGridEmailSender.cs
autonomous: true

must_haves:
  truths:
    - "SignalR hub accepts WebSocket connections with JWT authentication"
    - "Connected clients are added to tenant and user groups"
    - "NotificationDispatcher persists notification, pushes via SignalR, and optionally sends email"
    - "Notification repository supports paged listing, unread count, mark read, and preference management"
    - "Feed repository supports paged feed, create item, create comment"
    - "IEmailService extended with SendNotificationEmailAsync method"
  artifacts:
    - path: "src/GlobCRM.Api/Hubs/CrmHub.cs"
      provides: "SignalR hub with JWT auth and tenant groups"
      contains: "class CrmHub"
    - path: "src/GlobCRM.Infrastructure/Notifications/NotificationDispatcher.cs"
      provides: "Centralized notification delivery coordinator"
      contains: "class NotificationDispatcher"
    - path: "src/GlobCRM.Infrastructure/Notifications/NotificationRepository.cs"
      provides: "EF Core notification repository"
      contains: "class NotificationRepository"
  key_links:
    - from: "src/GlobCRM.Infrastructure/Notifications/NotificationDispatcher.cs"
      to: "src/GlobCRM.Api/Hubs/CrmHub.cs"
      via: "IHubContext<CrmHub> injection"
      pattern: "IHubContext<CrmHub>"
    - from: "src/GlobCRM.Api/Program.cs"
      to: "src/GlobCRM.Api/Hubs/CrmHub.cs"
      via: "MapHub<CrmHub>"
      pattern: "MapHub<CrmHub>"
    - from: "src/GlobCRM.Infrastructure/DependencyInjection.cs"
      to: "JwtBearerEvents"
      via: "OnMessageReceived query string handler"
      pattern: "OnMessageReceived"
---

<objective>
Set up SignalR hub infrastructure with JWT authentication, notification and feed repositories, and the NotificationDispatcher service that coordinates in-app + SignalR + email delivery.

Purpose: Establish the real-time communication backbone and notification delivery pipeline that controllers will call into.
Output: CrmHub, NotificationDispatcher, NotificationRepository, FeedRepository, extended IEmailService.
</objective>

<execution_context>
@/Users/metatech/.claude/get-shit-done/workflows/execute-plan.md
@/Users/metatech/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/08-real-time-and-notifications/08-RESEARCH.md
@.planning/phases/08-real-time-and-notifications/08-01-SUMMARY.md
@src/GlobCRM.Infrastructure/DependencyInjection.cs (JWT config to modify)
@src/GlobCRM.Api/Program.cs (add hub mapping + DI)
@src/GlobCRM.Infrastructure/Gmail/EmailSyncBackgroundService.cs (BackgroundService pattern)
@src/GlobCRM.Application/Common/IEmailService.cs (extend for notification emails)
@src/GlobCRM.Infrastructure/Email/SendGridEmailSender.cs (implement notification email)
</context>

<tasks>

<task type="auto">
  <name>Task 1: SignalR hub, JWT query string handler, and hub mapping</name>
  <files>
    src/GlobCRM.Api/Hubs/CrmHub.cs
    src/GlobCRM.Infrastructure/DependencyInjection.cs
    src/GlobCRM.Api/Program.cs
  </files>
  <action>
    **Create CrmHub.cs** in src/GlobCRM.Api/Hubs/:
    - [Authorize] attribute on the class
    - Inherits from Hub
    - OnConnectedAsync: extract tenantId from Context.User.FindFirst("organizationId"), extract userId from Context.UserIdentifier. Add connection to groups: "tenant_{tenantId}" and "user_{userId}". Call base.
    - OnDisconnectedAsync: call base only (groups auto-cleaned on disconnect).
    - No client-to-server methods needed for v1 (notifications are server-push only).

    **Modify DependencyInjection.cs** -- Add JwtBearerEvents to the existing .AddJwtBearer() configuration:
    - Add `options.Events = new JwtBearerEvents { OnMessageReceived = context => { ... } }` INSIDE the existing .AddJwtBearer lambda.
    - The handler reads `access_token` from `context.Request.Query["access_token"]` when path starts with "/hubs".
    - CRITICAL: This must be added to the EXISTING .AddJwtBearer() call, not a new one. Add `using Microsoft.AspNetCore.Authentication.JwtBearer;` if not already imported (it is -- JwtBearerDefaults is already used).

    **Modify Program.cs**:
    - Add `builder.Services.AddSignalR();` after the existing service registrations (before `var app = builder.Build()`).
    - Add `app.MapHub<CrmHub>("/hubs/crm");` AFTER `app.UseAuthorization()` and BEFORE `app.MapControllers()`.
    - Add `using GlobCRM.Api.Hubs;` import at the top.
  </action>
  <verify>`dotnet build src/GlobCRM.Api/GlobCRM.Api.csproj` compiles. Run the API and verify `/hubs/crm/negotiate` responds (200 or 401).</verify>
  <done>CrmHub mapped at /hubs/crm, JWT tokens read from WebSocket query string, SignalR services registered</done>
</task>

<task type="auto">
  <name>Task 2: Notification and feed repositories, dispatcher, and email extension</name>
  <files>
    src/GlobCRM.Infrastructure/Notifications/NotificationRepository.cs
    src/GlobCRM.Infrastructure/Notifications/NotificationServiceExtensions.cs
    src/GlobCRM.Infrastructure/Notifications/NotificationDispatcher.cs
    src/GlobCRM.Infrastructure/Feed/FeedRepository.cs
    src/GlobCRM.Infrastructure/Feed/FeedServiceExtensions.cs
    src/GlobCRM.Application/Common/IEmailService.cs
    src/GlobCRM.Infrastructure/Email/SendGridEmailSender.cs
    src/GlobCRM.Api/Program.cs
  </files>
  <action>
    **NotificationRepository.cs**: Implements INotificationRepository using ApplicationDbContext.
    - GetPagedAsync: query by UserId, order by CreatedAt DESC, use PagedResult pattern from Domain/Common.
    - GetUnreadCountAsync: count where UserId matches AND IsRead == false.
    - MarkAsReadAsync: set IsRead = true, ReadAt = UtcNow.
    - MarkAllAsReadAsync: bulk update all unread for user.
    - CreateAsync: add to DbSet, SaveChangesAsync.
    - GetPreferencesAsync: query by UserId.
    - UpdatePreferenceAsync: if exists update, else add. SaveChangesAsync.

    **FeedRepository.cs**: Implements IFeedRepository using ApplicationDbContext.
    - GetFeedAsync: query FeedItems ordered by CreatedAt DESC, include Author. Use PagedResult.
    - For RBAC filtering: social posts visible to all tenant users. System events with EntityType/EntityId -- for v1, include all (full RBAC filtering can be added via IPermissionService in a later pass if needed, keeping this simple for now since tenant isolation already enforces org-level access).
    - CreateFeedItemAsync: add to DbSet, SaveChangesAsync.
    - GetByIdAsync: include Comments and their Authors.
    - AddCommentAsync: add to DbSet, SaveChangesAsync.
    - GetCommentsAsync: query by FeedItemId, include Author, order by CreatedAt ASC.

    **NotificationDispatcher.cs**: Central service for notification delivery.
    - Constructor injects: ApplicationDbContext, IHubContext<CrmHub>, IEmailService, ILogger.
    - DispatchAsync(NotificationRequest request) method:
      1. Create Notification entity from request, persist to DB.
      2. Send via SignalR to user group: `_hubContext.Clients.Group($"user_{request.RecipientId}").SendAsync("ReceiveNotification", dto)`.
      3. Check NotificationPreference for this user+type. If EmailEnabled, call `_emailService.SendNotificationEmailAsync(...)`. Wrap email send in try/catch (fire-and-forget, don't fail the whole dispatch if email fails).
    - NotificationRequest is a simple record/class: RecipientId (Guid), Type (NotificationType), Title (string), Message (string), EntityType (string?), EntityId (Guid?), CreatedById (Guid?).
    - Also add a DispatchToTenantFeedAsync method that sends "FeedUpdate" to tenant group for real-time feed updates.

    **NotificationServiceExtensions.cs**: DI registration method AddNotificationServices(). Register NotificationRepository as INotificationRepository (scoped), NotificationDispatcher (scoped).

    **FeedServiceExtensions.cs**: DI registration method AddFeedServices(). Register FeedRepository as IFeedRepository (scoped).

    **Extend IEmailService.cs**: Add method `Task SendNotificationEmailAsync(string email, string userName, string title, string message, string? entityUrl);`

    **Extend SendGridEmailSender.cs**: Implement SendNotificationEmailAsync. Use existing RazorEmailRenderer to render a simple notification email template. Create a basic inline HTML email (same brand style as existing emails) with title, message, and optional "View in GlobCRM" button linking to entityUrl.

    **Update Program.cs**: Add `builder.Services.AddNotificationServices();` and `builder.Services.AddFeedServices();` after existing service registrations.
  </action>
  <verify>`dotnet build src/GlobCRM.Api/GlobCRM.Api.csproj` succeeds. All services resolve via DI (verified by app startup without errors).</verify>
  <done>NotificationDispatcher coordinates 3-channel delivery (DB + SignalR + email), both repositories implement full CRUD, IEmailService extended with notification email method, all services registered in DI</done>
</task>

</tasks>

<verification>
- `dotnet build` succeeds for Api project (which depends on all others)
- App starts without DI errors
- /hubs/crm/negotiate responds when API is running
- NotificationDispatcher can be resolved from DI
</verification>

<success_criteria>
- CrmHub accepts connections at /hubs/crm with JWT auth from query string
- Connected clients join tenant_{tenantId} and user_{userId} groups
- NotificationDispatcher persists, pushes via SignalR, and optionally emails
- NotificationRepository supports all CRUD operations for notifications and preferences
- FeedRepository supports paged feed, create item, and comments
- IEmailService has SendNotificationEmailAsync method implemented
- All services registered in DI via AddNotificationServices() and AddFeedServices()
</success_criteria>

<output>
After completion, create `.planning/phases/08-real-time-and-notifications/08-02-SUMMARY.md`
</output>
