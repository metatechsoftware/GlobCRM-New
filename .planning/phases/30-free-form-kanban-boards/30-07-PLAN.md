---
phase: 30-free-form-kanban-boards
plan: 07
type: execute
wave: 1
depends_on: []
files_modified:
  - src/GlobCRM.Api/Controllers/BoardsController.cs
  - globcrm-web/src/app/features/boards/boards-list/boards-list.component.ts
  - globcrm-web/src/app/features/boards/boards.store.ts
  - globcrm-web/src/app/features/boards/board-detail/board-detail.component.ts
autonomous: true
gap_closure: true
requirements: [KANB-01, KANB-03, KANB-10]

must_haves:
  truths:
    - "Newly created board appears in the boards list without manual refresh"
    - "Card moved to a different column stays in the target column after page refresh"
    - "Cards can be reordered within the same column and the new order persists after refresh"
    - "Checklist items display in the card detail panel after being added"
  artifacts:
    - path: "src/GlobCRM.Api/Controllers/BoardsController.cs"
      provides: "GET endpoint for checklist items by cardId"
      contains: "GetChecklistItems"
    - path: "globcrm-web/src/app/features/boards/boards-list/boards-list.component.ts"
      provides: "viewContainerRef passed to MatDialog.open config"
      contains: "viewContainerRef"
    - path: "globcrm-web/src/app/features/boards/boards.store.ts"
      provides: "moveCard with API-only optimistic update (no redundant array manipulation)"
      contains: "moveCard"
    - path: "globcrm-web/src/app/features/boards/board-detail/board-detail.component.ts"
      provides: "onCardDrop that captures pre-mutation state before CDK mutates arrays"
      contains: "onCardDrop"
  key_links:
    - from: "globcrm-web/src/app/features/boards/board-detail/board-detail.component.ts"
      to: "globcrm-web/src/app/features/boards/boards.store.ts"
      via: "onCardDrop calls store.moveCard with pre-computed state"
      pattern: "boardStore\\.moveCard"
    - from: "globcrm-web/src/app/features/boards/card-detail-panel/card-detail-panel.component.ts"
      to: "src/GlobCRM.Api/Controllers/BoardsController.cs"
      via: "GET /api/boards/{boardId}/cards/{cardId}/checklist"
      pattern: "GetChecklistItems"
---

<objective>
Fix three UAT-reported bugs in Phase 30 Kanban boards: (1) board list not refreshing after creation due to MatDialog injector mismatch, (2) card drag-and-drop not persisting due to double-mutation of CDK arrays in store, (3) checklist items not loading in detail panel due to missing backend GET endpoint.

Purpose: Close all three major UAT gaps so boards, drag-and-drop, and checklists function correctly end-to-end.
Output: Three targeted bug fixes across backend and frontend.
</objective>

<execution_context>
@C:/Users/maliy/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/maliy/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/30-free-form-kanban-boards/30-UAT.md
@.planning/phases/30-free-form-kanban-boards/30-02-SUMMARY.md
@.planning/phases/30-free-form-kanban-boards/30-04-SUMMARY.md
@.planning/phases/30-free-form-kanban-boards/30-05-SUMMARY.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Fix card drag-and-drop persistence and add GET checklist endpoint</name>
  <files>
    src/GlobCRM.Api/Controllers/BoardsController.cs
    globcrm-web/src/app/features/boards/boards.store.ts
    globcrm-web/src/app/features/boards/board-detail/board-detail.component.ts
  </files>
  <action>
**Bug A — Card drag-and-drop double-mutation (UAT test 8):**

The root cause is a double-mutation: CDK's `moveItemInArray` / `transferArrayItem` mutate the arrays passed from the Signal Store's state in-place (since the template binds `col.cards` directly to `[cdkDropListData]`). Then `store.moveCard()` tries to splice/insert the same arrays again, causing the card to be missing from the source (already moved by CDK) so the splice returns undefined and the method hits an early return before making the API call.

Fix `board-detail.component.ts` `onCardDrop()` method:
1. **Before** calling CDK mutation functions, capture the card ID and compute the new sortOrder from the CURRENT (pre-mutation) array state. Specifically:
   - For same-column reorder: capture `cardId = event.previousContainer.data[event.previousIndex].id` BEFORE calling `moveItemInArray`. Then call `moveItemInArray` to let CDK update the view. Then compute sortOrder from the post-mutation array.
   - For cross-column transfer: capture `cardId = event.previousContainer.data[event.previousIndex].id` and `sourceColId` BEFORE calling `transferArrayItem`. Then call `transferArrayItem`. Then compute sortOrder from the post-mutation target array.
2. After CDK mutates, call a new simplified `store.moveCard()` that only does: deep-clone current board for rollback, patchState with new array references (spread each column's cards array to create new references), and make the API call with rollback on error.

Fix `boards.store.ts` `moveCard()` method — completely rewrite it:
1. Remove ALL manual array splice/insert logic (lines ~141-155 currently). CDK has already done the mutation.
2. The method signature should change to: `moveCard(boardId: string, cardId: string, req: MoveCardRequest): void` — remove sourceColumnId, sourceIndex, targetIndex params since CDK already handled the move.
3. Implementation:
   - Capture `previousBoard` via `structuredClone(store.board())` for rollback BEFORE patching state.
   - Create new column array references by mapping each column and spreading its cards: `board.columns.map(col => ({ ...col, cards: [...col.cards] }))`. This ensures Signal Store detects the change even though CDK already mutated the underlying arrays.
   - `patchState(store, { board: { ...board, columns: updatedColumns } })` to notify signals of the new state.
   - Call `boardsService.moveCard(boardId, cardId, req)` and on error, `patchState(store, { board: previousBoard })`.

Update `board-detail.component.ts` `onCardDrop()` call sites to match the new simplified signature:
```typescript
// Same-column reorder
const card = event.container.data[event.previousIndex];
moveItemInArray(event.container.data, event.previousIndex, event.currentIndex);
const newSortOrder = this.calculateSortOrder(event.container.data, event.currentIndex);
this.boardStore.moveCard(board.id, card.id, { targetColumnId: targetColumn.id, sortOrder: newSortOrder });

// Cross-column transfer
const card = event.previousContainer.data[event.previousIndex];
const sourceColId = event.previousContainer.id.replace('col-', '');
transferArrayItem(event.previousContainer.data, event.container.data, event.previousIndex, event.currentIndex);
const newSortOrder = this.calculateSortOrder(event.container.data, event.currentIndex);
this.boardStore.moveCard(board.id, card.id, { targetColumnId: targetColumn.id, sortOrder: newSortOrder });
```

**Bug B — Missing GET checklist endpoint (UAT test 12):**

Add a new GET endpoint to `BoardsController.cs` in the Checklist Endpoints section (before the existing POST at line 756). The endpoint:
- Route: `[HttpGet("{id:guid}/cards/{cardId:guid}/checklist")]`
- Method name: `GetChecklistItems`
- Returns: `List<ChecklistItemDto>` ordered by SortOrder ascending
- Implementation pattern (follow existing checklist endpoints):
  1. Get userId, check board access via `GetBoardWithAccessCheck`
  2. Get card via `_db.KanbanCards.Include(c => c.ChecklistItems).FirstOrDefaultAsync(c => c.Id == cardId && boardColumnIds.Contains(c.ColumnId))`
  3. Return `Ok(card.ChecklistItems.OrderBy(ci => ci.SortOrder).Select(ChecklistItemDto.FromEntity).ToList())`
- ProducesResponseType attributes: 200 with `List<ChecklistItemDto>`, 404

Place this endpoint directly above the existing `AddChecklistItem` method so the section reads: GET (list), POST (create), PUT (update), DELETE, PATCH (toggle).
  </action>
  <verify>
    1. `cd src/GlobCRM.Api && dotnet build` completes with 0 errors
    2. `cd globcrm-web && npx ng build` completes with 0 errors
    3. Grep for `structuredClone` in boards.store.ts confirms rollback pattern
    4. Grep for `GetChecklistItems` in BoardsController.cs confirms new endpoint exists
    5. Grep for `sourceColumnId` in boards.store.ts moveCard method confirms old params are removed
  </verify>
  <done>
    - moveCard in store no longer manipulates arrays (CDK does it), only creates new references and calls API
    - onCardDrop captures card ID before CDK mutation, passes simplified args to store
    - GET /api/boards/{id}/cards/{cardId}/checklist returns checklist items ordered by sortOrder
    - Both backend and frontend build cleanly
  </done>
</task>

<task type="auto">
  <name>Task 2: Fix board list refresh after dialog creation</name>
  <files>
    globcrm-web/src/app/features/boards/boards-list/boards-list.component.ts
  </files>
  <action>
**Bug C — Board list not showing newly created board (UAT test 4):**

The working tree already has the correct fix (ViewContainerRef import + inject + passing to dialog config). The uncommitted diff shows:
- Added `ViewContainerRef` to imports from `@angular/core`
- Added `private readonly viewContainerRef = inject(ViewContainerRef);`
- Added `viewContainerRef: this.viewContainerRef` to the `MatDialog.open()` config

This fix ensures the BoardCreateDialogComponent's `inject(BoardStore)` resolves to the same route-level BoardStore instance that BoardsListComponent uses. Without this, the dialog got a different BoardStore from the root injector, so `createBoard()` updated a different store's state.

Verify the fix is already present in the file (it should be from the uncommitted changes). If the code already includes all three changes (ViewContainerRef import, inject, and dialog config), no code changes are needed — just commit the existing working tree changes.

If for any reason the fix is NOT present, apply it:
1. Add `ViewContainerRef` to the `@angular/core` import
2. Add `private readonly viewContainerRef = inject(ViewContainerRef);` after the transloco inject
3. Add `viewContainerRef: this.viewContainerRef` to the `this.dialog.open()` config object in `openCreateDialog()`

Additionally, ensure the `afterClosed` subscriber still calls `this.boardStore.loadBoards()` when `result?.created` is true, as a safety net to re-fetch from API even though `createBoard()` already optimistically adds the board.
  </action>
  <verify>
    1. `cd globcrm-web && npx ng build` completes with 0 errors
    2. Grep for `viewContainerRef: this.viewContainerRef` in boards-list.component.ts confirms fix is present
    3. Grep for `ViewContainerRef` import in boards-list.component.ts confirms import exists
  </verify>
  <done>
    - MatDialog.open() receives viewContainerRef so dialog resolves the same BoardStore instance
    - Newly created board appears in boards list immediately (optimistic) and persists after navigation
    - Frontend builds cleanly
  </done>
</task>

</tasks>

<verification>
After both tasks complete, verify end-to-end:
1. Backend builds: `cd src/GlobCRM.Api && dotnet build` — 0 errors
2. Frontend builds: `cd globcrm-web && npx ng build` — 0 errors
3. GET checklist endpoint exists: grep `GetChecklistItems` in BoardsController.cs
4. moveCard store method has no splice/insert logic: grep confirms no `splice` in moveCard
5. viewContainerRef passed to dialog: grep confirms in boards-list.component.ts
6. structuredClone used for rollback: grep confirms in boards.store.ts
</verification>

<success_criteria>
- All three UAT gaps are closed: board list refresh, card drag persistence, checklist loading
- Backend and frontend compile with 0 errors
- No regressions to existing board functionality (column drag, filter, card detail panel)
</success_criteria>

<output>
After completion, create `.planning/phases/30-free-form-kanban-boards/30-07-SUMMARY.md`
</output>
