---
phase: 01-foundation
plan: 03
type: execute
wave: 2
depends_on: ["01-01"]
files_modified:
  - src/GlobCRM.Api/Program.cs
  - src/GlobCRM.Infrastructure/MultiTenancy/TenantProvider.cs
  - src/GlobCRM.Infrastructure/MultiTenancy/TenantInfo.cs
  - src/GlobCRM.Infrastructure/Persistence/Interceptors/TenantDbConnectionInterceptor.cs
  - src/GlobCRM.Infrastructure/Persistence/Interceptors/AuditableEntityInterceptor.cs
  - src/GlobCRM.Infrastructure/Identity/CustomClaimsFactory.cs
  - src/GlobCRM.Infrastructure/Identity/CustomLoginEndpoint.cs
  - src/GlobCRM.Infrastructure/DependencyInjection.cs
  - src/GlobCRM.Api/Middleware/TenantResolutionMiddleware.cs
autonomous: true

must_haves:
  truths:
    - "Finbuckle resolves tenant from subdomain pattern (__tenant__.globcrm.com)"
    - "EF Core sets app.current_tenant session variable on every database connection via interceptor"
    - "Identity API endpoints are mapped at /api/auth/* and accept bearer tokens"
    - "Custom login endpoint returns JWT with organizationId claim and respects rememberMe flag"
    - "Token lifetimes: 30-minute access token, 30-day refresh token"
  artifacts:
    - path: "src/GlobCRM.Infrastructure/MultiTenancy/TenantProvider.cs"
      provides: "ITenantProvider implementation using Finbuckle context"
    - path: "src/GlobCRM.Infrastructure/Persistence/Interceptors/TenantDbConnectionInterceptor.cs"
      provides: "EF Core interceptor that sets app.current_tenant on each connection"
    - path: "src/GlobCRM.Infrastructure/Identity/CustomLoginEndpoint.cs"
      provides: "Custom login that adds organizationId to JWT claims and handles rememberMe"
    - path: "src/GlobCRM.Infrastructure/DependencyInjection.cs"
      provides: "Extension method registering all Infrastructure services"
  key_links:
    - from: "src/GlobCRM.Api/Program.cs"
      to: "src/GlobCRM.Infrastructure/DependencyInjection.cs"
      via: "builder.Services.AddInfrastructure()"
      pattern: "AddInfrastructure"
    - from: "src/GlobCRM.Infrastructure/Persistence/Interceptors/TenantDbConnectionInterceptor.cs"
      to: "src/GlobCRM.Domain/Interfaces/ITenantProvider.cs"
      via: "inject ITenantProvider to get current tenant ID"
      pattern: "ITenantProvider"
    - from: "src/GlobCRM.Api/Program.cs"
      to: "Identity API endpoints"
      via: "MapGroup('/api/auth').MapIdentityApi<ApplicationUser>()"
      pattern: "MapIdentityApi"
---

<objective>
Configure multi-tenancy infrastructure and authentication backend.

Purpose: Wire up the triple-layer tenant isolation (Finbuckle middleware + EF Core query filters + PostgreSQL RLS session variable) and configure ASP.NET Core Identity with JWT bearer authentication. Create the custom login endpoint that adds organizationId to JWT claims and handles the rememberMe flag for 30-min vs 30-day sessions.

Output: Working multi-tenant middleware pipeline, tenant-aware database connections, Identity API endpoints at /api/auth/*, and custom login with JWT claims.
</objective>

<execution_context>
@/Users/metatech/.claude/get-shit-done/workflows/execute-plan.md
@/Users/metatech/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/01-foundation/01-RESEARCH.md
@.planning/phases/01-foundation/01-CONTEXT.md
@.planning/phases/01-foundation/01-01-SUMMARY.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Configure Finbuckle multi-tenancy with subdomain resolution and RLS interceptor</name>
  <files>
    src/GlobCRM.Infrastructure/MultiTenancy/TenantProvider.cs
    src/GlobCRM.Infrastructure/MultiTenancy/TenantInfo.cs
    src/GlobCRM.Infrastructure/Persistence/Interceptors/TenantDbConnectionInterceptor.cs
    src/GlobCRM.Infrastructure/Persistence/Interceptors/AuditableEntityInterceptor.cs
    src/GlobCRM.Api/Middleware/TenantResolutionMiddleware.cs
    src/GlobCRM.Infrastructure/DependencyInjection.cs
  </files>
  <action>
    1. **TenantInfo.cs** -- Finbuckle tenant info class:
       - Extend Finbuckle's `ITenantInfo` (or use their base class)
       - Add OrganizationId (Guid) mapped from the Organization table
       - Identifier = subdomain string

    2. **TenantProvider.cs** -- Implement ITenantProvider from Domain:
       - Inject `IMultiTenantContextAccessor<TenantInfo>` from Finbuckle
       - GetTenantId() returns OrganizationId from resolved tenant (or null if no tenant context)
       - GetCurrentOrganizationAsync() queries TenantDbContext by resolved tenant ID
       - Register as scoped service

    3. **TenantDbConnectionInterceptor.cs** -- EF Core DbConnectionInterceptor:
       - Inject ITenantProvider
       - On ConnectionOpenedAsync: execute `SELECT set_config('app.current_tenant', @tenantId, false)`
       - On ConnectionOpened (sync version): same logic
       - Only set if tenantId is not null (some operations like tenant catalog are tenant-agnostic)
       - Use parameterized query to prevent SQL injection

    4. **AuditableEntityInterceptor.cs** -- EF Core SaveChangesInterceptor:
       - On SavingChangesAsync: set CreatedAt on Added entities, UpdatedAt on Modified entities
       - Check for IAuditable interface or convention-based (entities with CreatedAt/UpdatedAt properties)

    5. **TenantResolutionMiddleware.cs** (optional custom middleware wrapping Finbuckle):
       - If no tenant resolved and request is to a tenant-scoped endpoint, return 404 "Organization not found"
       - Exempt paths: /api/auth/register, /api/organizations (create org), /api/organizations/check-subdomain, health checks
       - In development: also support `X-Tenant-Id` header as fallback per research recommendation

    6. **DependencyInjection.cs** -- Infrastructure service registration:
       - AddInfrastructure(IServiceCollection, IConfiguration) extension method
       - Register Finbuckle: `AddMultiTenant<TenantInfo>().WithHostStrategy("__tenant__.globcrm.com").WithEFCoreStore<TenantDbContext, TenantInfo>()`
       - In development: chain `.WithHeaderStrategy("X-Tenant-Id")` for dev fallback
       - Register TenantDbContext with PostgreSQL provider
       - Register ApplicationDbContext with PostgreSQL provider + TenantDbConnectionInterceptor
       - Register TenantProvider as ITenantProvider (scoped)
       - Register AuditableEntityInterceptor

    7. Update **Program.cs** middleware pipeline:
       ```
       app.UseMultiTenant();          // Resolve tenant from subdomain
       // TenantResolutionMiddleware  // Validate tenant exists
       app.UseAuthentication();
       app.UseAuthorization();
       ```
       Finbuckle's UseMultiTenant MUST come before UseAuthentication.
  </action>
  <verify>
    Run `dotnet build GlobCRM.sln` -- must compile with 0 errors.
    Verify DependencyInjection.cs registers Finbuckle with WithHostStrategy.
    Verify TenantDbConnectionInterceptor sets app.current_tenant via set_config.
  </verify>
  <done>
    Finbuckle resolves tenant from subdomain. TenantProvider exposes current tenant ID. Connection interceptor sets PostgreSQL session variable for RLS on every connection. Development fallback supports X-Tenant-Id header. Middleware pipeline ordered correctly.
  </done>
</task>

<task type="auto">
  <name>Task 2: Configure ASP.NET Core Identity with JWT and custom login endpoint</name>
  <files>
    src/GlobCRM.Infrastructure/Identity/CustomClaimsFactory.cs
    src/GlobCRM.Infrastructure/Identity/CustomLoginEndpoint.cs
    src/GlobCRM.Api/Program.cs
    src/GlobCRM.Infrastructure/DependencyInjection.cs
  </files>
  <action>
    1. **Identity configuration** (in DependencyInjection.cs):
       ```csharp
       builder.Services.AddIdentityApiEndpoints<ApplicationUser>()
           .AddRoles<IdentityRole<Guid>>()
           .AddEntityFrameworkStores<ApplicationDbContext>();
       ```

    2. **Identity options** (in DependencyInjection.cs):
       - RequireConfirmedEmail = true (per research: must verify email before login)
       - Password: RequireDigit, RequireLowercase, RequireUppercase, RequireNonAlphanumeric, MinLength=8
       - Lockout: DefaultLockoutTimeSpan=15min, MaxFailedAccessAttempts=5
       - DataProtectionTokenProviderOptions.TokenLifespan = 24 hours (email confirmation, password reset tokens)

    3. **Bearer token configuration**:
       ```csharp
       builder.Services.Configure<BearerTokenOptions>(IdentityConstants.BearerScheme, options =>
       {
           options.BearerTokenExpiration = TimeSpan.FromMinutes(30);  // Default session
           options.RefreshTokenExpiration = TimeSpan.FromDays(30);    // Max with "Remember me"
       });
       ```

    4. **JWT Bearer authentication** (for validating custom tokens):
       - Configure JwtBearerDefaults with token validation parameters
       - Read Jwt:Issuer, Jwt:Audience, Jwt:Key from configuration
       - ValidateIssuer, ValidateAudience, ValidateLifetime, ValidateIssuerSigningKey = true

    5. **CustomClaimsFactory.cs** -- Extends UserClaimsPrincipalFactory:
       - Add "organizationId" claim with user's OrganizationId
       - Add "organizationName" claim (query from Organization table)
       - Add "role" claim from user's role assignment

    6. **CustomLoginEndpoint.cs** -- Custom login that handles rememberMe:
       Map as `POST /api/auth/login-extended`

       Implementation:
       - Accept LoginRequest { email, password, rememberMe, twoFactorCode? }
       - Validate credentials via SignInManager.CheckPasswordSignInAsync
       - If 2FA required and no code provided: return 200 with `{ requiresTwoFactor: true }`
       - If 2FA required and code provided: validate via SignInManager.TwoFactorSignInAsync
       - On success: generate JWT with custom claims (organizationId, role, email, name)
       - If rememberMe=false: set both access AND refresh token expiry to 30 minutes
       - If rememberMe=true: access=30min, refresh=30 days (per locked decision)
       - Return LoginResponse { tokenType, accessToken, expiresIn, refreshToken }
       - Update user's LastLoginAt timestamp
       - Allow multiple simultaneous sessions per locked decision (no session revocation on new login)

       NOTE: The built-in MapIdentityApi login returns opaque tokens. We need this custom endpoint to return proper JWTs with custom claims. Keep MapIdentityApi for other endpoints (register, forgot-password, 2fa management, email confirmation).

    7. **Program.cs** -- Map all auth endpoints:
       ```csharp
       // Built-in Identity endpoints (register, confirm email, forgot password, 2FA)
       app.MapGroup("/api/auth").MapIdentityApi<ApplicationUser>();

       // Custom login endpoint with JWT claims and rememberMe
       app.MapPost("/api/auth/login-extended", CustomLoginEndpoint.HandleLogin);

       // Logout is client-side (clear tokens) -- no server endpoint needed
       // But add a POST /api/auth/logout for future token blacklisting
       ```

    8. **EF Core migration** -- NOW create the initial migration:
       ```bash
       dotnet ef migrations add InitialCreate -p src/GlobCRM.Infrastructure -s src/GlobCRM.Api
       ```
       This creates the database schema with Identity tables + Organization + Invitation.

    9. **Database seeding** -- Create default roles on startup:
       - Seed "Admin" and "Member" roles in ApplicationDbContext
       - Run via app.Services scope in Program.cs
  </action>
  <verify>
    Run `dotnet build GlobCRM.sln` -- must compile with 0 errors.
    Run `dotnet ef migrations list -p src/GlobCRM.Infrastructure -s src/GlobCRM.Api` -- must show InitialCreate migration.
    Run the API: verify `/api/auth/register` endpoint responds (even if no DB yet).
  </verify>
  <done>
    Identity configured with all security options per locked decisions. Custom login endpoint generates JWT with organizationId claim and handles rememberMe (30min vs 30day). Bearer token lifetimes configured. EF Core migration created. Default roles seeded. MapIdentityApi mapped at /api/auth/*. Custom login at /api/auth/login-extended.
  </done>
</task>

</tasks>

<verification>
- `dotnet build GlobCRM.sln` compiles with 0 errors
- Finbuckle registered with WithHostStrategy for subdomain resolution
- TenantDbConnectionInterceptor sets app.current_tenant on connections
- Identity endpoints mapped at /api/auth/*
- Custom login endpoint at /api/auth/login-extended
- Bearer token expiration: 30min access, 30day refresh
- Password policy: 8 chars, upper, lower, digit, special
- Email confirmation required (RequireConfirmedEmail = true)
- EF Core migration exists
</verification>

<success_criteria>
Multi-tenancy resolves tenant from subdomain via Finbuckle. Connection interceptor sets PostgreSQL session variable for RLS. ASP.NET Core Identity configured with all security options. Custom login endpoint returns JWT with organizationId claim, handles rememberMe flag, and supports 2FA flow. Token lifetimes follow locked decision (30-min default, 30-day with rememberMe). Initial EF Core migration created.
</success_criteria>

<output>
After completion, create `.planning/phases/01-foundation/01-03-SUMMARY.md`
</output>
