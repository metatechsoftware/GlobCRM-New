---
phase: 22-shared-foundation-entity-preview-sidebar
plan: 02
type: execute
wave: 2
depends_on: ["22-01"]
files_modified:
  - src/GlobCRM.Api/Controllers/EntityPreviewController.cs
  - src/GlobCRM.Domain/Interfaces/ICustomFieldRepository.cs
  - src/GlobCRM.Infrastructure/Persistence/Repositories/CustomFieldRepository.cs
autonomous: true
requirements:
  - PREVIEW-03
  - PREVIEW-06
  - PREVIEW-12
  - PREVIEW-13

must_haves:
  truths:
    - "GET /api/entities/{type}/{id}/preview returns entity-appropriate key properties for all 6 entity types (Contact, Company, Deal, Lead, Activity, Product)"
    - "Preview endpoint enforces RBAC scope checking (Own/Team/All) using the same pattern as existing entity controllers"
    - "Preview endpoint returns 404 with a graceful error message for deleted or non-existent entities"
    - "Preview response includes association summaries (related entity counts and names) for each entity type"
    - "Preview response includes the last 3 recent activities for entity types that track activities"
    - "Preview response includes pinned custom fields (where ShowInPreview = true)"
    - "Deal and Lead preview responses include pipeline stage information (all stages + current stage) for the mini progress bar"
  artifacts:
    - path: "src/GlobCRM.Api/Controllers/EntityPreviewController.cs"
      provides: "Preview API endpoint with RBAC and per-type dispatch"
      contains: "EntityPreviewController"
    - path: "src/GlobCRM.Api/Controllers/EntityPreviewController.cs"
      provides: "EntityPreviewDto and per-type slim DTOs"
      contains: "EntityPreviewDto"
  key_links:
    - from: "src/GlobCRM.Api/Controllers/EntityPreviewController.cs"
      to: "IPermissionService + IsWithinScope"
      via: "RBAC scope enforcement on preview access"
      pattern: "GetEffectivePermissionAsync.*View"
    - from: "src/GlobCRM.Api/Controllers/EntityPreviewController.cs"
      to: "Entity repositories (Contact, Company, Deal, Lead, Activity, Product)"
      via: "Per-type dispatch loading entity data"
      pattern: "type\\.ToLower\\(\\) switch"
---

<objective>
Create a single backend preview endpoint (GET /api/entities/{type}/{id}/preview) that returns entity-appropriate slim DTOs with RBAC scope checking, association summaries, pipeline stage info, pinned custom fields, and the last 3 recent activities. Returns graceful 404 for deleted/non-existent entities and 403 for unauthorized access.

Purpose: Provides the data layer for the frontend preview sidebar. A single polymorphic endpoint keeps the frontend simple while the backend dispatches per-type for optimal queries.

Output: EntityPreviewController with per-type preview methods, co-located DTOs, RBAC enforcement.
</objective>

<execution_context>
@/Users/metatech/.claude/get-shit-done/workflows/execute-plan.md
@/Users/metatech/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/22-shared-foundation-entity-preview-sidebar/22-RESEARCH.md
@.planning/phases/22-shared-foundation-entity-preview-sidebar/22-01-SUMMARY.md

@src/GlobCRM.Api/Controllers/ContactsController.cs
@src/GlobCRM.Api/Controllers/CompaniesController.cs
@src/GlobCRM.Api/Controllers/DealsController.cs
@src/GlobCRM.Api/Controllers/LeadsController.cs
@src/GlobCRM.Api/Controllers/ActivitiesController.cs
@src/GlobCRM.Api/Controllers/ProductsController.cs
@src/GlobCRM.Domain/Entities/Contact.cs
@src/GlobCRM.Domain/Entities/Company.cs
@src/GlobCRM.Domain/Entities/Deal.cs
@src/GlobCRM.Domain/Entities/Lead.cs
@src/GlobCRM.Domain/Entities/Activity.cs
@src/GlobCRM.Domain/Entities/Product.cs
@src/GlobCRM.Domain/Entities/CustomFieldDefinition.cs
@src/GlobCRM.Domain/Interfaces/IContactRepository.cs
@src/GlobCRM.Domain/Interfaces/ICompanyRepository.cs
@src/GlobCRM.Domain/Interfaces/IDealRepository.cs
@src/GlobCRM.Domain/Interfaces/ILeadRepository.cs
@src/GlobCRM.Domain/Interfaces/IActivityRepository.cs
@src/GlobCRM.Domain/Interfaces/IProductRepository.cs
@src/GlobCRM.Domain/Interfaces/ICustomFieldRepository.cs
@src/GlobCRM.Infrastructure/Authorization/PermissionService.cs
</context>

<tasks>

<task type="auto">
  <name>Task 1: EntityPreviewController with RBAC, per-type DTOs, associations, and recent activities</name>
  <files>
    src/GlobCRM.Api/Controllers/EntityPreviewController.cs
    src/GlobCRM.Domain/Interfaces/ICustomFieldRepository.cs
    src/GlobCRM.Infrastructure/Persistence/Repositories/CustomFieldRepository.cs
  </files>
  <action>
    Create `src/GlobCRM.Api/Controllers/EntityPreviewController.cs` with:

    **DTOs (co-located in the same file per project convention):**

    ```csharp
    public record EntityPreviewDto
    {
        public Guid Id { get; init; }
        public string EntityType { get; init; } = string.Empty;
        public string Name { get; init; } = string.Empty;
        public string? OwnerName { get; init; }
        public string? OwnerAvatarUrl { get; init; }
        public Guid? OwnerId { get; init; }

        // Per-entity-type key fields (flattened, nullable -- frontend renders based on EntityType)
        public Dictionary<string, object?> Fields { get; init; } = new();

        // Pinned custom fields (ShowInPreview = true)
        public List<CustomFieldPreviewDto> PinnedCustomFields { get; init; } = new();

        // Association summaries
        public List<AssociationChipDto> Associations { get; init; } = new();

        // Pipeline stage info (Deal and Lead only)
        public PipelineStagePreviewDto? PipelineStage { get; init; }

        // Last 3 recent activities
        public List<RecentActivityDto> RecentActivities { get; init; } = new();
    }

    public record CustomFieldPreviewDto
    {
        public string Label { get; init; } = string.Empty;
        public string FieldType { get; init; } = string.Empty;
        public object? Value { get; init; }
    }

    public record AssociationChipDto
    {
        public string EntityType { get; init; } = string.Empty;
        public int Count { get; init; }
        public List<AssociationItemDto> Items { get; init; } = new();  // First 3 named items
    }

    public record AssociationItemDto
    {
        public Guid Id { get; init; }
        public string Name { get; init; } = string.Empty;
    }

    public record PipelineStagePreviewDto
    {
        public string PipelineName { get; init; } = string.Empty;
        public Guid CurrentStageId { get; init; }
        public string CurrentStageName { get; init; } = string.Empty;
        public int CurrentSortOrder { get; init; }
        public List<StageInfoDto> AllStages { get; init; } = new();
    }

    public record StageInfoDto
    {
        public Guid Id { get; init; }
        public string Name { get; init; } = string.Empty;
        public int SortOrder { get; init; }
        public string? Color { get; init; }
    }

    public record RecentActivityDto
    {
        public Guid Id { get; init; }
        public string Subject { get; init; } = string.Empty;
        public string Type { get; init; } = string.Empty;
        public string Status { get; init; } = string.Empty;
        public DateTimeOffset CreatedAt { get; init; }
    }
    ```

    **Controller:**

    ```csharp
    [ApiController]
    [Route("api/entities")]
    [Authorize]
    public class EntityPreviewController : ControllerBase
    {
        // Inject all 6 entity repositories, IPermissionService, ICustomFieldRepository, ApplicationDbContext

        [HttpGet("{type}/{id:guid}/preview")]
        [Authorize(Policy = "Permission:Contact:View")]  // Base auth -- actual scope check is per-type inside
        public async Task<IActionResult> GetPreview(string type, Guid id)
        {
            var userId = GetCurrentUserId();

            return type.ToLower() switch
            {
                "contact"  => await GetContactPreview(id, userId),
                "company"  => await GetCompanyPreview(id, userId),
                "deal"     => await GetDealPreview(id, userId),
                "lead"     => await GetLeadPreview(id, userId),
                "activity" => await GetActivityPreview(id, userId),
                "product"  => await GetProductPreview(id, userId),
                _          => BadRequest(new { error = $"Unknown entity type: {type}" }),
            };
        }
    }
    ```

    **IMPORTANT:** Do NOT use a blanket `[Authorize(Policy = "Permission:Contact:View")]` on the endpoint. Instead, remove the policy attribute and only use `[Authorize]` at the class/method level. The per-type methods internally call `GetEffectivePermissionAsync` with the correct entity type string. This ensures a user with Deal:View but not Contact:View can still preview deals.

    **Per-type preview methods (implement all 6):**

    Each follows the same pattern (using Contact as example):

    ```csharp
    private async Task<IActionResult> GetContactPreview(Guid id, Guid userId)
    {
        var contact = await _contactRepository.GetByIdAsync(id);
        if (contact is null)
            return NotFound(new { error = "This Contact was not found. It may have been deleted or merged." });

        var permission = await _permissionService.GetEffectivePermissionAsync(userId, "Contact", "View");
        var teamMemberIds = await GetTeamMemberIds(userId, permission.Scope);
        if (!IsWithinScope(contact.OwnerId, permission.Scope, userId, teamMemberIds))
            return StatusCode(403, new { error = "You don't have permission to view this Contact." });

        var pinnedFields = await GetPinnedCustomFields("Contact", contact.CustomFields);
        var associations = await GetContactAssociations(id);
        var recentActivities = await GetRecentActivities("Contact", id);

        var owner = contact.OwnerId.HasValue ? await GetOwnerInfo(contact.OwnerId.Value) : null;

        return Ok(new EntityPreviewDto
        {
            Id = contact.Id,
            EntityType = "Contact",
            Name = $"{contact.FirstName} {contact.LastName}",
            OwnerName = owner?.Name,
            OwnerAvatarUrl = owner?.AvatarUrl,
            OwnerId = contact.OwnerId,
            Fields = new Dictionary<string, object?>
            {
                ["email"] = contact.Email,
                ["phone"] = contact.Phone,
                ["jobTitle"] = contact.JobTitle,
                ["companyName"] = contact.Company?.Name,
                ["city"] = contact.City,
            },
            PinnedCustomFields = pinnedFields,
            Associations = associations,
            RecentActivities = recentActivities,
        });
    }
    ```

    **Field selection per entity type (per research discretion recommendations):**

    - **Contact (6):** email, phone, jobTitle, companyName, city, fullName (name already in top-level Name)
    - **Company (6):** industry, phone, website, size, city, country
    - **Deal (7):** value (formatted), probability, expectedCloseDate, stageName, companyName, pipelineName, currency
    - **Lead (7):** email, phone, companyName, temperature, source, stageName, city
    - **Activity (5):** type, status, priority, dueDate, relatedEntityInfo
    - **Product (4):** unitPrice, sku, category, description

    **Association queries per entity type:**

    Use DbContext to query association counts + first 3 named items:
    - **Contact:** Companies (via CompanyId), Deals (via DealContacts), Activities (via ActivityContacts)
    - **Company:** Contacts, Deals, Activities
    - **Deal:** Contacts (via DealContacts), Products (via DealProducts), Activities
    - **Lead:** Activities (via ActivityLeads or similar relationship)
    - **Activity:** Contacts, Companies, Deals (via polymorphic relations)
    - **Product:** Deals (via DealProducts)

    For each association, query `Count()` and `Take(3)` with name projection.

    **Pipeline stage info (Deal + Lead only):**

    For Deals: Query the pipeline's stages (`_dbContext.PipelineStages.Where(s => s.PipelineId == deal.PipelineId).OrderBy(s => s.SortOrder)`) and include the current stage name, sort order, and all stages for the mini progress bar.

    For Leads: Query `_dbContext.LeadStages.OrderBy(s => s.SortOrder)` and include the current stage.

    **Recent activities (last 3):**

    Query activities linked to this entity:
    ```csharp
    private async Task<List<RecentActivityDto>> GetRecentActivities(string entityType, Guid entityId)
    {
        // Use the entity-activity junction tables (ActivityContacts, ActivityCompanies, ActivityDeals, ActivityLeads)
        // to find activities linked to this entity. Order by CreatedAt desc, take 3.
        // Return Subject, Type, Status, CreatedAt.
    }
    ```

    **Pinned custom fields:**

    Add a method `GetPinnedForPreviewAsync(string entityType)` to `ICustomFieldRepository` and implement in `CustomFieldRepository`:

    ```csharp
    Task<List<CustomFieldDefinition>> GetPinnedForPreviewAsync(string entityType);
    ```

    Implementation: `_dbContext.CustomFieldDefinitions.Where(c => c.EntityType == entityType && c.ShowInPreview && !c.IsDeleted).OrderBy(c => c.SortOrder).ToListAsync()`

    Then extract values from the entity's `CustomFields` JSONB dictionary and match with pinned definitions.

    **Product entity note:** Product has no OwnerId, so skip the RBAC scope check for Product. Just verify the product exists and return it (products are shared tenant resources).
  </action>
  <verify>
    1. `cd src/GlobCRM.Api && dotnet build` -- compiles with no errors.
    2. Start API and test: `curl -H "Authorization: Bearer {token}" http://localhost:5233/api/entities/contact/{id}/preview` -- returns 200 with EntityPreviewDto shape.
    3. Test unknown type: `curl ... http://localhost:5233/api/entities/unknown/{id}/preview` -- returns 400.
    4. Test non-existent entity: `curl ... http://localhost:5233/api/entities/contact/00000000-0000-0000-0000-000000000000/preview` -- returns 404 with error message.
  </verify>
  <done>
    Single preview endpoint handles all 6 entity types with RBAC scope checking. Returns key fields, association summaries (counts + first 3 named items), pipeline stage info for deals/leads, pinned custom fields, and last 3 recent activities. Returns graceful 404 for missing entities and 403 for unauthorized access. Backend compiles and endpoint responds correctly.
  </done>
</task>

</tasks>

<verification>
1. `cd src/GlobCRM.Api && dotnet build` succeeds
2. Preview endpoint returns correct shape for each of the 6 entity types
3. RBAC scope check prevents unauthorized access (user with Own scope can't see other user's entities)
4. 404 returned for non-existent entities with user-friendly message
5. Association counts are accurate
6. Pipeline stage data includes all stages for mini progress bar rendering
</verification>

<success_criteria>
- EntityPreviewController exists at `src/GlobCRM.Api/Controllers/EntityPreviewController.cs`
- Endpoint returns entity-specific fields matching the field selection spec for all 6 types
- RBAC scope enforcement works for Contact, Company, Deal, Lead, Activity (Product skips scope)
- Response includes associations, pipeline stages (Deal/Lead), pinned custom fields, recent activities
- Backend compiles and responds to API requests
</success_criteria>

<output>
After completion, create `.planning/phases/22-shared-foundation-entity-preview-sidebar/22-02-SUMMARY.md`
</output>
