---
phase: 03-core-crm-entities
plan: 04
type: execute
wave: 2
depends_on: ["03-01"]
files_modified:
  - src/GlobCRM.Domain/Interfaces/ICompanyRepository.cs
  - src/GlobCRM.Domain/Interfaces/IContactRepository.cs
  - src/GlobCRM.Domain/Interfaces/IProductRepository.cs
  - src/GlobCRM.Infrastructure/Persistence/Repositories/CompanyRepository.cs
  - src/GlobCRM.Infrastructure/Persistence/Repositories/ContactRepository.cs
  - src/GlobCRM.Infrastructure/Persistence/Repositories/ProductRepository.cs
  - src/GlobCRM.Infrastructure/MultiTenancy/TenantSeeder.cs
  - src/GlobCRM.Infrastructure/Authorization/RoleTemplateSeeder.cs
  - src/GlobCRM.Api/Models/EntityQueryParams.cs
autonomous: true

must_haves:
  truths:
    - "Repositories support server-side filtering, sorting, and pagination for all 3 entities"
    - "Ownership scope filtering (None/Own/Team/All) is applied to all entity queries"
    - "Custom field filtering uses JSONB containment operator for GIN index utilization"
    - "TenantSeeder creates actual Company and Contact entities from seed manifest"
    - "Existing template roles get permissions for Company, Contact, Product entity types"
  artifacts:
    - path: "src/GlobCRM.Domain/Interfaces/ICompanyRepository.cs"
      provides: "Repository interface with GetPagedAsync, GetByIdAsync, CreateAsync, UpdateAsync, DeleteAsync"
      contains: "interface ICompanyRepository"
    - path: "src/GlobCRM.Infrastructure/Persistence/Repositories/CompanyRepository.cs"
      provides: "EF Core implementation with server-side filter/sort/page and ownership scope"
      contains: "class CompanyRepository"
    - path: "src/GlobCRM.Api/Models/EntityQueryParams.cs"
      provides: "Shared query parameter model for all entity list endpoints"
      contains: "class EntityQueryParams"
    - path: "src/GlobCRM.Infrastructure/MultiTenancy/TenantSeeder.cs"
      provides: "Updated seeder that creates Company and Contact entities from manifest"
      contains: "Companies.Add"
  key_links:
    - from: "CompanyRepository"
      to: "ApplicationDbContext.Companies"
      via: "EF Core LINQ queries with pagination"
      pattern: "_db\\.Companies"
    - from: "CompanyRepository"
      to: "PermissionScope"
      via: "ApplyOwnershipScope method filters by OwnerId"
      pattern: "PermissionScope"
    - from: "TenantSeeder"
      to: "Company/Contact entities"
      via: "Creates entities from seed manifest data"
      pattern: "new Company"
---

<objective>
Create the repository layer with server-side filtering, sorting, pagination, and ownership scope enforcement for all 3 CRM entities. Update TenantSeeder to create actual entities from the seed manifest. Update permission seeder to ensure existing roles cover new entity types.

Purpose: Controllers (Plan 05) need repositories for data access. The server-side query system is critical for performance -- client-side filtering would break with real data volumes. Seed data and permissions must exist for the entities to be usable.

Output: 3 repository interfaces, 3 implementations, shared query params model, updated TenantSeeder, updated RoleTemplateSeeder.
</objective>

<execution_context>
@/Users/metatech/.claude/get-shit-done/workflows/execute-plan.md
@/Users/metatech/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/03-core-crm-entities/03-RESEARCH.md
@.planning/phases/03-core-crm-entities/03-01-SUMMARY.md
@src/GlobCRM.Infrastructure/Persistence/Repositories/CustomFieldRepository.cs
@src/GlobCRM.Infrastructure/MultiTenancy/TenantSeeder.cs
@src/GlobCRM.Infrastructure/Authorization/RoleTemplateSeeder.cs
@src/GlobCRM.Domain/Enums/PermissionScope.cs
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create shared EntityQueryParams and repository interfaces/implementations</name>
  <files>
    src/GlobCRM.Api/Models/EntityQueryParams.cs
    src/GlobCRM.Domain/Interfaces/ICompanyRepository.cs
    src/GlobCRM.Domain/Interfaces/IContactRepository.cs
    src/GlobCRM.Domain/Interfaces/IProductRepository.cs
    src/GlobCRM.Infrastructure/Persistence/Repositories/CompanyRepository.cs
    src/GlobCRM.Infrastructure/Persistence/Repositories/ContactRepository.cs
    src/GlobCRM.Infrastructure/Persistence/Repositories/ProductRepository.cs
  </files>
  <action>
**EntityQueryParams.cs** (in Api/Models/ -- shared across all entity controllers):
Follow the research Pattern 2 exactly:
```csharp
public class EntityQueryParams
{
    public int Page { get; set; } = 1;
    public int PageSize { get; set; } = 25;
    public string? SortField { get; set; }
    public string SortDirection { get; set; } = "asc";
    public string? Search { get; set; }
    public List<FilterParam>? Filters { get; set; }
}

public class FilterParam
{
    public string FieldId { get; set; } = string.Empty;
    public string Operator { get; set; } = "equals";
    public string? Value { get; set; }
}

public class PagedResult<T>
{
    public List<T> Items { get; set; } = new();
    public int TotalCount { get; set; }
    public int Page { get; set; }
    public int PageSize { get; set; }
    public int TotalPages => (int)Math.Ceiling((double)TotalCount / PageSize);
}
```

**Repository interfaces** (Domain/Interfaces/):
Each interface follows the same contract:
```csharp
public interface ICompanyRepository
{
    Task<PagedResult<Company>> GetPagedAsync(EntityQueryParams queryParams, PermissionScope scope, Guid userId, List<Guid>? teamMemberIds = null);
    Task<Company?> GetByIdAsync(Guid id);
    Task<Company> CreateAsync(Company company);
    Task UpdateAsync(Company company);
    Task DeleteAsync(Guid id);
}
```
Note: PagedResult<T> will need to be accessible from Domain -- either put it in Domain or use a common PagedResult in the Application/Domain layer. Since Domain shouldn't reference Api, create `PagedResult<T>` in `src/GlobCRM.Domain/Common/PagedResult.cs` and have the Api model reference or mirror it. Or put it in a shared location. Simplest: put PagedResult in Domain/Common/ since repositories return it.

IContactRepository: Same interface but with Contact type. Add: `Task<List<Contact>> GetByCompanyIdAsync(Guid companyId)` for the company detail contacts tab.

IProductRepository: Same interface but with Product type. No scope filtering needed (products are shared resources, not owned), so: `Task<PagedResult<Product>> GetPagedAsync(EntityQueryParams queryParams)` without scope params.

**Repository implementations** (Infrastructure/Persistence/Repositories/):

**CompanyRepository.cs:**
Constructor: inject ApplicationDbContext.

`GetPagedAsync`:
1. Start with `_db.Companies.AsQueryable()`
2. Apply ownership scope (research Pattern 3):
   - All: no additional filter
   - Team: Where(c => c.OwnerId == userId || (teamMemberIds != null && teamMemberIds.Contains(c.OwnerId!.Value)))
   - Own: Where(c => c.OwnerId == userId)
   - None: Where(_ => false)
3. Apply search: if Search is not empty, filter by Name.Contains(search) || Industry.Contains(search) || Email.Contains(search) || City.Contains(search) (case-insensitive via ToLower())
4. Apply filters via switch on FieldId:
   - Core fields (name, industry, city, state, country, email, phone, website, size): use standard LINQ string operations based on Operator (equals, contains, starts_with, not_equals)
   - Custom fields (fieldId is a GUID string, length 36): use raw SQL with JSONB containment: `query = query.Where(c => EF.Functions.JsonContains(c.CustomFields, $"{{\"{filter.FieldId}\": \"{filter.Value}\"}}"))`
   If EF.Functions.JsonContains is not available, use FromSqlRaw approach or simple JSONB extraction: the important thing is that custom field filters work. If EF Functions approach fails at build time, fall back to filtering by extracting the value: `query.Where(c => EF.Property<string>(c.CustomFields, filter.FieldId) == filter.Value)` -- test what compiles with Npgsql 10.
5. Apply sorting via switch-based field mapper (per research Open Question 1 -- no System.Linq.Dynamic.Core dependency):
   - Core fields: switch(sortField) { "name" => query.OrderBy(c => c.Name), "industry" => OrderBy(c => c.Industry), "city" => OrderBy(c => c.City), "createdAt" => OrderBy(c => c.CreatedAt), etc. }
   - Custom field sort (fieldId is GUID): use raw SQL OrderBy via `query.OrderBy(c => EF.Property<string>(c, "custom_fields"))` -- or skip custom field sorting for now and document as known limitation (custom field sort needs raw SQL). Default sort: CreatedAt descending.
   - Apply direction: if SortDirection == "desc", use OrderByDescending
6. Get TotalCount before pagination: `await query.CountAsync()`
7. Apply pagination: `.Skip((page - 1) * pageSize).Take(pageSize)`
8. Include Owner navigation: `.Include(c => c.Owner)` for owner name in DTOs
9. Return PagedResult with items, totalCount, page, pageSize

`GetByIdAsync`: `_db.Companies.Include(c => c.Owner).FirstOrDefaultAsync(c => c.Id == id)`
`CreateAsync`: Add to DbSet, SaveChangesAsync, return entity
`UpdateAsync`: Update entity, set UpdatedAt = UtcNow, SaveChangesAsync
`DeleteAsync`: Find by ID, Remove, SaveChangesAsync

**ContactRepository.cs:** Same pattern as CompanyRepository but:
- Search filters: FirstName, LastName, Email, JobTitle, Department
- Sort fields: firstName, lastName, email, jobTitle, companyName (for companyName sort, need .Include(c => c.Company) and .OrderBy(c => c.Company!.Name))
- Include Company navigation for company name in list DTOs
- GetByCompanyIdAsync: simple Where(c => c.CompanyId == companyId).ToListAsync()

**ProductRepository.cs:** Simpler -- no ownership scope:
- Search: Name, SKU, Category, Description
- Sort: name, unitPrice, sku, category, createdAt
- No Include needed (no navigation properties)
- Filter on isActive: support filtering by isActive boolean
  </action>
  <verify>`dotnet build` passes with 0 errors. All repository files exist in correct directories.</verify>
  <done>3 repository interfaces in Domain/Interfaces, 3 implementations in Infrastructure/Persistence/Repositories, shared EntityQueryParams in Api/Models, all with server-side filter/sort/page support</done>
</task>

<task type="auto">
  <name>Task 2: Update TenantSeeder and RoleTemplateSeeder for CRM entities</name>
  <files>
    src/GlobCRM.Infrastructure/MultiTenancy/TenantSeeder.cs
    src/GlobCRM.Infrastructure/Authorization/RoleTemplateSeeder.cs
  </files>
  <action>
**TenantSeeder update:**
The existing TenantSeeder has a seed manifest with Companies and Contacts but only logs it. Update SeedOrganizationDataAsync to actually create entities:

1. Inject ApplicationDbContext in addition to existing dependencies (or use the _organizationRepository's context)
2. After creating the seed manifest:
   - Create Company entities from seedManifest.Companies, setting TenantId = organizationId, IsSeedData = true
   - Store created companies in a Dictionary<string, Company> keyed by Name for contact linking
   - Create Contact entities from seedManifest.Contacts, setting TenantId = organizationId, CompanyId from the company dictionary lookup, IsSeedData = true
   - SaveChangesAsync after all entities are added
3. Keep the existing logging but change the final log to indicate entities were created (not just manifest logged)
4. Skip Deal creation for now (Deal entity doesn't exist until Phase 4) -- log that deal seeding is deferred
5. Also create Product seed data: add a few sample products to the manifest and create them:
   ```csharp
   Products = new List<ProductSeed>
   {
       new() { Name = "CRM Enterprise License", Description = "Annual enterprise license", UnitPrice = 499.99m, SKU = "CRM-ENT-001", Category = "Software" },
       new() { Name = "Premium Support", Description = "24/7 premium support package", UnitPrice = 99.99m, SKU = "SUP-PREM-001", Category = "Support" },
       new() { Name = "Data Migration Service", Description = "One-time data migration assistance", UnitPrice = 1500.00m, SKU = "SVC-MIG-001", Category = "Services" },
   }
   ```
   Add ProductSeed model to the seed manifest models region.

**RoleTemplateSeeder update:**
The existing RoleTemplateSeeder iterates over EntityType enum names to seed permissions. Since Company, Contact, Product already exist in the EntityType enum, the seeder should already handle them for NEW tenants. But for EXISTING tenants (whose roles were seeded before Phase 3), we need to ensure permissions are added.

Add a static method `EnsurePermissionsForAllEntityTypesAsync` following the research pattern:
1. Load all template roles for the given tenant with their permissions (Include(r => r.Permissions))
2. For each role, for each EntityType, for each operation (View, Create, Edit, Delete):
   - If the permission doesn't exist, add it with appropriate scope based on role name:
     - Admin: All
     - Manager: Team
     - Sales Rep: View=Team, Create/Edit/Delete=Own
     - Viewer: View=All, Create/Edit/Delete=None
3. SaveChangesAsync

Call this method from `SeedTemplateRolesAsync` after the existing role creation logic, or add it as a separate public method that can be called at startup. The simplest approach: call it at the end of SeedTemplateRolesAsync so it runs on every startup (it's idempotent -- only adds missing permissions).

**DI registration:**
Register the 3 new repositories in a new `CrmEntityServiceExtensions.cs` file or add to Program.cs following the subsystem pattern. Create `src/GlobCRM.Infrastructure/CrmEntities/CrmEntityServiceExtensions.cs` with AddCrmEntityServices() that registers ICompanyRepository, IContactRepository, IProductRepository as scoped services.
  </action>
  <verify>`dotnet build` passes with 0 errors. TenantSeeder.SeedOrganizationDataAsync creates Company and Contact entities. RoleTemplateSeeder handles new entity types.</verify>
  <done>TenantSeeder creates actual Company, Contact, Product entities from seed manifest. RoleTemplateSeeder ensures all entity types have permissions for template roles. Repository DI registration complete.</done>
</task>

</tasks>

<verification>
- `dotnet build` passes with 0 errors
- CompanyRepository.GetPagedAsync applies ownership scope, search, filters, sorting, pagination
- ContactRepository includes Company navigation for company name
- TenantSeeder creates Company and Contact entities with IsSeedData = true
- RoleTemplateSeeder adds permissions for Company, Contact, Product to existing roles
- All 3 repositories registered in DI
</verification>

<success_criteria>
- Server-side pagination works with OFFSET/LIMIT pattern
- Ownership scope filtering correctly applies None/Own/Team/All
- Custom field filtering uses JSONB-aware queries
- Core field sorting uses switch-based mapper (no dynamic LINQ dependency)
- Seed data creates 2 companies, 5 contacts, 3 products with proper company links
- Template roles have permissions for all EntityType values
</success_criteria>

<output>
After completion, create `.planning/phases/03-core-crm-entities/03-04-SUMMARY.md`
</output>
