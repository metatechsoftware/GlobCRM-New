---
phase: 03-core-crm-entities
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - globcrm-web/src/app/features/companies/company.models.ts
  - globcrm-web/src/app/features/companies/company.service.ts
  - globcrm-web/src/app/features/companies/company.store.ts
  - globcrm-web/src/app/features/contacts/contact.models.ts
  - globcrm-web/src/app/features/contacts/contact.service.ts
  - globcrm-web/src/app/features/contacts/contact.store.ts
  - globcrm-web/src/app/features/products/product.models.ts
  - globcrm-web/src/app/features/products/product.service.ts
  - globcrm-web/src/app/features/products/product.store.ts
autonomous: true

must_haves:
  truths:
    - "TypeScript interfaces match backend entity DTOs for all 3 entity types"
    - "API services provide full CRUD + paginated list methods for each entity"
    - "Signal stores manage list state (items, pagination, filters, sorts, search, loading) and detail state"
  artifacts:
    - path: "globcrm-web/src/app/features/companies/company.models.ts"
      provides: "CompanyDto, CompanyDetailDto, CreateCompanyRequest, UpdateCompanyRequest, PagedResult<T>"
      contains: "export interface CompanyDto"
    - path: "globcrm-web/src/app/features/companies/company.service.ts"
      provides: "CompanyService with getList, getById, create, update, delete, getTimeline"
      contains: "class CompanyService"
    - path: "globcrm-web/src/app/features/companies/company.store.ts"
      provides: "CompanyStore signal store with loadPage, setSort, setFilters, setSearch, loadDetail"
      contains: "CompanyStore"
    - path: "globcrm-web/src/app/features/contacts/contact.models.ts"
      provides: "ContactDto, ContactDetailDto with companyName, CreateContactRequest with companyId"
      contains: "export interface ContactDto"
    - path: "globcrm-web/src/app/features/contacts/contact.service.ts"
      provides: "ContactService with full CRUD + timeline"
      contains: "class ContactService"
    - path: "globcrm-web/src/app/features/contacts/contact.store.ts"
      provides: "ContactStore signal store"
      contains: "ContactStore"
    - path: "globcrm-web/src/app/features/products/product.models.ts"
      provides: "ProductDto with unitPrice, sku, category, isActive"
      contains: "export interface ProductDto"
    - path: "globcrm-web/src/app/features/products/product.service.ts"
      provides: "ProductService with full CRUD"
      contains: "class ProductService"
    - path: "globcrm-web/src/app/features/products/product.store.ts"
      provides: "ProductStore signal store"
      contains: "ProductStore"
  key_links:
    - from: "company.store.ts"
      to: "company.service.ts"
      via: "inject(CompanyService) in store methods"
      pattern: "inject.*CompanyService"
    - from: "company.service.ts"
      to: "/api/companies"
      via: "ApiService HTTP calls"
      pattern: "api/companies"
---

<objective>
Create TypeScript models, API services, and NgRx Signal Stores for Company, Contact, and Product entities -- establishing the frontend data layer that all entity pages will consume.

Purpose: Every entity list page, detail page, and form depends on these services and stores for data fetching, state management, and API communication. Building them first allows all 3 entity UI features to develop in parallel.

Output: 9 files (3 models + 3 services + 3 stores) in the companies/, contacts/, and products/ feature directories.
</objective>

<execution_context>
@/Users/metatech/.claude/get-shit-done/workflows/execute-plan.md
@/Users/metatech/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/03-core-crm-entities/03-RESEARCH.md
@globcrm-web/src/app/core/auth/auth.store.ts
@globcrm-web/src/app/shared/components/saved-views/view.store.ts
@globcrm-web/src/app/shared/components/saved-views/view.models.ts
@globcrm-web/src/app/core/api/api.service.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create entity models and API services for Company, Contact, Product</name>
  <files>
    globcrm-web/src/app/features/companies/company.models.ts
    globcrm-web/src/app/features/companies/company.service.ts
    globcrm-web/src/app/features/contacts/contact.models.ts
    globcrm-web/src/app/features/contacts/contact.service.ts
    globcrm-web/src/app/features/products/product.models.ts
    globcrm-web/src/app/features/products/product.service.ts
  </files>
  <action>
**Shared types (define in company.models.ts and re-export or create a shared file):**

Create a `PagedResult<T>` generic interface:
```typescript
export interface PagedResult<T> {
  items: T[];
  totalCount: number;
  page: number;
  pageSize: number;
  totalPages: number;
}
```

Create `EntityQueryParams` interface:
```typescript
export interface EntityQueryParams {
  page?: number;
  pageSize?: number;
  sortField?: string;
  sortDirection?: 'asc' | 'desc';
  search?: string;
  filters?: FilterParam[];
}

export interface FilterParam {
  fieldId: string;
  operator: string;
  value?: string;
}
```

Create a shared models file at `globcrm-web/src/app/shared/models/query.models.ts` for PagedResult, EntityQueryParams, FilterParam, and TimelineEntry. Then import from there in each entity's models file.

**TimelineEntry interface** (in shared query.models.ts):
```typescript
export interface TimelineEntry {
  id: string;
  type: 'created' | 'updated' | 'contact_linked' | 'contact_unlinked' | 'deal_created' | 'activity' | 'note' | 'email';
  title: string;
  description: string | null;
  timestamp: string;
  userId: string | null;
  userName: string | null;
}
```

**company.models.ts:**
- CompanyDto: id, name, industry, website, phone, email, city, state, country, ownerName (string|null), customFields (Record<string,any>), createdAt, updatedAt
- CompanyDetailDto: extends CompanyDto with address, postalCode, size, description, ownerId, contactCount (number)
- CreateCompanyRequest: name (required), industry, website, phone, email, address, city, state, country, postalCode, size, description, customFields (Record<string,any>)
- UpdateCompanyRequest: same fields as CreateCompanyRequest

**contact.models.ts:**
- ContactDto: id, firstName, lastName, fullName, email, phone, jobTitle, companyId, companyName (string|null), ownerName (string|null), customFields, createdAt, updatedAt
- ContactDetailDto: extends ContactDto with mobilePhone, department, address, city, state, country, postalCode, description, ownerId
- CreateContactRequest: firstName (required), lastName (required), email, phone, mobilePhone, jobTitle, department, address, city, state, country, postalCode, description, companyId (string|null), customFields
- UpdateContactRequest: same as Create

**product.models.ts:**
- ProductDto: id, name, description, unitPrice (number), sku, category, isActive (boolean), customFields, createdAt, updatedAt
- CreateProductRequest: name (required), description, unitPrice (required), sku, category, customFields
- UpdateProductRequest: same as Create plus isActive

**API Services** (follow existing ApiService pattern):

Each service is @Injectable({ providedIn: 'root' }) and uses the existing ApiService for HTTP calls.

**CompanyService:**
- getList(params: EntityQueryParams): Observable<PagedResult<CompanyDto>> -- GET /api/companies with query params
- getById(id: string): Observable<CompanyDetailDto> -- GET /api/companies/{id}
- create(request: CreateCompanyRequest): Observable<CompanyDto> -- POST /api/companies
- update(id: string, request: UpdateCompanyRequest): Observable<void> -- PUT /api/companies/{id}
- delete(id: string): Observable<void> -- DELETE /api/companies/{id}
- getTimeline(id: string): Observable<TimelineEntry[]> -- GET /api/companies/{id}/timeline

Build EntityQueryParams into HttpParams: skip nullish values, serialize filters array as JSON string param.

**ContactService:** Same CRUD pattern with /api/contacts endpoints. Add getTimeline method.

**ProductService:** Same CRUD pattern with /api/products endpoints. No getTimeline method (products don't have timelines).
  </action>
  <verify>`cd globcrm-web && npx ng build --configuration development 2>&1 | tail -5` -- should compile (may have warnings but no errors in these files)</verify>
  <done>6 model files and 6 service files exist with correct TypeScript interfaces matching the backend API contracts</done>
</task>

<task type="auto">
  <name>Task 2: Create NgRx Signal Stores for Company, Contact, Product</name>
  <files>
    globcrm-web/src/app/features/companies/company.store.ts
    globcrm-web/src/app/features/contacts/contact.store.ts
    globcrm-web/src/app/features/products/product.store.ts
  </files>
  <action>
Create signal stores following the pattern from research (Pattern 7) and the existing ViewStore/AuthStore patterns in the codebase.

**CompanyStore** (will be component-provided, like ViewStore):

```typescript
import { signalStore, withState, withMethods, patchState } from '@ngrx/signals';
```

State interface:
```typescript
interface CompanyState {
  items: CompanyDto[];
  totalCount: number;
  page: number;
  pageSize: number;
  sortField: string | null;
  sortDirection: 'asc' | 'desc';
  filters: ViewFilter[];
  search: string;
  isLoading: boolean;
  selectedCompany: CompanyDetailDto | null;
  isDetailLoading: boolean;
}
```

Initial state: items=[], totalCount=0, page=1, pageSize=25, sortField=null, sortDirection='asc', filters=[], search='', isLoading=false, selectedCompany=null, isDetailLoading=false.

Methods (using inject(CompanyService)):
- `loadPage()`: Build EntityQueryParams from current state (page, pageSize, sortField, sortDirection, search, filters converted to FilterParam[]), call service.getList(), patchState with items + totalCount. Set isLoading true before, false after. Use rxMethod or manual subscribe with firstValueFrom.
- `setSort(field: string, direction: 'asc'|'desc')`: patchState sort fields + reset page to 1, then call loadPage()
- `setFilters(filters: ViewFilter[])`: patchState filters + reset page to 1, then call loadPage()
- `setSearch(search: string)`: patchState search + reset page to 1, then call loadPage()
- `setPage(page: number)`: patchState page, then call loadPage()
- `setPageSize(pageSize: number)`: patchState pageSize + reset page to 1, then call loadPage()
- `loadDetail(id: string)`: Set isDetailLoading=true, call service.getById(id), patchState selectedCompany, set isDetailLoading=false
- `clearDetail()`: patchState selectedCompany=null

Convert ViewFilter[] to FilterParam[] by mapping: { fieldId: filter.fieldId, operator: filter.operator, value: filter.value }.

Import ViewFilter from the existing view.models.ts to maintain consistency with the dynamic table filter system.

**ContactStore:** Identical pattern to CompanyStore but with ContactDto/ContactDetailDto types and ContactService injection.

**ProductStore:** Same pattern but with ProductDto types and ProductService injection. No selectedProduct detail loading needed initially (product detail is simpler), but include it for consistency.

All three stores should be exported as named constants (CompanyStore, ContactStore, ProductStore) so they can be component-provided in list pages.
  </action>
  <verify>`cd globcrm-web && npx ng build --configuration development 2>&1 | tail -5` compiles without errors</verify>
  <done>3 signal stores exist with loadPage, setSort, setFilters, setSearch, setPage, loadDetail methods matching the dynamic table integration pattern</done>
</task>

</tasks>

<verification>
- All 9+ files exist in the correct feature directories
- TypeScript compilation passes (ng build)
- Models match the backend API contract from the research
- Stores follow the ViewStore pattern (component-provided signal stores)
- Services use ApiService for HTTP calls
- Shared query models (PagedResult, EntityQueryParams, TimelineEntry) are in shared/models/
</verification>

<success_criteria>
- CompanyDto, ContactDto, ProductDto interfaces cover all core + custom fields
- API services have full CRUD + pagination methods
- Signal stores manage list state (items, pagination, filters, sorts) and detail state
- Stores are designed for component-level provision (not root)
- ng build compiles successfully
</success_criteria>

<output>
After completion, create `.planning/phases/03-core-crm-entities/03-02-SUMMARY.md`
</output>
