---
phase: 09-dashboards-and-reporting
plan: 03
type: execute
wave: 3
depends_on: ["09-02"]
files_modified:
  - src/GlobCRM.Api/Controllers/DashboardsController.cs
autonomous: true

must_haves:
  truths:
    - "User can create, read, update, and delete dashboards via REST API"
    - "User can fetch batched widget data (metrics) for a dashboard with date range"
    - "User can create, read, update, and delete KPI targets via REST API"
    - "API enforces ownership (personal dashboards only editable by owner, team-wide by admin)"
    - "Metrics endpoint respects RBAC scope so users only see data they have permission to access"
  artifacts:
    - path: "src/GlobCRM.Api/Controllers/DashboardsController.cs"
      provides: "REST API for dashboards CRUD, widget data batch, and targets CRUD"
      exports: ["GET /api/dashboards", "POST /api/dashboards", "GET /api/dashboards/{id}", "PUT /api/dashboards/{id}", "DELETE /api/dashboards/{id}", "POST /api/dashboards/{id}/widget-data", "GET /api/targets", "POST /api/targets", "PUT /api/targets/{id}", "DELETE /api/targets/{id}"]
  key_links:
    - from: "src/GlobCRM.Api/Controllers/DashboardsController.cs"
      to: "DashboardAggregationService"
      via: "ComputeMetricsAsync for batched widget data"
      pattern: "_aggregationService.ComputeMetricsAsync"
    - from: "src/GlobCRM.Api/Controllers/DashboardsController.cs"
      to: "IPermissionService"
      via: "Scope resolution for RBAC-filtered metrics"
      pattern: "GetPermissionScopeAsync"
---

<objective>
Create the DashboardsController providing REST API endpoints for dashboard CRUD, batched widget metric data, and KPI target management.

Purpose: The controller is the API surface that the Angular frontend calls. The critical endpoint is the batched widget-data POST that fetches all widget metrics in a single request (avoiding N+1 API calls). Dashboard ownership enforcement ensures personal dashboards are owner-only while team-wide dashboards require admin role.
Output: One controller file with dashboard CRUD, widget data batch endpoint, and target CRUD.
</objective>

<execution_context>
@/Users/metatech/.claude/get-shit-done/workflows/execute-plan.md
@/Users/metatech/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/09-dashboards-and-reporting/09-RESEARCH.md
@.planning/phases/09-dashboards-and-reporting/09-01-SUMMARY.md
@.planning/phases/09-dashboards-and-reporting/09-02-SUMMARY.md

@src/GlobCRM.Api/Controllers/NotificationsController.cs (controller pattern reference)
@src/GlobCRM.Api/Controllers/DealsController.cs (RBAC scope pattern reference)
</context>

<tasks>

<task type="auto">
  <name>Task 1: DashboardsController with dashboard CRUD and widget data batch</name>
  <files>
    src/GlobCRM.Api/Controllers/DashboardsController.cs
  </files>
  <action>
    Create DashboardsController at `src/GlobCRM.Api/Controllers/DashboardsController.cs`.

    Controller-level: [ApiController], [Route("api/dashboards")], [Authorize]. Inject IDashboardRepository, ITargetRepository, DashboardAggregationService, IPermissionService, UserManager of ApplicationUser.

    Define DTOs as records inside the controller file (matching EmailsController pattern):

    **Dashboard DTOs:**
    - DashboardDto: Id, Name, Description, OwnerId, OwnerName, IsDefault, IsTeamWide (computed: OwnerId == null), Widgets (list of WidgetDto), CreatedAt, UpdatedAt
    - WidgetDto: Id, Type (string), Title, X, Y, Cols, Rows, Config (Dictionary of string,object?), SortOrder
    - CreateDashboardRequest: Name, Description, IsTeamWide (bool), IsDefault, Widgets (list of CreateWidgetRequest)
    - CreateWidgetRequest: Type (string), Title, X, Y, Cols, Rows, Config (Dictionary of string,object?), SortOrder
    - UpdateDashboardRequest: Name, Description, IsDefault, Widgets (list of CreateWidgetRequest)

    **Widget Data DTOs:**
    - WidgetDataRequest: Widgets (list of WidgetMetricRequest), StartDate (DateTimeOffset), EndDate (DateTimeOffset)
    - WidgetMetricRequest: WidgetId (string), MetricType (string), Config (Dictionary of string,object?)
    - WidgetDataResponse: Results (Dictionary of string to MetricResultDto)
    - MetricResultDto: Value (decimal), Label (string), Series (list of ChartDataPointDto)?
    - ChartDataPointDto: Label (string), Value (decimal)

    **Target DTOs:**
    - TargetDto: Id, Name, MetricType (string), Period (string), TargetValue, CurrentValue (decimal -- computed by aggregation), OwnerId, OwnerName, StartDate, EndDate, ProgressPercent (computed), CreatedAt, UpdatedAt
    - CreateTargetRequest: Name, MetricType (string), Period (string), TargetValue, StartDate, EndDate, IsTeamWide (bool)
    - UpdateTargetRequest: Name, TargetValue, StartDate, EndDate

    **Dashboard Endpoints:**
    - GET /api/dashboards -- List all dashboards (personal + team-wide) for current user. Map to DashboardDto list.
    - POST /api/dashboards -- Create dashboard. If request.IsTeamWide, set OwnerId = null (requires Admin role check via User.IsInRole("Admin")). Otherwise OwnerId = current user ID.
    - GET /api/dashboards/{id} -- Get dashboard with widgets. Verify ownership: if dashboard has OwnerId and it != current user, return 403 (unless admin).
    - PUT /api/dashboards/{id} -- Update dashboard. Same ownership check. For team-wide dashboards, require Admin role. Widget updates use full-replacement via repository.
    - DELETE /api/dashboards/{id} -- Delete. Same ownership/admin check.

    **Widget Data Endpoint (CRITICAL -- batched):**
    - POST /api/dashboards/{id}/widget-data -- Accepts WidgetDataRequest with list of widgets + date range. Resolves current user's RBAC scope via IPermissionService (check Deal:View scope for deal metrics, Activity:View for activity metrics, etc.). Calls DashboardAggregationService.ComputeMetricsAsync with resolved scope. Returns WidgetDataResponse with results keyed by WidgetId.

    For RBAC scope resolution: For each metric type, determine which entity it queries (Deals, Activities, Contacts, etc.), then call IPermissionService to get the user's scope for that entity. Pass scope + teamMemberIds to aggregation service. If user has no permission for the entity, return zero/empty for that metric.

    **Target Endpoints:**
    - GET /api/targets -- List all targets (personal + team-wide). For each target, compute current value by calling aggregation service with the target's metric/date range. Compute progressPercent = (currentValue / targetValue) * 100.
    - POST /api/targets -- Create target. IsTeamWide -> OwnerId null (admin only). Else OwnerId = current user.
    - PUT /api/targets/{id} -- Update. Ownership check.
    - DELETE /api/targets/{id} -- Delete. Ownership check.
  </action>
  <verify>`dotnet build src/GlobCRM.Api/` succeeds. Verify controller compiles with all endpoints.</verify>
  <done>DashboardsController provides dashboard CRUD (5 endpoints), batched widget data (1 endpoint), and target CRUD (4 endpoints) with ownership enforcement and RBAC-scoped metrics</done>
</task>

</tasks>

<verification>
- `dotnet build` succeeds
- Dashboard CRUD enforces ownership (personal = owner only, team-wide = admin only for create/edit)
- Widget data endpoint batches multiple metric requests
- Target endpoints compute current progress from aggregation service
- All DTOs defined as records inside controller file
</verification>

<success_criteria>
- 10 REST endpoints created covering dashboard CRUD, widget data batch, and target CRUD
- Ownership enforcement: personal dashboards/targets are owner-only, team-wide require Admin role
- RBAC scope applied to all metric queries via IPermissionService
- No raw entity queries in controller -- all aggregation through DashboardAggregationService
</success_criteria>

<output>
After completion, create `.planning/phases/09-dashboards-and-reporting/09-03-SUMMARY.md`
</output>
