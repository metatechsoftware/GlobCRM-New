---
phase: 09-dashboards-and-reporting
plan: 02
type: execute
wave: 2
depends_on: ["09-01"]
files_modified:
  - src/GlobCRM.Infrastructure/Dashboards/DashboardRepository.cs
  - src/GlobCRM.Infrastructure/Dashboards/TargetRepository.cs
  - src/GlobCRM.Infrastructure/Dashboards/DashboardAggregationService.cs
  - src/GlobCRM.Infrastructure/Dashboards/DashboardServiceExtensions.cs
  - src/GlobCRM.Api/Program.cs
autonomous: true

must_haves:
  truths:
    - "DashboardRepository provides CRUD with personal/team-wide dashboard listing"
    - "TargetRepository provides CRUD with metric-based lookups"
    - "DashboardAggregationService computes all 20 metrics server-side using EF Core projections"
    - "Aggregation respects RBAC ownership scope (Own/Team/All) so users only see permitted data"
    - "DI registration follows existing subsystem extension pattern"
  artifacts:
    - path: "src/GlobCRM.Infrastructure/Dashboards/DashboardRepository.cs"
      provides: "Dashboard CRUD with Include(Widgets) and owner filtering"
      contains: "class DashboardRepository"
    - path: "src/GlobCRM.Infrastructure/Dashboards/DashboardAggregationService.cs"
      provides: "Server-side metric computation with GroupBy/Sum/Count projections"
      contains: "class DashboardAggregationService"
    - path: "src/GlobCRM.Infrastructure/Dashboards/DashboardServiceExtensions.cs"
      provides: "AddDashboardServices DI extension"
      contains: "AddDashboardServices"
  key_links:
    - from: "src/GlobCRM.Infrastructure/Dashboards/DashboardAggregationService.cs"
      to: "ApplicationDbContext.Deals, Activities, Quotes, Contacts, Companies, Requests"
      via: "EF Core GroupBy/Sum/Count projection queries"
      pattern: "GroupBy.*Select.*Count|Sum"
    - from: "src/GlobCRM.Api/Program.cs"
      to: "src/GlobCRM.Infrastructure/Dashboards/DashboardServiceExtensions.cs"
      via: "builder.Services.AddDashboardServices()"
      pattern: "AddDashboardServices"
---

<objective>
Create the dashboard repository, target repository, centralized aggregation service, and DI registration for the dashboard subsystem.

Purpose: The DashboardAggregationService is the core of the reporting feature -- it computes all 20 metrics server-side using EF Core projections (never raw entity queries) and respects RBAC scope. The repositories handle Dashboard/Target CRUD with the SavedView ownership pattern.
Output: Three service classes, one DI extension, Program.cs registration.
</objective>

<execution_context>
@/Users/metatech/.claude/get-shit-done/workflows/execute-plan.md
@/Users/metatech/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/09-dashboards-and-reporting/09-RESEARCH.md
@.planning/phases/09-dashboards-and-reporting/09-01-SUMMARY.md

@src/GlobCRM.Infrastructure/Notifications/NotificationRepository.cs (repository pattern reference)
@src/GlobCRM.Infrastructure/Notifications/NotificationServiceExtensions.cs (DI extension pattern)
@src/GlobCRM.Infrastructure/Persistence/Repositories/DealRepository.cs (aggregation query pattern)
@src/GlobCRM.Infrastructure/Persistence/ApplicationDbContext.cs (DbSet access)
@src/GlobCRM.Domain/Interfaces/IPermissionService.cs (RBAC scope resolution)
@src/GlobCRM.Api/Program.cs (DI registration point)
</context>

<tasks>

<task type="auto">
  <name>Task 1: Dashboard and Target repositories</name>
  <files>
    src/GlobCRM.Infrastructure/Dashboards/DashboardRepository.cs
    src/GlobCRM.Infrastructure/Dashboards/TargetRepository.cs
  </files>
  <action>
    Create `src/GlobCRM.Infrastructure/Dashboards/` directory.

    **DashboardRepository.cs** -- implements IDashboardRepository:
    - Constructor takes ApplicationDbContext
    - GetByIdAsync: Include(d => d.Widgets) for full dashboard load with widgets
    - GetAllAsync(Guid? ownerId): Returns dashboards where OwnerId == ownerId (personal) OR OwnerId == null (team-wide). This gives the user both their personal dashboards and all team-wide dashboards.
    - GetDefaultAsync(Guid? ownerId): Returns the dashboard marked IsDefault for the given owner, or the first team-wide default if no personal default exists
    - CreateAsync: Adds and saves, returns created dashboard
    - UpdateAsync: Updates dashboard properties and widgets. For widgets, use full-replacement strategy (remove existing, add new) matching the permission update pattern from Phase 02. This ensures widget position/config changes are atomic.
    - DeleteAsync: Remove by ID

    **TargetRepository.cs** -- implements ITargetRepository:
    - Constructor takes ApplicationDbContext
    - GetByIdAsync: Simple find by ID
    - GetAllAsync(Guid? ownerId): Returns targets where OwnerId == ownerId OR OwnerId == null (team + personal)
    - GetByMetricAsync: Filter by MetricType and optional ownerId
    - CreateAsync, UpdateAsync, DeleteAsync: Standard CRUD
  </action>
  <verify>`dotnet build src/GlobCRM.Infrastructure/`</verify>
  <done>Both repositories implement their interfaces with correct Include patterns and ownership filtering</done>
</task>

<task type="auto">
  <name>Task 2: DashboardAggregationService and DI registration</name>
  <files>
    src/GlobCRM.Infrastructure/Dashboards/DashboardAggregationService.cs
    src/GlobCRM.Infrastructure/Dashboards/DashboardServiceExtensions.cs
    src/GlobCRM.Api/Program.cs
  </files>
  <action>
    **DashboardAggregationService.cs:**
    - Scoped service, constructor takes ApplicationDbContext and IPermissionService
    - Main method: `ComputeMetricAsync(MetricType metric, DateTimeOffset start, DateTimeOffset end, Guid userId, PermissionScope scope, List of Guid teamMemberIds)`
    - The userId/scope/teamMemberIds are resolved by the controller and passed in. The service applies ownership scope to queries:
      - All scope: no user filter
      - Team scope: filter by OwnerId in teamMemberIds
      - Own scope: filter by OwnerId == userId
    - Returns a `MetricResult` record: { Value (decimal), Label (string), Series (List of ChartDataPoint)? }
    - `ChartDataPoint` record: { Label (string), Value (decimal) }
    - `LeaderboardEntry` record: { UserId (Guid), Name (string), Value (decimal), Count (int) }

    Implement all 20 metrics using switch expression on MetricType:
    - **DealCount**: Deals.Where(date range).CountAsync() -- returns single value
    - **DealPipelineValue**: Deals.Where(date range).SumAsync(d => d.Value ?? 0)
    - **DealsByStage**: Deals.Where(date range).Include Stage, GroupBy Stage.Name, Select { Label, Count, Sum(Value) }
    - **DealsWon**: Deals.Where(date range).Where(Stage.IsWon).CountAsync()
    - **DealsLost**: Deals.Where(date range).Where(Stage.IsLost).CountAsync()
    - **WinRate**: Compute won/(won+lost) as percentage
    - **AverageDealValue**: Deals.Where(date range).AverageAsync(d => d.Value ?? 0)
    - **ActivityCount**: Activities.Where(date range).CountAsync()
    - **ActivitiesByType**: GroupBy Type, Select { Label=Type.ToString(), Count }
    - **ActivitiesByStatus**: GroupBy Status, Select { Label=Status.ToString(), Count }
    - **ActivitiesCompleted**: Activities.Where(Status == Done, date range).CountAsync()
    - **OverdueActivities**: Activities.Where(DueDate < DateTimeOffset.UtcNow, Status != Done).CountAsync()
    - **QuoteTotal**: Quotes.Where(date range).SumAsync(q => q.GrandTotal)
    - **QuotesByStatus**: GroupBy Status, Select { Label, Count }
    - **ContactsCreated**: Contacts.Where(date range).CountAsync()
    - **CompaniesCreated**: Companies.Where(date range).CountAsync()
    - **RequestsByStatus**: GroupBy Status, Select { Label, Count }
    - **RequestsByPriority**: GroupBy Priority, Select { Label, Count }
    - **SalesLeaderboard**: Deals.Where(Stage.IsWon, date range).GroupBy Owner, Select { Name, Count, Sum(Value) } -- returns as Series
    - **ActivityLeaderboard**: Activities.Where(Status == Done, date range).GroupBy AssignedTo, Select { Name, Count } -- returns as Series

    Use EF Core projections (GroupBy/Select/Sum/Count) -- NEVER load full entities. This is the anti-pattern from research.

    Also add a batch method: `ComputeMetricsAsync(List of (MetricType, Dictionary of string,object? config), DateTimeOffset start, DateTimeOffset end, Guid userId, PermissionScope scope, List of Guid teamMemberIds)` that returns Dictionary of MetricType to MetricResult. This batches multiple widget data requests into one call to avoid N+1 API calls per research guidance.

    **DashboardServiceExtensions.cs:**
    - AddDashboardServices extension method
    - Register DashboardRepository as IDashboardRepository (scoped)
    - Register TargetRepository as ITargetRepository (scoped)
    - Register DashboardAggregationService (scoped)

    **Program.cs:** Add `builder.Services.AddDashboardServices();` after the existing AddFeedServices() call.
  </action>
  <verify>`dotnet build src/GlobCRM.Api/` -- full solution builds. Verify DashboardAggregationService has all 20 metric switch cases.</verify>
  <done>Aggregation service computes all 20 metrics with ownership scope filtering, repositories provide CRUD, and all services registered in DI</done>
</task>

</tasks>

<verification>
- `dotnet build` succeeds for full solution
- DashboardAggregationService covers all 20 MetricType enum values
- Ownership scope (Own/Team/All) applied to all aggregation queries
- DI registration follows subsystem extension pattern (separate from DependencyInjection.cs)
- Program.cs calls AddDashboardServices()
</verification>

<success_criteria>
- Aggregation service uses EF Core projections (GroupBy/Sum/Count) -- no full entity loading
- Batch method supports fetching multiple metrics in one call
- Repositories use Include(Widgets) for dashboard load and ownership-based filtering
- All services registered as scoped in DI container
</success_criteria>

<output>
After completion, create `.planning/phases/09-dashboards-and-reporting/09-02-SUMMARY.md`
</output>
