---
phase: 17-webhooks
plan: 02
type: execute
wave: 2
depends_on: [17-01]
files_modified:
  - src/GlobCRM.Infrastructure/Webhooks/WebhookDomainEventHandler.cs
  - src/GlobCRM.Infrastructure/Webhooks/WebhookDeliveryService.cs
  - src/GlobCRM.Infrastructure/Webhooks/WebhookPayloadBuilder.cs
  - src/GlobCRM.Infrastructure/Webhooks/WebhookSsrfValidator.cs
  - src/GlobCRM.Infrastructure/Webhooks/WebhookServiceExtensions.cs
  - src/GlobCRM.Infrastructure/DependencyInjection.cs
autonomous: true
requirements:
  - WHOOK-02
  - WHOOK-03
  - WHOOK-06

must_haves:
  truths:
    - "When a CRM entity is created/updated/deleted, matching webhook subscriptions receive delivery jobs enqueued to Hangfire"
    - "Webhook payloads are signed with HMAC-SHA256 using the subscription's secret, with signature in X-Webhook-Signature header"
    - "Failed deliveries are retried with exponential backoff (immediate, 1min, 5min, 30min, 2hr, 8hr, 24hr) with jitter"
    - "Subscriptions auto-disable after 50 consecutive failures"
    - "SSRF validation rejects private/loopback/link-local IPs on every delivery attempt"
    - "Webhook payloads include full entity snapshot, changes object (old/new), and standard envelope"
  artifacts:
    - path: "src/GlobCRM.Infrastructure/Webhooks/WebhookDomainEventHandler.cs"
      provides: "IDomainEventHandler that matches events to subscriptions and enqueues Hangfire jobs"
      contains: "class WebhookDomainEventHandler"
    - path: "src/GlobCRM.Infrastructure/Webhooks/WebhookDeliveryService.cs"
      provides: "HTTP delivery with HMAC signing, retry scheduling, failure tracking, auto-disable"
      contains: "class WebhookDeliveryService"
    - path: "src/GlobCRM.Infrastructure/Webhooks/WebhookPayloadBuilder.cs"
      provides: "Entity serialization with changes tracking and envelope structure"
      contains: "class WebhookPayloadBuilder"
    - path: "src/GlobCRM.Infrastructure/Webhooks/WebhookSsrfValidator.cs"
      provides: "URL and DNS validation against SSRF attacks"
      contains: "class WebhookSsrfValidator"
  key_links:
    - from: "src/GlobCRM.Infrastructure/Webhooks/WebhookDomainEventHandler.cs"
      to: "Hangfire IBackgroundJobClient"
      via: "Enqueues WebhookDeliveryService.DeliverAsync to webhooks queue"
      pattern: "Enqueue.*DeliverAsync"
    - from: "src/GlobCRM.Infrastructure/Webhooks/WebhookDeliveryService.cs"
      to: "src/GlobCRM.Infrastructure/Webhooks/WebhookSsrfValidator.cs"
      via: "Validates URL before every HTTP delivery attempt"
      pattern: "ValidateUrlAsync"
    - from: "src/GlobCRM.Infrastructure/Webhooks/WebhookDeliveryService.cs"
      to: "Hangfire BackgroundJob.Schedule"
      via: "Schedules retry with exponential backoff on failure"
      pattern: "BackgroundJob\\.Schedule"
---

<objective>
Build the webhook delivery pipeline: domain event handler that matches events to subscriptions and enqueues Hangfire jobs, delivery service with HMAC-SHA256 signing and exponential retry, payload builder for entity serialization with change tracking, and SSRF validator for URL security.

Purpose: This is the core engine of the webhook system — everything between a domain event firing and an HTTP request landing at an external URL.
Output: WebhookDomainEventHandler, WebhookDeliveryService, WebhookPayloadBuilder, WebhookSsrfValidator, and DI registration.
</objective>

<execution_context>
@/Users/metatech/.claude/get-shit-done/workflows/execute-plan.md
@/Users/metatech/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/17-webhooks/17-RESEARCH.md
@.planning/phases/17-webhooks/17-01-SUMMARY.md
@src/GlobCRM.Domain/Interfaces/IDomainEvent.cs
@src/GlobCRM.Infrastructure/DomainEvents/DomainEventInterceptor.cs
@src/GlobCRM.Infrastructure/DomainEvents/DomainEventDispatcher.cs
@src/GlobCRM.Infrastructure/BackgroundJobs/HangfireServiceExtensions.cs
@src/GlobCRM.Infrastructure/BackgroundJobs/TenantJobFilter.cs
@src/GlobCRM.Infrastructure/BackgroundJobs/TenantScope.cs
@src/GlobCRM.Infrastructure/Notifications/NotificationDispatcher.cs
@src/GlobCRM.Domain/Entities/Contact.cs
@src/GlobCRM.Domain/Entities/Company.cs
@src/GlobCRM.Domain/Entities/Deal.cs
@src/GlobCRM.Domain/Entities/Lead.cs
@src/GlobCRM.Domain/Entities/Activity.cs
</context>

<tasks>

<task type="auto">
  <name>Task 1: WebhookPayloadBuilder, WebhookSsrfValidator, and WebhookDomainEventHandler</name>
  <files>
    src/GlobCRM.Infrastructure/Webhooks/WebhookPayloadBuilder.cs
    src/GlobCRM.Infrastructure/Webhooks/WebhookSsrfValidator.cs
    src/GlobCRM.Infrastructure/Webhooks/WebhookDomainEventHandler.cs
  </files>
  <action>
    **1. Create WebhookPayloadBuilder** at `src/GlobCRM.Infrastructure/Webhooks/WebhookPayloadBuilder.cs`:
    - Purpose: Serialize entity objects into webhook payload dictionaries. NOT reusing existing DTOs (per research — DTOs change frequently, webhook payloads should be stable API contracts).
    - Method: `string BuildPayload(DomainEvent domainEvent, WebhookSubscription subscription)` — returns serialized JSON string.
    - Payload envelope (Claude's discretion from context):
      ```json
      {
        "id": "delivery-uuid",
        "timestamp": "ISO8601",
        "version": "1.0",
        "tenantId": "tenant-uuid",
        "event": "contact.updated",
        "data": { ... entity fields ... },
        "changes": { "fieldName": { "old": ..., "new": ... } }
      }
      ```
    - Entity serialization: For each of the 5 entity types (Contact, Company, Deal, Lead, Activity), create a dictionary with key properties. Use a switch on `domainEvent.EntityName` to pick the right serializer. Use reflection as fallback for unknown entity types (future-proofing).
    - For update events: Build "changes" dictionary from `domainEvent.ChangedProperties` (new values) and `domainEvent.OldPropertyValues` (old values). Each changed field has `{ "old": oldValue, "new": newValue }`.
    - For delete events: Include full entity snapshot (captured before deletion per research recommendation).
    - CustomFields: Only include if `subscription.IncludeCustomFields == true`. Check entity has a `CustomFields` property.
    - Serialize with `System.Text.Json.JsonSerializer` using camelCase naming policy.
    - IMPORTANT: This method runs inside the domain event handler (while entity is still in memory). The returned string is passed to the Hangfire job.

    **2. Create WebhookSsrfValidator** at `src/GlobCRM.Infrastructure/Webhooks/WebhookSsrfValidator.cs`:
    - Method: `Task<(bool IsValid, string? Error)> ValidateUrlAsync(string url)`
    - Validations:
      - URL must be valid absolute URI
      - Scheme must be HTTPS only
      - Resolve DNS via `Dns.GetHostAddressesAsync(uri.Host)` — FRESH resolution every time (prevents DNS rebinding)
      - Check each resolved IP against blocked networks:
        - 10.0.0.0/8, 172.16.0.0/12, 192.168.0.0/16 (RFC1918)
        - 127.0.0.0/8 (loopback)
        - 169.254.0.0/16 (link-local)
        - 0.0.0.0/8 ("this" network)
        - ::1/128 (IPv6 loopback), fc00::/7 (IPv6 ULA), fe80::/10 (IPv6 link-local)
      - Use `System.Net.IPNetwork` (or manual byte comparison) for CIDR matching
    - Static method: `bool IsPrivateIp(IPAddress address)` for reuse

    **3. Create WebhookDomainEventHandler** at `src/GlobCRM.Infrastructure/Webhooks/WebhookDomainEventHandler.cs`:
    - Implements `IDomainEventHandler`
    - Dependencies: `IBackgroundJobClient` (Hangfire), `IWebhookRepository`, `ITenantProvider`, `WebhookPayloadBuilder`, `IMemoryCache`, `ILogger`
    - Eligible entities: `HashSet<string> { "Contact", "Company", "Deal", "Lead", "Activity" }` — per locked decision
    - HandleAsync flow:
      1. Check if entity is eligible (early return if not)
      2. Get tenant ID from ITenantProvider (early return if null)
      3. Load active subscriptions — use IMemoryCache with 60-second TTL keyed by `$"webhook_subs_{tenantId}"`. Cache the list of active subscriptions to avoid DB query on every SaveChanges (per research recommendation).
      4. For each subscription, check if `EventSubscriptions` contains `$"{domainEvent.EntityName}.{domainEvent.EventType}"`
      5. If match: serialize payload NOW (while entity is in memory — per pitfall #1) using WebhookPayloadBuilder
      6. Enqueue Hangfire job: `_jobClient.Enqueue<WebhookDeliveryService>(svc => svc.DeliverAsync(sub.Id, payload, tenantId.Value, 0))` — attemptNumber starts at 0
    - Cache invalidation: Add a method `InvalidateCache(Guid tenantId)` to remove the cache entry. This will be called from the API controller on subscription CRUD.
    - CRITICAL: The handler must be FAST. Only: check cache, match, serialize, enqueue. No network calls.
  </action>
  <verify>
    `cd src/GlobCRM.Api && dotnet build` — 0 errors. Verify WebhookPayloadBuilder produces JSON with envelope structure. Verify WebhookSsrfValidator rejects 127.0.0.1, 10.0.0.1, etc. Verify WebhookDomainEventHandler implements IDomainEventHandler and uses IMemoryCache.
  </verify>
  <done>WebhookPayloadBuilder serializes entities with envelope, changes, and optional custom fields. WebhookSsrfValidator blocks private/loopback/link-local IPs with DNS re-resolution. WebhookDomainEventHandler matches events to cached subscriptions and enqueues Hangfire delivery jobs.</done>
</task>

<task type="auto">
  <name>Task 2: WebhookDeliveryService with HMAC signing, retry, auto-disable, and DI registration</name>
  <files>
    src/GlobCRM.Infrastructure/Webhooks/WebhookDeliveryService.cs
    src/GlobCRM.Infrastructure/Webhooks/WebhookServiceExtensions.cs
    src/GlobCRM.Infrastructure/DependencyInjection.cs
  </files>
  <action>
    **1. Create WebhookDeliveryService** at `src/GlobCRM.Infrastructure/Webhooks/WebhookDeliveryService.cs`:
    - Public constant: `public const string QueueName = "webhooks";`
    - Dependencies: `IHttpClientFactory`, `IWebhookRepository`, `WebhookSsrfValidator`, `NotificationDispatcher`, `IBackgroundJobClient`, `ITenantProvider`, `ILogger`
    - Hangfire attribute: `[Queue("webhooks")]` and `[AutomaticRetry(Attempts = 0)]` — disable Hangfire auto-retry; we manage retries manually per research recommendation.

    **Main method: `DeliverAsync(Guid subscriptionId, string jsonPayload, Guid tenantId, int attemptNumber)`**

    Flow:
    1. Set tenant scope: `TenantScope.SetCurrentTenant(tenantId)` — ensure DbContext tenant filtering works
    2. Load subscription from repository by ID. If not found or IsActive=false or IsDisabled=true, log and return (no delivery).
    3. SSRF validate the URL via `WebhookSsrfValidator.ValidateUrlAsync(subscription.Url)`. If invalid, log failure to delivery log and return (do NOT retry — permanent error).
    4. Sign the payload: Use `System.Security.Cryptography.HMACSHA256` with subscription.Secret as key. Compute hash of `jsonPayload` bytes (UTF-8). Convert to lowercase hex string. Format as `sha256={hexHash}`.
    5. Create HTTP request:
       - Method: POST to subscription.Url
       - Content-Type: application/json
       - Headers: `X-Webhook-Signature: sha256={hash}`, `X-Webhook-Id: {deliveryId}`, `X-Webhook-Timestamp: {unixSeconds}`
       - Body: jsonPayload (the raw string — NEVER re-serialize, per anti-pattern in research)
    6. Send via named HttpClient "WebhookDelivery" from IHttpClientFactory (30s timeout, no auto-redirect)
    7. Create WebhookDeliveryLog entry with: attempt number, success/failure, HTTP status code, response body (truncated to 1KB), duration in ms, error message if failed.
    8. On success (2xx): Reset subscription.ConsecutiveFailureCount to 0, update LastDeliveryAt.
    9. On failure:
       a. Increment ConsecutiveFailureCount
       b. Check if count >= 50: if so, set IsDisabled=true, DisabledAt=now, DisabledReason="Auto-disabled after 50 consecutive delivery failures"
       c. If auto-disabled: dispatch notifications — both email alert AND in-app notification via NotificationDispatcher to the subscription's CreatedByUserId (per locked decision). Add `WebhookAutoDisabled` to NotificationType enum.
       d. If NOT auto-disabled and attemptNumber < 7: schedule retry via `BackgroundJob.Schedule<WebhookDeliveryService>(...)` with exponential backoff + jitter:
          - Retry delays (seconds): [0, 60, 300, 1800, 7200, 28800, 86400] (immediate, 1min, 5min, 30min, 2hr, 8hr, 24hr)
          - Jitter: add `Random.Shared.Next(0, baseDelay / 10 + 1)` (10% jitter)
       e. Only retry on 5xx, timeout, connection failures. Do NOT retry on 4xx (permanent errors per research).
    10. Save subscription state changes.

    **HMAC signing helper** (static method or inline):
    ```csharp
    private static string SignPayload(string payload, string secret)
    {
        var keyBytes = Encoding.UTF8.GetBytes(secret);
        var payloadBytes = Encoding.UTF8.GetBytes(payload);
        using var hmac = new HMACSHA256(keyBytes);
        var hash = hmac.ComputeHash(payloadBytes);
        return $"sha256={Convert.ToHexString(hash).ToLowerInvariant()}";
    }
    ```

    **Secret generation helper** (static):
    ```csharp
    public static string GenerateSecret()
    {
        var bytes = RandomNumberGenerator.GetBytes(32);
        return $"whsec_{Convert.ToBase64String(bytes)}";
    }
    ```

    **2. Add WebhookAutoDisabled to NotificationType enum** in `src/GlobCRM.Domain/Enums/NotificationType.cs`.

    **3. Create WebhookServiceExtensions** at `src/GlobCRM.Infrastructure/Webhooks/WebhookServiceExtensions.cs`:
    - `AddWebhookServices(this IServiceCollection services)`:
      - Register named HttpClient "WebhookDelivery" with 30s timeout, User-Agent "GlobCRM-Webhook/1.0", AllowAutoRedirect=false on handler
      - Register: `services.AddScoped<IDomainEventHandler, WebhookDomainEventHandler>()` — this adds to the existing IDomainEventHandler registrations
      - Register: `services.AddScoped<WebhookDeliveryService>()`
      - Register: `services.AddScoped<WebhookSsrfValidator>()`
      - Register: `services.AddScoped<WebhookPayloadBuilder>()`
      - Register: `services.AddScoped<IWebhookRepository, WebhookRepository>()`

    **4. Register in DependencyInjection.cs**: Add `services.AddWebhookServices();` after the duplicate services registration. Add `using GlobCRM.Infrastructure.Webhooks;` import.
  </action>
  <verify>
    `cd src/GlobCRM.Api && dotnet build` — 0 errors. Verify WebhookDeliveryService has `[Queue("webhooks")]` and `[AutomaticRetry(Attempts = 0)]`. Verify HMAC signing method exists. Verify WebhookServiceExtensions registers all services. Verify DependencyInjection.cs calls AddWebhookServices(). Verify NotificationType has WebhookAutoDisabled.
  </verify>
  <done>WebhookDeliveryService delivers payloads with HMAC-SHA256 signing, creates delivery logs, handles retry scheduling with exponential backoff and jitter, auto-disables subscriptions after 50 failures with email+in-app notification. All webhook services registered in DI. HttpClient configured with no auto-redirect for SSRF safety.</done>
</task>

</tasks>

<verification>
1. `cd src/GlobCRM.Api && dotnet build` — 0 errors
2. WebhookDomainEventHandler registered as IDomainEventHandler (will be invoked by DomainEventDispatcher)
3. WebhookDeliveryService signs payloads with HMAC-SHA256
4. Retry schedule: 7 attempts with exponential backoff + jitter
5. Auto-disable at 50 consecutive failures with notification dispatch
6. SSRF validator blocks private IPs and resolves DNS on every attempt
7. Payload includes envelope (id, timestamp, version, tenantId, event), data, and changes
8. HttpClient has AllowAutoRedirect=false
</verification>

<success_criteria>
- Domain event handler correctly matches entity+event to subscriptions using cached lookup
- Payload builder serializes all 5 entity types with envelope and changes
- HMAC-SHA256 signing produces lowercase hex hash with sha256= prefix
- SSRF validator blocks RFC1918, loopback, link-local IPs
- Delivery service creates log entries for every attempt
- Retry follows exponential backoff schedule with jitter, only on 5xx/timeout
- Auto-disable triggers at 50 consecutive failures with email + in-app notification
- All services registered via AddWebhookServices() in DI
- Solution builds with 0 errors
</success_criteria>

<output>
After completion, create `.planning/phases/17-webhooks/17-02-SUMMARY.md`
</output>
