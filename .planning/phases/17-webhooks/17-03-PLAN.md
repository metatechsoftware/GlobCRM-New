---
phase: 17-webhooks
plan: 03
type: execute
wave: 3
depends_on: [17-02]
files_modified:
  - src/GlobCRM.Api/Controllers/WebhooksController.cs
autonomous: true
requirements:
  - WHOOK-01
  - WHOOK-04
  - WHOOK-05

must_haves:
  truths:
    - "Admin can create a webhook subscription with entity+event type selection via POST /api/webhooks"
    - "Secret is returned only on creation and regeneration responses, masked in all GET responses"
    - "Admin can view, update, enable/disable, and delete subscriptions"
    - "Admin can view delivery logs globally and filtered per subscription"
    - "Admin can test a webhook subscription — preview payload, then optionally send to the real URL"
    - "Admin can regenerate a subscription's secret (old secret immediately invalidated)"
    - "Admin can manually retry a failed delivery from the delivery log"
    - "Admin can re-enable an auto-disabled subscription"
  artifacts:
    - path: "src/GlobCRM.Api/Controllers/WebhooksController.cs"
      provides: "Full CRUD, test, delivery logs, retry, regenerate secret endpoints"
      contains: "class WebhooksController"
  key_links:
    - from: "src/GlobCRM.Api/Controllers/WebhooksController.cs"
      to: "src/GlobCRM.Infrastructure/Webhooks/WebhookDeliveryService.cs"
      via: "Test send and manual retry both enqueue Hangfire delivery jobs"
      pattern: "Enqueue.*DeliverAsync"
    - from: "src/GlobCRM.Api/Controllers/WebhooksController.cs"
      to: "src/GlobCRM.Infrastructure/Webhooks/WebhookDomainEventHandler.cs"
      via: "Subscription CRUD invalidates cache"
      pattern: "InvalidateCache"
---

<objective>
Create the WebhooksController with all REST endpoints for subscription management, delivery log viewing, webhook testing, secret regeneration, and manual retry. DTOs and validators co-located per codebase convention.

Purpose: Expose the webhook subsystem to the admin frontend — the complete API surface for subscription CRUD, observability, and testing.
Output: WebhooksController.cs with ~12 endpoints, request/response DTOs, and FluentValidation validators.
</objective>

<execution_context>
@/Users/metatech/.claude/get-shit-done/workflows/execute-plan.md
@/Users/metatech/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/17-webhooks/17-RESEARCH.md
@.planning/phases/17-webhooks/17-01-SUMMARY.md
@.planning/phases/17-webhooks/17-02-SUMMARY.md
@src/GlobCRM.Api/Controllers/DuplicateSettingsController.cs
@src/GlobCRM.Api/Controllers/ContactsController.cs
</context>

<tasks>

<task type="auto">
  <name>Task 1: WebhooksController subscription CRUD endpoints with DTOs and validators</name>
  <files>
    src/GlobCRM.Api/Controllers/WebhooksController.cs
  </files>
  <action>
    Create `WebhooksController.cs` with admin-only endpoints (Authorize(Roles = "Admin")) at route `api/webhooks`.

    **Dependencies injected:** IWebhookRepository, WebhookDeliveryService, WebhookPayloadBuilder, WebhookSsrfValidator, WebhookDomainEventHandler (for cache invalidation), ITenantProvider, IBackgroundJobClient, ILogger.

    **DTOs (co-located in same file per codebase convention):**

    1. `WebhookSubscriptionDto` — read DTO returned by GET endpoints:
       - Id, Name, Url, SecretMask (e.g., "whsec_****...{last4}"), EventSubscriptions, IncludeCustomFields, IsActive, IsDisabled, ConsecutiveFailureCount, LastDeliveryAt, DisabledAt, DisabledReason, CreatedAt, UpdatedAt
       - Static `FromEntity(WebhookSubscription entity)` factory method
       - Secret is ALWAYS masked — never return full secret in GET (per locked decision: Stripe-style shown once only)

    2. `WebhookSubscriptionCreateDto` — returned on create (includes full secret):
       - All fields from WebhookSubscriptionDto PLUS `Secret` (the full secret, shown once only)
       - Static `FromEntity(WebhookSubscription entity)` factory

    3. `CreateWebhookRequest` record:
       - Name (required, max 200), Url (required, HTTPS, max 2048), EventSubscriptions (required, non-empty List<string>), IncludeCustomFields (optional, default false)

    4. `UpdateWebhookRequest` record:
       - Name (optional), Url (optional, HTTPS), EventSubscriptions (optional), IncludeCustomFields (optional), IsActive (optional)

    5. `WebhookDeliveryLogDto`:
       - Id, SubscriptionId, SubscriptionName, EventType, EntityId, AttemptNumber, Success, HttpStatusCode, ResponseBody, ErrorMessage, RequestPayload, DurationMs, CreatedAt
       - Static `FromEntity(WebhookDeliveryLog entity)` factory

    6. `WebhookTestPreviewResponse`:
       - SamplePayload (string — the JSON that would be sent)

    7. `PagedDeliveryLogResponse`:
       - Items (List<WebhookDeliveryLogDto>), TotalCount, Page, PageSize

    **Validators (FluentValidation, co-located):**

    1. `CreateWebhookRequestValidator`:
       - Name: NotEmpty, MaxLength(200)
       - Url: NotEmpty, MaxLength(2048), must start with "https://"
       - EventSubscriptions: NotEmpty, each item must match pattern "{Entity}.{Event}" where Entity in [Contact, Company, Deal, Lead, Activity] and Event in [Created, Updated, Deleted]

    2. `UpdateWebhookRequestValidator`: Same rules but all fields optional (only validate if provided)

    **Endpoints:**

    1. `GET /api/webhooks` — List all subscriptions for tenant (masked secrets). Return List<WebhookSubscriptionDto>.
    2. `GET /api/webhooks/{id}` — Get single subscription (masked secret). Return WebhookSubscriptionDto.
    3. `POST /api/webhooks` — Create subscription:
       - Validate request via CreateWebhookRequestValidator
       - SSRF validate the URL via WebhookSsrfValidator.ValidateUrlAsync
       - Generate secret: `WebhookDeliveryService.GenerateSecret()`
       - Create WebhookSubscription entity, set CreatedByUserId from JWT claims
       - Save via repository
       - Invalidate subscription cache via WebhookDomainEventHandler.InvalidateCache
       - Return 201 with WebhookSubscriptionCreateDto (includes full secret — SHOWN ONCE ONLY)
    4. `PUT /api/webhooks/{id}` — Update subscription:
       - Load existing, apply partial update fields
       - If URL changed, SSRF validate new URL
       - Save, invalidate cache
       - Return WebhookSubscriptionDto (masked secret)
    5. `DELETE /api/webhooks/{id}` — Delete subscription. Remove via repository, invalidate cache. Return 204.
    6. `POST /api/webhooks/{id}/regenerate-secret` — Regenerate secret:
       - Generate new secret, update subscription, save
       - Old secret immediately invalidated (per locked decision)
       - Invalidate cache
       - Return `{ secret: "whsec_..." }` (full new secret, shown once)
    7. `POST /api/webhooks/{id}/toggle` — Enable/disable subscription:
       - Toggle IsActive. If re-enabling a previously auto-disabled subscription, also set IsDisabled=false, ConsecutiveFailureCount=0, clear DisabledAt/DisabledReason (per locked decision: re-enable preserves config and history)
       - Invalidate cache
       - Return WebhookSubscriptionDto
  </action>
  <verify>
    `cd src/GlobCRM.Api && dotnet build` — 0 errors. Verify 7 endpoints exist: GET list, GET by id, POST create, PUT update, DELETE, POST regenerate-secret, POST toggle. Verify CreateWebhookRequestValidator validates EventSubscriptions format. Verify secret is masked in WebhookSubscriptionDto.FromEntity.
  </verify>
  <done>WebhooksController has full subscription CRUD (list, get, create, update, delete), secret regeneration, and enable/disable toggle. Secrets are masked in GET responses, shown in full only on create and regenerate. SSRF validation runs on create and URL update. Cache invalidated on all mutations.</done>
</task>

<task type="auto">
  <name>Task 2: Delivery log endpoints, test webhook, and manual retry</name>
  <files>
    src/GlobCRM.Api/Controllers/WebhooksController.cs
  </files>
  <action>
    Add the remaining endpoints to WebhooksController.cs:

    **Endpoints:**

    8. `GET /api/webhooks/delivery-logs` — Global delivery log (all subscriptions):
       - Query params: page (default 1), pageSize (default 25), subscriptionId (optional filter)
       - Call repository.GetDeliveryLogsAsync(subscriptionId: null or provided, page, pageSize)
       - Return PagedDeliveryLogResponse with items, totalCount, page, pageSize
       - Include subscription name in each log DTO (via Include navigation)

    9. `GET /api/webhooks/{id}/delivery-logs` — Per-subscription delivery log:
       - Verify subscription exists and belongs to tenant
       - Query params: page (default 1), pageSize (default 25)
       - Call repository.GetDeliveryLogsAsync(subscriptionId: id, page, pageSize)
       - Return PagedDeliveryLogResponse

    10. `POST /api/webhooks/{id}/test` — Test webhook (two-step per locked decision):
        - Step 1 (preview): If request body has `{ "preview": true }`:
          - Build a sample payload using WebhookPayloadBuilder with fake/sample entity data
          - Generate sample data for the first event type in the subscription's EventSubscriptions list
          - Return WebhookTestPreviewResponse with the sample JSON payload (user inspects before firing)
        - Step 2 (send): If request body has `{ "preview": false }` or omitted:
          - Build the same sample payload
          - Enqueue a real delivery via `_jobClient.Enqueue<WebhookDeliveryService>(svc => svc.DeliverAsync(id, samplePayload, tenantId, 0))`
          - Return 200 with `{ message: "Test webhook enqueued for delivery." }`

        **Sample entity data for test payloads:** Create a `BuildSamplePayload` private method that generates realistic-looking fake data based on entity type:
        - Contact: { "id": "00000000-...", "firstName": "Jane", "lastName": "Doe", "email": "jane.doe@example.com", ... }
        - Company: { "id": "...", "name": "Acme Corp", "domain": "acme.com", ... }
        - Deal: { "id": "...", "name": "Enterprise License", "value": 50000, ... }
        - Lead: { "id": "...", "firstName": "Test", "lastName": "Lead", "email": "lead@example.com", ... }
        - Activity: { "id": "...", "subject": "Follow-up Call", "type": "call", ... }

        The sample payload should use the standard webhook envelope format with event type from the subscription.

    11. `POST /api/webhooks/delivery-logs/{logId}/retry` — Manual retry a failed delivery:
        - Load the delivery log entry by ID
        - Verify it belongs to the tenant
        - Verify it was a failed delivery (Success == false)
        - Verify the subscription still exists and is active
        - Enqueue new delivery: `_jobClient.Enqueue<WebhookDeliveryService>(svc => svc.DeliverAsync(log.SubscriptionId, log.RequestPayload, tenantId, 0))`
        - Return 200 with `{ message: "Delivery retry enqueued." }`

    **Add GetDeliveryLogByIdAsync to IWebhookRepository** if not already present. Add to WebhookRepository implementation.

    **Update PagedDeliveryLogResponse**: Ensure it includes `TotalCount` for pagination. Repository methods need to return total count alongside the page data. Update repository signature if needed to: `Task<(List<WebhookDeliveryLog> Items, int TotalCount)> GetDeliveryLogsAsync(...)`.
  </action>
  <verify>
    `cd src/GlobCRM.Api && dotnet build` — 0 errors. Verify endpoints: GET /api/webhooks/delivery-logs, GET /api/webhooks/{id}/delivery-logs, POST /api/webhooks/{id}/test, POST /api/webhooks/delivery-logs/{logId}/retry. Verify test endpoint supports both preview and send modes. Verify manual retry validates log is failed before re-enqueuing.
  </verify>
  <done>WebhooksController has delivery log viewing (global and per-subscription with pagination), test webhook (preview payload then send), and manual retry from failed delivery logs. Total of ~11 endpoints covering complete webhook admin API surface.</done>
</task>

</tasks>

<verification>
1. `cd src/GlobCRM.Api && dotnet build` — 0 errors
2. All ~11 endpoints accessible with [Authorize(Roles = "Admin")]
3. Secret masked in all GET responses (only shown on POST create and POST regenerate-secret)
4. SSRF validation on create and URL update
5. Test endpoint supports preview (inspect before firing) and send modes
6. Manual retry re-enqueues stored payload for failed deliveries
7. Delivery logs paginated with total count
8. FluentValidation on create/update requests validates event subscription format
</verification>

<success_criteria>
- WebhooksController at route /api/webhooks with Admin role authorization
- Full subscription CRUD: list, get, create, update, delete
- Secret shown once on create, masked everywhere else, regeneratable
- Enable/disable toggle that can re-enable auto-disabled subscriptions
- Delivery log viewing: global (all subscriptions) and per-subscription, paginated
- Test webhook: preview payload first, then option to send
- Manual retry from failed delivery log entries
- All DTOs use static FromEntity pattern
- FluentValidation validates event subscription format
- Cache invalidated on all subscription mutations
- 0 build errors
</success_criteria>

<output>
After completion, create `.planning/phases/17-webhooks/17-03-SUMMARY.md`
</output>
