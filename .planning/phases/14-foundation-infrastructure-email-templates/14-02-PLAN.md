---
phase: 14-foundation-infrastructure-email-templates
plan: 02
type: execute
wave: 2
depends_on: ["14-01"]
files_modified:
  - src/GlobCRM.Api/Controllers/EmailTemplatesController.cs
  - src/GlobCRM.Api/Controllers/EmailTemplateCategoriesController.cs
  - src/GlobCRM.Api/Controllers/MergeFieldsController.cs
  - src/GlobCRM.Api/Program.cs
  - src/GlobCRM.Infrastructure/MultiTenancy/TenantSeeder.cs
autonomous: true
requirements:
  - ETMPL-01
  - ETMPL-04
  - ETMPL-05

must_haves:
  truths:
    - "User can create, read, update, and delete email templates via REST API"
    - "User can preview a template rendered with sample data or a real entity's data"
    - "User can send a test email of a rendered template to their own email address"
    - "User can clone an existing template into a new copy with a different name"
    - "User can manage email template categories via REST API"
    - "User can retrieve available merge fields grouped by entity for the editor"
    - "Starter templates and categories are seeded for new organizations"
  artifacts:
    - path: "src/GlobCRM.Api/Controllers/EmailTemplatesController.cs"
      provides: "Email template CRUD + preview + test-send + clone endpoints"
      contains: "EmailTemplatesController"
    - path: "src/GlobCRM.Api/Controllers/EmailTemplateCategoriesController.cs"
      provides: "Email template category CRUD endpoints"
      contains: "EmailTemplateCategoriesController"
    - path: "src/GlobCRM.Api/Controllers/MergeFieldsController.cs"
      provides: "Available merge fields endpoint"
      contains: "GetAvailableFields"
  key_links:
    - from: "src/GlobCRM.Api/Controllers/EmailTemplatesController.cs"
      to: "src/GlobCRM.Infrastructure/EmailTemplates/TemplateRenderService.cs"
      via: "Preview endpoint calls RenderAsync with resolved entity data"
      pattern: "RenderAsync"
    - from: "src/GlobCRM.Api/Controllers/EmailTemplatesController.cs"
      to: "src/GlobCRM.Infrastructure/EmailTemplates/MergeFieldService.cs"
      via: "Preview endpoint calls ResolveEntityDataAsync for real entity preview"
      pattern: "ResolveEntityDataAsync"
    - from: "src/GlobCRM.Api/Program.cs"
      to: "src/GlobCRM.Infrastructure/BackgroundJobs/HangfireServiceExtensions.cs"
      via: "AddHangfireServices and UseHangfireDashboard registration"
      pattern: "AddHangfireServices"
---

<objective>
Create REST API controllers for email template CRUD, preview, test send, and clone operations, plus category management and merge field endpoints. Wire up Hangfire and email template services in Program.cs. Seed starter categories and templates for new organizations.

Purpose: Provides the complete backend API surface for the email template feature, enabling the frontend to create/edit/preview/clone templates. Seeds useful starter content so new tenants have templates to work with immediately.

Output: Full API surface for email templates, categories, and merge fields. Hangfire dashboard accessible. Starter templates seeded.
</objective>

<execution_context>
@/Users/metatech/.claude/get-shit-done/workflows/execute-plan.md
@/Users/metatech/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/14-foundation-infrastructure-email-templates/14-RESEARCH.md
@.planning/phases/14-foundation-infrastructure-email-templates/14-CONTEXT.md
@.planning/phases/14-foundation-infrastructure-email-templates/14-01-SUMMARY.md
@src/GlobCRM.Api/Program.cs
@src/GlobCRM.Api/Controllers/ContactsController.cs
@src/GlobCRM.Infrastructure/MultiTenancy/TenantSeeder.cs
</context>

<tasks>

<task type="auto">
  <name>Task 1: Email template API controllers with preview, test send, and clone</name>
  <files>
    src/GlobCRM.Api/Controllers/EmailTemplatesController.cs
    src/GlobCRM.Api/Controllers/EmailTemplateCategoriesController.cs
    src/GlobCRM.Api/Controllers/MergeFieldsController.cs
  </files>
  <action>
    **Create `Controllers/EmailTemplatesController.cs`:**
    Follow the established controller pattern (DTOs as static inner records with `FromEntity()`, request records, co-located in same file).

    Endpoints:
    1. `GET /api/email-templates` — List templates with optional query params: `categoryId`, `isShared`, `search` (name/subject). Returns paginated list with `PaginatedResponse<EmailTemplateListDto>`. `EmailTemplateListDto` includes: Id, Name, Subject, CategoryId, CategoryName, IsShared, OwnerId, OwnerName, HtmlBody (for thumbnail preview), CreatedAt, UpdatedAt. Authorize with `[Authorize(Policy = "Permission:EmailTemplate:View")]`.
    2. `GET /api/email-templates/{id}` — Get single template by ID. Returns `EmailTemplateDto` with all fields including DesignJson. Authorize with View permission.
    3. `POST /api/email-templates` — Create template. Request: `CreateEmailTemplateRequest(string Name, string? Subject, string DesignJson, string HtmlBody, Guid? CategoryId, bool IsShared)`. Set OwnerId from current user claims. Authorize with Create permission.
    4. `PUT /api/email-templates/{id}` — Update template. Request: `UpdateEmailTemplateRequest(string Name, string? Subject, string DesignJson, string HtmlBody, Guid? CategoryId, bool IsShared)`. Authorize with Edit permission.
    5. `DELETE /api/email-templates/{id}` — Delete template. Return 204. Authorize with Delete permission.
    6. `POST /api/email-templates/{id}/clone` — Clone template. Request: `CloneEmailTemplateRequest(string Name)`. Calls repository `CloneAsync`. Returns 201 with cloned template DTO. Authorize with Create permission.
    7. `POST /api/email-templates/{id}/preview` — Preview rendered template. Request: `PreviewEmailTemplateRequest(string? EntityType, Guid? EntityId)`. If EntityType and EntityId provided, resolve real entity data via `MergeFieldService.ResolveEntityDataAsync()`. Otherwise, use sample/placeholder data (generate sensible defaults like "John", "Doe", "Acme Corp"). Render HtmlBody through `TemplateRenderService.RenderAsync()`. Return `PreviewResponse(string RenderedHtml, string RenderedSubject)`. Authorize with View permission.
    8. `POST /api/email-templates/{id}/test-send` — Send test email. Request: `TestSendRequest(string? EntityType, Guid? EntityId)`. Render template (same as preview). Send via existing `IEmailService` to the current user's email address (from claims). Return 200 with message. Authorize with View permission.

    **Create `Controllers/EmailTemplateCategoriesController.cs`:**
    Endpoints:
    1. `GET /api/email-template-categories` — List all categories for current tenant. Return `List<EmailTemplateCategoryDto>`. Authorize with `[Authorize]` (any authenticated user can view categories).
    2. `POST /api/email-template-categories` — Create category. Request: `CreateCategoryRequest(string Name, int? SortOrder)`. Authorize with `[Authorize(Roles = "Admin")]`.
    3. `PUT /api/email-template-categories/{id}` — Update category. Request: `UpdateCategoryRequest(string Name, int? SortOrder)`. Only non-system categories can be updated. Authorize with Admin role.
    4. `DELETE /api/email-template-categories/{id}` — Delete category. Only non-system categories. Templates in deleted category get `CategoryId = null`. Authorize with Admin role.

    **Create `Controllers/MergeFieldsController.cs`:**
    Single endpoint:
    1. `GET /api/merge-fields` — Returns available merge fields grouped by entity. Calls `MergeFieldService.GetAvailableFieldsAsync()`. Response format: `Dictionary<string, List<MergeFieldDto>>` where key is entity name (contact, company, deal, lead) and value is list of `MergeFieldDto(string Key, string Label, string Group, bool IsCustomField)`. Authorize with `[Authorize]`.

    **DTOs and request records** follow existing controller pattern: defined as inner records/classes within each controller file. Use static `FromEntity()` factory methods for DTOs.

    **For test send:** Use the existing `IEmailService` (SendGrid). Call `SendEmailAsync` with the current user's email, rendered subject, and rendered HTML body. If `IEmailService` doesn't have a generic send method, add a simple method or use the underlying SendGrid client directly. Wrap in try/catch — if email sending fails, return 500 with error message.
  </action>
  <verify>
    - `cd src/GlobCRM.Api && dotnet build` succeeds
    - All controller files compile with correct DTOs and request types
    - All endpoints have appropriate `[Authorize]` attributes
    - Preview endpoint handles both sample data and real entity data paths
  </verify>
  <done>
    Email template CRUD API with 8 endpoints, category management API with 4 endpoints, and merge fields API with 1 endpoint. Preview renders templates via Fluid with real or sample data. Test send delivers rendered template to user's email. Clone creates a copy with new name. All endpoints properly authorized.
  </done>
</task>

<task type="auto">
  <name>Task 2: Program.cs wiring, Hangfire dashboard, and TenantSeeder starter templates</name>
  <files>
    src/GlobCRM.Api/Program.cs
    src/GlobCRM.Infrastructure/MultiTenancy/TenantSeeder.cs
  </files>
  <action>
    **Update `Program.cs`:**
    1. Add `using GlobCRM.Infrastructure.BackgroundJobs;` and `using GlobCRM.Infrastructure.DomainEvents;` and `using GlobCRM.Infrastructure.EmailTemplates;` and `using Hangfire;`
    2. After existing `AddImportServices()`, add:
       - `builder.Services.AddHangfireServices(builder.Configuration);`
       - `builder.Services.AddDomainEventServices();`
       - `builder.Services.AddEmailTemplateServices();`
    3. After `app.UseAuthorization()` and before `app.MapControllers()`, add Hangfire dashboard:
       ```csharp
       app.UseHangfireDashboard("/hangfire", new DashboardOptions
       {
           Authorization = new[] { new HangfireDashboardAuthorizationFilter() }
       });
       ```
       Create a simple `HangfireDashboardAuthorizationFilter` class (can be inline or in BackgroundJobs folder) that implements `IDashboardAuthorizationFilter`. In development, allow all. In production, require Admin Identity role from the HttpContext user claims.

    **Update `TenantSeeder.cs`:**
    Add email template category and starter template seeding to the `SeedOrganizationAsync` method (or `ReseedOrganizationDataAsync`).

    **Seed starter categories (in order):**
    1. "Sales" (SortOrder=1, IsSystem=true)
    2. "Marketing" (SortOrder=2, IsSystem=true)
    3. "Support" (SortOrder=3, IsSystem=true)
    4. "General" (SortOrder=4, IsSystem=true)

    **Seed starter templates (IsSeedData=true, IsShared=true):**
    1. **"Welcome Email"** (Category: General) — Subject: `Welcome to {{company.name}}!`, simple HTML with greeting using `{{contact.first_name}}`, company intro, and CTA button. Design JSON can be minimal `{}` (templates will be editable only if design JSON is loaded; seeded templates serve as clone sources).
    2. **"Follow-up"** (Category: Sales) — Subject: `Following up on our conversation`, HTML with `{{contact.first_name}}` greeting, reference to recent discussion, next steps, signature block.
    3. **"Meeting Request"** (Category: Sales) — Subject: `Let's schedule a meeting`, HTML with professional meeting request using `{{contact.first_name}}`, `{{deal.title}}` context.
    4. **"Deal Won"** (Category: Sales) — Subject: `Congratulations on {{deal.title}}!`, HTML celebration email using `{{contact.first_name}}`, `{{deal.title}}`, `{{deal.value}}`, next steps.
    5. **"Support Follow-up"** (Category: Support) — Subject: `How was your experience?`, HTML with `{{contact.first_name}}`, satisfaction check, support link.

    Each starter template should have professional, table-based inline-CSS HTML (following existing email template patterns in the codebase — see `Infrastructure/Email/` for style reference). Keep templates simple but polished.

    **Add cleanup for email templates and categories in `ReseedOrganizationDataAsync`:**
    - Delete existing seed email templates: `_db.EmailTemplates.Where(t => t.TenantId == organizationId && t.IsSeedData).ExecuteDeleteAsync()`
    - Delete existing seed categories: `_db.EmailTemplateCategories.Where(c => c.TenantId == organizationId && c.IsSeedData).ExecuteDeleteAsync()`
    - Then re-seed categories and templates
  </action>
  <verify>
    - `cd src/GlobCRM.Api && dotnet build` succeeds
    - `cd src/GlobCRM.Api && dotnet run -- --reseed` succeeds and seeds email template categories and starter templates
    - Start the API server (`dotnet run`), verify `/hangfire` dashboard loads (in development mode)
    - `curl http://localhost:5233/api/email-template-categories -H "Authorization: Bearer $TOKEN" -H "X-Tenant-Id: $TENANT_ID"` returns seeded categories
    - `curl http://localhost:5233/api/email-templates -H "Authorization: Bearer $TOKEN" -H "X-Tenant-Id: $TENANT_ID"` returns seeded templates
  </verify>
  <done>
    Program.cs wires up Hangfire, domain events, and email template services. Hangfire dashboard accessible at /hangfire with authorization. TenantSeeder creates 4 starter categories and 5 starter templates for new organizations. Reseed cleans and re-creates seed data. Full API surface operational.
  </done>
</task>

</tasks>

<verification>
1. `cd src/GlobCRM.Api && dotnet build` — solution builds
2. All 13 API endpoints compile and have authorization attributes
3. Hangfire dashboard accessible at `/hangfire`
4. `dotnet run -- --reseed` seeds categories and templates
5. Preview endpoint renders merge fields with both sample and real entity data
6. Clone endpoint creates a new template copy
7. Test send endpoint calls email service with rendered content
</verification>

<success_criteria>
- All email template CRUD endpoints functional
- Preview renders templates with Fluid merge field resolution
- Test send delivers rendered email to current user
- Clone creates a duplicate with new name
- Starter templates and categories seeded on organization creation
- Hangfire dashboard secured and accessible
</success_criteria>

<output>
After completion, create `.planning/phases/14-foundation-infrastructure-email-templates/14-02-SUMMARY.md`
</output>
