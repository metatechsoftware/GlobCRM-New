---
phase: 24-my-day-personal-dashboard
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - src/GlobCRM.Domain/Entities/RecentlyViewedEntity.cs
  - src/GlobCRM.Infrastructure/Persistence/ApplicationDbContext.cs
  - src/GlobCRM.Infrastructure/Persistence/Configurations/RecentlyViewedEntityConfiguration.cs
  - src/GlobCRM.Api/Controllers/MyDayController.cs
autonomous: true
requirements:
  - MYDAY-03
  - MYDAY-04
  - MYDAY-05
  - MYDAY-06
  - MYDAY-08
  - MYDAY-10
  - MYDAY-11
  - MYDAY-12

must_haves:
  truths:
    - "GET /api/my-day returns a single JSON response with all widget data for the current user"
    - "Tasks include isOverdue flag and daysOverdue count for overdue highlighting"
    - "POST /api/my-day/track-view records a recently viewed entity for the current user"
    - "Pipeline stages are grouped with deal counts and total values per stage"
    - "Feed items, notifications, emails, and recent records are all included in the batched response"
  artifacts:
    - path: "src/GlobCRM.Domain/Entities/RecentlyViewedEntity.cs"
      provides: "Domain entity for tracking recently viewed records"
      contains: "class RecentlyViewedEntity"
    - path: "src/GlobCRM.Infrastructure/Persistence/Configurations/RecentlyViewedEntityConfiguration.cs"
      provides: "EF Core configuration with tenant scoping"
      contains: "IEntityTypeConfiguration<RecentlyViewedEntity>"
    - path: "src/GlobCRM.Api/Controllers/MyDayController.cs"
      provides: "Aggregation endpoint returning all My Day widget data"
      contains: "GetMyDay"
  key_links:
    - from: "src/GlobCRM.Api/Controllers/MyDayController.cs"
      to: "src/GlobCRM.Infrastructure/Persistence/ApplicationDbContext.cs"
      via: "EF Core queries for all widget data"
      pattern: "_db\\.Activities|_db\\.Deals|_db\\.FeedItems|_db\\.Notifications"
    - from: "src/GlobCRM.Infrastructure/Persistence/ApplicationDbContext.cs"
      to: "src/GlobCRM.Domain/Entities/RecentlyViewedEntity.cs"
      via: "DbSet registration"
      pattern: "DbSet<RecentlyViewedEntity>"
---

<objective>
Build the backend MyDay aggregation endpoint and RecentlyViewedEntity domain model. A single GET /api/my-day endpoint returns all widget data (tasks, events, pipeline, emails, feed, notifications, recent records) in one batched response, plus a POST endpoint for tracking recently viewed entities.

Purpose: Provides all data needed by the frontend My Day widgets in a single HTTP request, following the Phase 23 summary endpoint aggregation pattern.
Output: MyDayController with GET /api/my-day and POST /api/my-day/track-view, RecentlyViewedEntity domain entity, EF Core configuration, and migration.
</objective>

<execution_context>
@/Users/metatech/.claude/get-shit-done/workflows/execute-plan.md
@/Users/metatech/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/24-my-day-personal-dashboard/24-RESEARCH.md
@src/GlobCRM.Api/Controllers/CompaniesController.cs (GetSummary pattern reference)
@src/GlobCRM.Infrastructure/Persistence/ApplicationDbContext.cs
@src/GlobCRM.Domain/Entities/Notification.cs
@src/GlobCRM.Domain/Entities/FeedItem.cs
@src/GlobCRM.Domain/Entities/Activity.cs
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create RecentlyViewedEntity domain model and EF Core configuration</name>
  <files>
    src/GlobCRM.Domain/Entities/RecentlyViewedEntity.cs
    src/GlobCRM.Infrastructure/Persistence/Configurations/RecentlyViewedEntityConfiguration.cs
    src/GlobCRM.Infrastructure/Persistence/ApplicationDbContext.cs
  </files>
  <action>
    1. Create `src/GlobCRM.Domain/Entities/RecentlyViewedEntity.cs`:
       ```csharp
       public class RecentlyViewedEntity
       {
           public Guid Id { get; set; } = Guid.NewGuid();
           public Guid TenantId { get; set; }
           public Guid UserId { get; set; }
           public string EntityType { get; set; } = string.Empty; // "Contact", "Deal", etc.
           public Guid EntityId { get; set; }
           public string EntityName { get; set; } = string.Empty; // Denormalized for display
           public DateTimeOffset ViewedAt { get; set; } = DateTimeOffset.UtcNow;

           // Navigation
           public ApplicationUser? User { get; set; }
       }
       ```
       - Follow existing entity patterns (Notification, FeedItem) for structure
       - TenantId for multi-tenant scoping

    2. Create `src/GlobCRM.Infrastructure/Persistence/Configurations/RecentlyViewedEntityConfiguration.cs`:
       - Table name: `recently_viewed_entities` (snake_case per convention)
       - Configure all columns with snake_case names: `id`, `tenant_id`, `user_id`, `entity_type`, `entity_id`, `entity_name`, `viewed_at`
       - Add index on `(tenant_id, user_id, viewed_at DESC)` for fast lookups per user ordered by recency
       - Add unique index on `(tenant_id, user_id, entity_type, entity_id)` to prevent duplicate entries (upsert pattern)
       - Configure `EntityType` with max length 50, `EntityName` with max length 500
       - Global query filter: `.HasQueryFilter(e => e.TenantId == tenantId)` following existing pattern
       - Foreign key to ApplicationUser on UserId

    3. Add DbSet to `ApplicationDbContext.cs`:
       - Add `public DbSet<RecentlyViewedEntity> RecentlyViewedEntities => Set<RecentlyViewedEntity>();`
       - Place it in a new comment section: `// My Day DbSets`
       - Register the configuration in `OnModelCreating` if not auto-discovered

    4. Create EF Core migration:
       - Run: `cd src/GlobCRM.Api && dotnet ef migrations add AddRecentlyViewedEntity --context ApplicationDbContext --output-dir ../GlobCRM.Infrastructure/Persistence/Migrations/App --project ../GlobCRM.Infrastructure`
       - Apply: `cd src/GlobCRM.Api && dotnet ef database update --context ApplicationDbContext --project ../GlobCRM.Infrastructure`
  </action>
  <verify>
    - `cd src/GlobCRM.Api && dotnet build` compiles
    - Migration file exists in `src/GlobCRM.Infrastructure/Persistence/Migrations/App/`
    - Database has `recently_viewed_entities` table
  </verify>
  <done>
    - RecentlyViewedEntity domain entity exists with TenantId, UserId, EntityType, EntityId, EntityName, ViewedAt
    - EF Core configuration with snake_case table/columns, indexes, and tenant query filter
    - DbSet registered in ApplicationDbContext
    - Migration created and applied
  </done>
</task>

<task type="auto">
  <name>Task 2: Build MyDayController with aggregation GET endpoint and track-view POST endpoint</name>
  <files>
    src/GlobCRM.Api/Controllers/MyDayController.cs
  </files>
  <action>
    Create `src/GlobCRM.Api/Controllers/MyDayController.cs` following the existing controller pattern (CompaniesController, DealsController GetSummary methods):

    1. **Controller setup:**
       - `[ApiController]`, `[Route("api/my-day")]`, `[Authorize]`
       - Inject `ApplicationDbContext _db`, `IHttpContextAccessor _http`
       - Helper method `GetCurrentUserId()` returning `Guid` from claims (same pattern as other controllers)

    2. **DTO records** (co-located in same file per project convention):
       - `MyDayDto` — top-level response with all widget data:
         - `int TasksTodayCount`, `int OverdueCount`, `int UpcomingMeetingsCount` (greeting stats)
         - `List<MyDayTaskDto> Tasks` (today + overdue)
         - `List<MyDayEventDto> UpcomingEvents` (today + next 2 days)
         - `List<MyDayPipelineStageDto> PipelineStages`, `decimal PipelineTotalValue`, `int PipelineDealCount`
         - `int UnreadEmailCount`, `List<MyDayEmailDto> RecentEmails`
         - `List<MyDayFeedItemDto> RecentFeedItems`
         - `List<MyDayNotificationGroupDto> NotificationGroups`, `int TodayNotificationCount`
         - `List<MyDayRecentRecordDto> RecentRecords`
       - Sub-DTOs exactly as specified in research RESEARCH.md (MyDayTaskDto, MyDayEventDto, MyDayPipelineStageDto, MyDayEmailDto, MyDayFeedItemDto, MyDayNotificationGroupDto, MyDayNotificationDto, MyDayRecentRecordDto)
         - MyDayTaskDto: Id, Subject, Type (string), Status (string), Priority (string), DueDate, IsOverdue (bool), DaysOverdue (int), LinkedEntityType, LinkedEntityId, LinkedEntityName
         - MyDayEventDto: Id, Subject, Type (string), DueDate, AssignedToName
         - MyDayPipelineStageDto: StageName, Color, DealCount, TotalValue
         - MyDayEmailDto: Id, Subject, FromName, SentAt, IsInbound, IsRead
         - MyDayFeedItemDto: Id, Type (string), Content, EntityType, EntityId, EntityName, AuthorName, CreatedAt
         - MyDayNotificationGroupDto: Type (string), Count, Items (List<MyDayNotificationDto>)
         - MyDayNotificationDto: Id, Title, Message, EntityType, EntityId, IsRead, CreatedAt
         - MyDayRecentRecordDto: EntityType, EntityId, EntityName, ViewedAt

    3. **GET endpoint** `[HttpGet] GetMyDay()`:
       - Get userId and compute todayStart (UTC midnight), todayEnd, upcomingEnd (today + 3 days)
       - **IMPORTANT: Use sequential await (NOT Task.WhenAll) — EF Core DbContext is not thread-safe**

       - **Tasks query**: `Activities` where `(AssignedToId == userId || OwnerId == userId) && Status != ActivityStatus.Done && DueDate != null && DueDate < todayEnd`. Include overdue (DueDate < todayStart). OrderBy DueDate. Take 20. Select into MyDayTaskDto with `IsOverdue = a.DueDate < todayStart`, `DaysOverdue = (int)(todayStart - a.DueDate.Value.Date).TotalDays` (compute in memory after fetch). Also select LinkedEntityType/LinkedEntityId/LinkedEntityName from ActivityLinks navigation (first link if exists).

       - **Upcoming events query**: `Activities` where `(AssignedToId == userId || OwnerId == userId) && (Type == ActivityType.Meeting || Type == ActivityType.Call) && Status != ActivityStatus.Done && DueDate != null && DueDate >= todayStart && DueDate < upcomingEnd`. OrderBy DueDate. Take 8.

       - **Pipeline query**: `Deals` where `OwnerId == userId && Status != DealStatus.Lost && Status != DealStatus.Won`. Include PipelineStage. GroupBy PipelineStage. Select StageName, Color (from PipelineStage), DealCount, TotalValue (sum of Value). NOTE: GroupBy on navigation property may need .Select() first to materialize — fetch deals with stage info, then group in memory if EF translation fails.

       - **Emails query**: `EmailMessages` joined with `EmailAccounts` where `EmailAccounts.UserId == userId`. OrderByDescending SentAt. Take 5 for RecentEmails. Also count where IsRead == false for UnreadEmailCount.

       - **Feed query**: `FeedItems` OrderByDescending CreatedAt. Take 5. Select into MyDayFeedItemDto. Use the `EntityName` column (denormalized in Phase 22) and `AuthorName`.

       - **Notifications query**: `Notifications` where `UserId == userId && CreatedAt >= todayStart`. Group by Type in memory. For each group: count + take first 3 items. Also compute TodayNotificationCount.

       - **Recent records query**: `RecentlyViewedEntities` where `UserId == userId`. OrderByDescending ViewedAt. Take 8.

       - Compute greeting stats: TasksTodayCount = tasks where !IsOverdue, OverdueCount = tasks where IsOverdue, UpcomingMeetingsCount = upcoming events count.

       - IMPORTANT for enum handling: Fetch enum values first, then convert to strings in memory (not in LINQ projection). Use `.AsEnumerable()` or materialize before string conversion to avoid EF Core translation errors.

       - Return `Ok(new MyDayDto { ... })`.

    4. **POST endpoint** `[HttpPost("track-view")] TrackView(TrackViewRequest request)`:
       - Request record: `{ string EntityType, Guid EntityId, string EntityName }`
       - Find existing: `RecentlyViewedEntities.FirstOrDefaultAsync(r => r.UserId == userId && r.EntityType == request.EntityType && r.EntityId == request.EntityId)`
       - If exists: update `ViewedAt = DateTimeOffset.UtcNow` and `EntityName = request.EntityName`
       - If not exists: create new `RecentlyViewedEntity` with TenantId from context
       - SaveChangesAsync. Return `Ok()`.
       - This endpoint should be lightweight — no validation beyond auth.

    5. **PATCH endpoint** `[HttpPatch("tasks/{taskId}/complete")] CompleteTask(Guid taskId)`:
       - Find activity by id where (AssignedToId == userId || OwnerId == userId)
       - Set Status = ActivityStatus.Done, CompletedAt = DateTimeOffset.UtcNow
       - SaveChangesAsync. Return `Ok()`.
       - This provides the inline task completion from My Day without going through the full activity status endpoint.
  </action>
  <verify>
    - `cd src/GlobCRM.Api && dotnet build` compiles
    - Controller file contains GetMyDay, TrackView, and CompleteTask endpoints
    - All DTOs are defined as records in the controller file
    - No Task.WhenAll usage (sequential awaits only)
  </verify>
  <done>
    - GET /api/my-day returns batched MyDayDto with all 8 widget data sections
    - POST /api/my-day/track-view upserts a recently viewed entity
    - PATCH /api/my-day/tasks/{taskId}/complete marks a task as done
    - Tasks include IsOverdue and DaysOverdue for urgency indicators
    - Pipeline stages grouped with counts and values
    - Notifications grouped by type
    - All queries use sequential await (EF Core safe)
    - Enum values converted to strings in memory (not in LINQ)
  </done>
</task>

</tasks>

<verification>
1. `cd src/GlobCRM.Api && dotnet build` passes
2. Migration exists and applies cleanly
3. MyDayController has 3 endpoints: GET, POST track-view, PATCH complete
4. No concurrent EF Core operations (no Task.WhenAll)
5. All enum-to-string conversions happen in memory, not in LINQ projections
</verification>

<success_criteria>
- Backend builds and starts without errors
- GET /api/my-day returns comprehensive MyDayDto with data for all 8 widgets
- POST /api/my-day/track-view records entity views
- PATCH /api/my-day/tasks/{taskId}/complete transitions task to Done
- recently_viewed_entities table exists with proper indexes
</success_criteria>

<output>
After completion, create `.planning/phases/24-my-day-personal-dashboard/24-02-SUMMARY.md`
</output>
