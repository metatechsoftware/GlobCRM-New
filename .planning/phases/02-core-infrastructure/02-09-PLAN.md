---
phase: 02-core-infrastructure
plan: 09
type: execute
wave: 3
depends_on: [02-07]
files_modified:
  - globcrm-web/src/app/core/permissions/permission.models.ts
  - globcrm-web/src/app/core/permissions/permission.service.ts
  - globcrm-web/src/app/core/permissions/permission.store.ts
  - globcrm-web/src/app/core/permissions/has-permission.directive.ts
  - globcrm-web/src/app/core/permissions/permission.guard.ts
  - globcrm-web/src/app/shared/directives/field-access.directive.ts
autonomous: true

must_haves:
  truths:
    - "PermissionStore loads all effective permissions for the current user on login/refresh"
    - "HasPermission structural directive shows/hides UI elements based on entity+operation permissions"
    - "FieldAccess directive applies hidden/readonly states based on field-level permissions"
    - "PermissionGuard protects routes based on required entity permissions"
    - "Permission checks use signals (reactive, no polling) for Angular template performance"
  artifacts:
    - path: "globcrm-web/src/app/core/permissions/permission.store.ts"
      provides: "Signal store for user permissions"
      contains: "PermissionStore"
    - path: "globcrm-web/src/app/core/permissions/has-permission.directive.ts"
      provides: "Structural directive for permission-based rendering"
      contains: "HasPermissionDirective"
    - path: "globcrm-web/src/app/core/permissions/permission.guard.ts"
      provides: "Route guard for permission checks"
      contains: "permissionGuard"
    - path: "globcrm-web/src/app/shared/directives/field-access.directive.ts"
      provides: "Field-level access directive"
      contains: "FieldAccessDirective"
  key_links:
    - from: "globcrm-web/src/app/core/permissions/permission.store.ts"
      to: "globcrm-web/src/app/core/permissions/permission.service.ts"
      via: "Service injection for API calls"
      pattern: "PermissionService"
    - from: "globcrm-web/src/app/core/permissions/has-permission.directive.ts"
      to: "globcrm-web/src/app/core/permissions/permission.store.ts"
      via: "Store injection for reactive permission checks"
      pattern: "PermissionStore"
---

<objective>
Create the Angular permission infrastructure: signal store, service, structural directives, and route guard.

Purpose: Enables reactive permission checks throughout the Angular UI. The PermissionStore loads all effective permissions once (on login/refresh) and exposes them as signals. The HasPermission directive conditionally renders UI elements. The FieldAccess directive controls field visibility/editability. The PermissionGuard protects routes. This is the frontend counterpart to the backend authorization engine (Plan 04/07).

Output: PermissionStore, PermissionService, HasPermissionDirective, FieldAccessDirective, PermissionGuard.
</objective>

<execution_context>
@/Users/metatech/.claude/get-shit-done/workflows/execute-plan.md
@/Users/metatech/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/02-core-infrastructure/02-RESEARCH.md
@.planning/phases/02-core-infrastructure/02-07-SUMMARY.md

@globcrm-web/src/app/core/auth/auth.store.ts
@globcrm-web/src/app/core/auth/auth.service.ts
@globcrm-web/src/app/core/auth/auth.guard.ts
@globcrm-web/src/app/core/api/api.service.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create PermissionService, PermissionStore, and permission models</name>
  <files>
    globcrm-web/src/app/core/permissions/permission.models.ts
    globcrm-web/src/app/core/permissions/permission.service.ts
    globcrm-web/src/app/core/permissions/permission.store.ts
  </files>
  <action>
    **permission.models.ts:**
    ```typescript
    export interface EffectivePermission {
      entityType: string;
      operation: string;
      scope: 'none' | 'own' | 'team' | 'all';
    }

    export interface FieldPermission {
      entityType: string;
      fieldName: string;
      accessLevel: 'hidden' | 'readonly' | 'editable';
    }

    // For the roles management UI (Plan 10)
    export interface RoleDto {
      id: string;
      name: string;
      description: string | null;
      isSystem: boolean;
      isTemplate: boolean;
      permissionCount: number;
      assignedUserCount: number;
    }

    export interface RoleDetailDto extends RoleDto {
      permissions: RolePermissionDto[];
      fieldPermissions: RoleFieldPermissionDto[];
    }

    export interface RolePermissionDto {
      entityType: string;
      operation: string;
      scope: 'none' | 'own' | 'team' | 'all';
    }

    export interface RoleFieldPermissionDto {
      entityType: string;
      fieldName: string;
      accessLevel: 'hidden' | 'readonly' | 'editable';
    }

    export interface TeamDto {
      id: string;
      name: string;
      description: string | null;
      defaultRoleName: string | null;
      memberCount: number;
    }
    ```

    **permission.service.ts:**
    - Injectable service using ApiService
    - Methods:
      - `getMyPermissions(): Observable<EffectivePermission[]>` — GET /api/roles/my-permissions
      - `getRoles(): Observable<RoleDto[]>` — GET /api/roles
      - `getRole(id: string): Observable<RoleDetailDto>` — GET /api/roles/{id}
      - `createRole(role: CreateRoleRequest): Observable<RoleDetailDto>` — POST /api/roles
      - `updateRole(id: string, role: UpdateRoleRequest): Observable<RoleDetailDto>` — PUT /api/roles/{id}
      - `deleteRole(id: string): Observable<void>` — DELETE /api/roles/{id}
      - `cloneRole(id: string, name: string): Observable<RoleDetailDto>` — POST /api/roles/{id}/clone
      - `assignRole(roleId: string, userId: string): Observable<void>` — POST /api/roles/{roleId}/assign
      - `unassignRole(roleId: string, userId: string): Observable<void>` — DELETE /api/roles/{roleId}/assign/{userId}
      - `getTeams(): Observable<TeamDto[]>` — GET /api/teams
      - `getTeam(id: string): Observable<TeamDetailDto>` — GET /api/teams/{id}
      - `createTeam(team: CreateTeamRequest): Observable<TeamDetailDto>` — POST /api/teams
      - `updateTeam(id: string, team: UpdateTeamRequest): Observable<TeamDetailDto>` — PUT /api/teams/{id}
      - `deleteTeam(id: string): Observable<void>` — DELETE /api/teams/{id}
      - `addTeamMember(teamId: string, userId: string): Observable<void>` — POST /api/teams/{teamId}/members
      - `removeTeamMember(teamId: string, userId: string): Observable<void>` — DELETE /api/teams/{teamId}/members/{userId}

    **PermissionStore** (@ngrx/signals):
    - State: `{ permissions: EffectivePermission[], isLoaded: boolean, isLoading: boolean }`
    - Computed:
      - `permissionMap: Map<string, string>` — maps "EntityType:Operation" -> scope string for O(1) lookups
    - Methods:
      - `loadPermissions()`: call permissionService.getMyPermissions(), set permissions + isLoaded
      - `hasPermission(entityType: string, operation: string): Signal<boolean>` — returns computed signal checking permissionMap for scope != 'none'
      - `getScope(entityType: string, operation: string): Signal<string>` — returns scope string
      - `clear()`: reset state (on logout)

    - Follow existing @ngrx/signals pattern from AuthStore (withState + withComputed + withMethods)
    - Use `{ providedIn: 'root' }` for singleton
    - Per research pitfall #7: use signals/computed for reactive permission checks, NOT method calls in templates

    **Integration point:** The PermissionStore should be loaded after successful login. Update the auth flow to call permissionStore.loadPermissions() after login/token refresh. This can be done in the AuthStore's login method or in an APP_INITIALIZER. For now, add the loadPermissions call in the PermissionStore as a method — the integration with AuthStore will be wired by the executor.
  </action>
  <verify>
    `cd globcrm-web && ng build` succeeds with 0 errors (or only expected warnings).
    PermissionStore has loadPermissions, hasPermission, getScope methods.
    PermissionService has getMyPermissions and all role/team management methods.
  </verify>
  <done>PermissionStore, PermissionService, and permission models created with reactive signal-based permission checks.</done>
</task>

<task type="auto">
  <name>Task 2: Create HasPermission directive, FieldAccess directive, and PermissionGuard</name>
  <files>
    globcrm-web/src/app/core/permissions/has-permission.directive.ts
    globcrm-web/src/app/core/permissions/permission.guard.ts
    globcrm-web/src/app/shared/directives/field-access.directive.ts
  </files>
  <action>
    **HasPermissionDirective** (standalone structural directive):
    - Selector: `[appHasPermission]`
    - Input: `appHasPermission: string` — format "EntityType:Operation" (e.g., "Contact:Edit")
    - Logic:
      1. Inject PermissionStore
      2. Parse input into entityType and operation
      3. Use effect() to reactively watch permissionStore.hasPermission(entityType, operation)
      4. If allowed: create embedded view (show element)
      5. If not allowed: clear view container (hide element)
      6. Track hasView flag to avoid duplicate creation
    - Usage: `<button *appHasPermission="'Contact:Edit'" (click)="edit()">Edit</button>`
    - Per research pattern 7: use signals for reactive checks, NOT method calls per change detection cycle

    **FieldAccessDirective** (standalone attribute directive):
    - Selector: `[appFieldAccess]`
    - Inputs:
      - `appFieldAccess: string` — format "EntityType:FieldName" (e.g., "Contact:phone")
      - `appFieldAccessFallback: 'hidden' | 'readonly' | 'editable'` — default behavior if no permission defined (default: 'editable')
    - Logic:
      1. Inject PermissionStore
      2. Get field access level from store (need to add field permission support to PermissionStore, or make a separate API call)
      3. Based on access level:
         - 'hidden': set host element display:none
         - 'readonly': set host element to readonly/disabled state (add 'readonly' attribute for inputs, add 'disabled' for buttons)
         - 'editable': no modification (default)
    - NOTE: Field-level permissions require an additional API endpoint or can be included in the my-permissions response. For Phase 2, implement the directive structure and add a placeholder `getFieldAccess` method on PermissionStore. Full field permission loading can be wired when entity pages are built in Phase 3.
    - Usage: `<input [appFieldAccess]="'Contact:phone'" matInput>`

    **PermissionGuard** (functional guard — CanActivateFn):
    - Factory function: `permissionGuard(entityType: string, operation: string): CanActivateFn`
    - Logic:
      1. Inject PermissionStore and Router
      2. If permissionStore.isLoaded() is false, wait for it (could use a small polling loop or resolve via the auth flow)
      3. Check permissionStore.hasPermission(entityType, operation)
      4. If allowed: return true
      5. If not allowed: redirect to /dashboard with a snackbar message "Access denied"
    - Usage in routes: `{ path: 'contacts', canActivate: [permissionGuard('Contact', 'View')], ... }`
    - Follow existing functional guard pattern from auth.guard.ts

    **Wire permissions loading into auth flow:**
    - In the AuthStore or AuthService, after successful login and token storage, call `permissionStore.loadPermissions()`
    - This ensures permissions are available before any guard or directive checks
    - If the auth interceptor handles 401 → refresh → retry, permissions should also be reloaded after token refresh
    - Add this integration: inject PermissionStore in AuthStore/AuthService and call loadPermissions() in the login success handler
  </action>
  <verify>
    `cd globcrm-web && ng build` succeeds with 0 errors (or only expected warnings).
    HasPermissionDirective uses *appHasPermission="'Entity:Op'" syntax.
    FieldAccessDirective applies hidden/readonly/editable states.
    PermissionGuard returns CanActivateFn.
    Auth flow calls permissionStore.loadPermissions() after login.
  </verify>
  <done>HasPermission directive, FieldAccess directive, and PermissionGuard created. Permissions loaded after login for reactive UI enforcement.</done>
</task>

</tasks>

<verification>
1. `ng build` succeeds from globcrm-web/
2. PermissionStore loads on login and exposes reactive signals
3. HasPermission directive conditionally renders elements based on "Entity:Operation"
4. FieldAccess directive sets hidden/readonly/editable on host element
5. PermissionGuard protects routes and redirects unauthorized users
6. All directives use signals (not method calls) for template performance
</verification>

<success_criteria>
- *appHasPermission directive works for conditional rendering
- [appFieldAccess] directive works for field-level access control
- PermissionGuard factory creates route guards
- PermissionStore is loaded after login and reactive
- Build passes with 0 errors
</success_criteria>

<output>
After completion, create `.planning/phases/02-core-infrastructure/02-09-SUMMARY.md`
</output>
