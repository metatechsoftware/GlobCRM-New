---
phase: 02-core-infrastructure
plan: 04
type: execute
wave: 2
depends_on: [02-01]
files_modified:
  - src/GlobCRM.Domain/Interfaces/IPermissionService.cs
  - src/GlobCRM.Infrastructure/Authorization/PermissionRequirement.cs
  - src/GlobCRM.Infrastructure/Authorization/PermissionAuthorizationHandler.cs
  - src/GlobCRM.Infrastructure/Authorization/PermissionPolicyProvider.cs
  - src/GlobCRM.Infrastructure/Authorization/PermissionService.cs
  - src/GlobCRM.Infrastructure/Authorization/AuthorizationServiceExtensions.cs
  - src/GlobCRM.Infrastructure/Authorization/RoleTemplateSeeder.cs
  - src/GlobCRM.Infrastructure/DependencyInjection.cs
  - src/GlobCRM.Api/Program.cs
autonomous: true

must_haves:
  truths:
    - "PermissionService resolves effective permissions from direct roles + team-inherited roles using most-permissive-wins"
    - "PermissionAuthorizationHandler integrates with ASP.NET Core [Authorize] attribute for dynamic policy checks"
    - "PermissionPolicyProvider parses 'Permission:Entity:Operation' policy names into PermissionRequirements"
    - "Role template seeder creates Admin, Manager, Sales Rep, Viewer templates on org creation"
    - "Permission results are cached with IMemoryCache (5-min TTL) and invalidatable"
  artifacts:
    - path: "src/GlobCRM.Infrastructure/Authorization/PermissionService.cs"
      provides: "Effective permission resolution with caching"
      contains: "GetEffectivePermissionAsync"
    - path: "src/GlobCRM.Infrastructure/Authorization/PermissionAuthorizationHandler.cs"
      provides: "ASP.NET Core authorization handler"
      contains: "AuthorizationHandler<PermissionRequirement>"
    - path: "src/GlobCRM.Infrastructure/Authorization/PermissionPolicyProvider.cs"
      provides: "Dynamic policy provider"
      contains: "IAuthorizationPolicyProvider"
    - path: "src/GlobCRM.Infrastructure/Authorization/RoleTemplateSeeder.cs"
      provides: "Default role templates"
      contains: "Admin.*Manager.*Sales Rep.*Viewer"
  key_links:
    - from: "src/GlobCRM.Infrastructure/Authorization/PermissionAuthorizationHandler.cs"
      to: "src/GlobCRM.Infrastructure/Authorization/PermissionService.cs"
      via: "IPermissionService injection"
      pattern: "IPermissionService"
    - from: "src/GlobCRM.Infrastructure/Authorization/PermissionPolicyProvider.cs"
      to: "src/GlobCRM.Infrastructure/Authorization/PermissionRequirement.cs"
      via: "Creates PermissionRequirement from policy name"
      pattern: "PermissionRequirement"
    - from: "src/GlobCRM.Api/Program.cs"
      to: "src/GlobCRM.Infrastructure/Authorization/RoleTemplateSeeder.cs"
      via: "Startup seeding call"
      pattern: "SeedTemplateRoles"
---

<objective>
Build the RBAC authorization engine with dynamic permission resolution, ASP.NET Core integration, and role template seeding.

Purpose: Creates the runtime permission enforcement layer. Every API endpoint can use `[Authorize(Policy = "Permission:Contact:View")]` to check permissions. The PermissionService computes effective permissions by unioning all roles (direct + team-inherited) and picking the most permissive scope. Role templates (Admin, Manager, Sales Rep, Viewer) are auto-seeded for each new organization.

Output: PermissionService, PermissionAuthorizationHandler, PermissionPolicyProvider, RoleTemplateSeeder, DI registration, and startup wiring.
</objective>

<execution_context>
@/Users/metatech/.claude/get-shit-done/workflows/execute-plan.md
@/Users/metatech/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/02-core-infrastructure/02-RESEARCH.md
@.planning/phases/02-core-infrastructure/02-01-SUMMARY.md

@src/GlobCRM.Infrastructure/DependencyInjection.cs
@src/GlobCRM.Infrastructure/Persistence/ApplicationDbContext.cs
@src/GlobCRM.Api/Program.cs
@src/GlobCRM.Domain/Entities/Role.cs
@src/GlobCRM.Domain/Entities/RolePermission.cs
@src/GlobCRM.Domain/Entities/Team.cs
@src/GlobCRM.Domain/Entities/TeamMember.cs
@src/GlobCRM.Domain/Entities/UserRoleAssignment.cs
@src/GlobCRM.Domain/Enums/PermissionScope.cs
@src/GlobCRM.Domain/Enums/EntityType.cs
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create PermissionService with effective permission resolution and caching</name>
  <files>
    src/GlobCRM.Domain/Interfaces/IPermissionService.cs
    src/GlobCRM.Infrastructure/Authorization/PermissionService.cs
    src/GlobCRM.Infrastructure/Authorization/PermissionRequirement.cs
  </files>
  <action>
    **IPermissionService** (src/GlobCRM.Domain/Interfaces/IPermissionService.cs):
    - Methods:
      - `Task<EffectivePermission> GetEffectivePermissionAsync(Guid userId, string entityType, string operation)`
      - `Task<IReadOnlyList<EffectivePermission>> GetAllPermissionsAsync(Guid userId)` — returns all permissions for a user (used by frontend to load permission map)
      - `Task<FieldAccessLevel> GetFieldAccessLevelAsync(Guid userId, string entityType, string fieldName)` — field-level access check
      - `void InvalidateUserPermissions(Guid userId)` — cache invalidation
    - Include EffectivePermission record: `record EffectivePermission(string EntityType, string Operation, PermissionScope Scope)`

    **PermissionRequirement** (src/GlobCRM.Infrastructure/Authorization/PermissionRequirement.cs):
    - Implements IAuthorizationRequirement
    - Properties: EntityType (string), Operation (string)
    - Constructor takes both parameters

    **PermissionService** (src/GlobCRM.Infrastructure/Authorization/PermissionService.cs):
    - Dependencies: ApplicationDbContext, IMemoryCache
    - GetEffectivePermissionAsync implementation:
      1. Check cache first: key = `perm:{userId}:{entityType}:{operation}`, TTL = 5 minutes
      2. If not cached, load ALL permissions for this user in a SINGLE query to avoid N+1:
         - Get direct role IDs from UserRoleAssignments WHERE UserId = userId
         - Get team default role IDs from TeamMembers JOIN Teams WHERE TeamMember.UserId = userId AND Team.DefaultRoleId IS NOT NULL
         - Union both role ID sets
         - Query RolePermissions WHERE RoleId IN (allRoleIds) AND EntityType = entityType AND Operation = operation
      3. Apply "most permissive wins": take Max(Scope) across all matching permissions
      4. If no permissions found, return PermissionScope.None
      5. Cache result

    - GetAllPermissionsAsync: Similar but loads ALL entity+operation combinations for all user roles. Cache entire set with key `perm-all:{userId}`. Used for frontend permission loading.

    - GetFieldAccessLevelAsync:
      1. Get all role IDs (same as above)
      2. Query RoleFieldPermissions for this entityType+fieldName
      3. Most permissive wins: Max(AccessLevel) — Editable > ReadOnly > Hidden
      4. If no field permissions found, default to Editable (fields are editable unless restricted)

    - InvalidateUserPermissions: Remove all cache entries for this user. Use a cache entry key pattern or maintain a list of keys per user.

    Per locked decision: conflict resolution is most permissive wins (union of all permissions from direct + team-inherited roles). Per research pitfall #1: 5-minute cache TTL. Per research pitfall #2: single query to avoid N+1.
  </action>
  <verify>
    `dotnet build` succeeds with 0 errors.
    PermissionService.cs contains GetEffectivePermissionAsync with cache and single-query pattern.
    IPermissionService.cs defines all 4 methods.
  </verify>
  <done>PermissionService resolves effective permissions from direct + team roles using most-permissive-wins, with IMemoryCache caching and invalidation.</done>
</task>

<task type="auto">
  <name>Task 2: Create authorization handler, policy provider, role seeder, and wire DI</name>
  <files>
    src/GlobCRM.Infrastructure/Authorization/PermissionAuthorizationHandler.cs
    src/GlobCRM.Infrastructure/Authorization/PermissionPolicyProvider.cs
    src/GlobCRM.Infrastructure/Authorization/AuthorizationServiceExtensions.cs
    src/GlobCRM.Infrastructure/Authorization/RoleTemplateSeeder.cs
    src/GlobCRM.Infrastructure/DependencyInjection.cs
    src/GlobCRM.Api/Program.cs
  </files>
  <action>
    **PermissionAuthorizationHandler** (src/GlobCRM.Infrastructure/Authorization/PermissionAuthorizationHandler.cs):
    - Extends `AuthorizationHandler<PermissionRequirement>`
    - Dependencies: IPermissionService
    - HandleRequirementAsync:
      1. Get userId from context.User claims (ClaimTypes.NameIdentifier)
      2. If no userId, return (unauthorized)
      3. Call _permissionService.GetEffectivePermissionAsync(userId, requirement.EntityType, requirement.Operation)
      4. If scope != None, call context.Succeed(requirement)
    - Per research pattern 1: use ASP.NET Core's built-in IAuthorizationHandler

    **PermissionPolicyProvider** (src/GlobCRM.Infrastructure/Authorization/PermissionPolicyProvider.cs):
    - Implements IAuthorizationPolicyProvider
    - Constructor: takes IOptions<AuthorizationOptions>, creates DefaultAuthorizationPolicyProvider as fallback
    - GetPolicyAsync: If policyName starts with "Permission:", parse "Permission:{Entity}:{Operation}", create AuthorizationPolicyBuilder with PermissionRequirement, build and return. Otherwise, delegate to fallback.
    - GetDefaultPolicyAsync: Delegate to fallback
    - GetFallbackPolicyAsync: Delegate to fallback
    - Per research pattern 1: dynamic policy names like "Permission:Contact:View"

    **AuthorizationServiceExtensions** (src/GlobCRM.Infrastructure/Authorization/AuthorizationServiceExtensions.cs):
    - Extension method: `AddPermissionAuthorization(this IServiceCollection services)`
    - Register:
      - IAuthorizationPolicyProvider -> PermissionPolicyProvider (Singleton — policy providers must be singleton)
      - IAuthorizationHandler -> PermissionAuthorizationHandler (Scoped — needs scoped DbContext)
      - IPermissionService -> PermissionService (Scoped)
      - IMemoryCache via AddMemoryCache() if not already registered

    **RoleTemplateSeeder** (src/GlobCRM.Infrastructure/Authorization/RoleTemplateSeeder.cs):
    - Static class with: `static async Task SeedTemplateRolesAsync(ApplicationDbContext db, Guid tenantId)`
    - Entity types to seed: all values from EntityType enum (Contact, Company, Deal, Activity, Quote, Request, Product)
    - Operations: "View", "Create", "Edit", "Delete"
    - Template roles per locked decision:
      - **Admin**: All CRUD = All scope on every entity. Description: "Full access to all records and settings". IsSystem=true, IsTemplate=true.
      - **Manager**: All CRUD = Team scope on every entity. Description: "Full access to team records". IsSystem=true, IsTemplate=true.
      - **Sales Rep**: View = Team scope, Create/Edit/Delete = Own scope on every entity. Description: "Access to own records, view team records". IsSystem=true, IsTemplate=true.
      - **Viewer**: View = All scope, Create/Edit/Delete = None scope on every entity. Description: "Read-only access to all records". IsSystem=true, IsTemplate=true.
    - Check if templates already exist (idempotent): `if (await db.Roles.AnyAsync(r => r.TenantId == tenantId && r.IsTemplate)) return;`
    - Also seed field permissions: Admin gets Editable for all, Viewer gets ReadOnly for all (optional, can defer to runtime defaults)

    **DependencyInjection.cs update:**
    - Add call to `services.AddPermissionAuthorization()` in the AddInfrastructure method

    **Program.cs update:**
    - In the organization creation flow (or where roles are seeded on startup), call RoleTemplateSeeder.SeedTemplateRolesAsync
    - Specifically: after the existing SeedRolesAsync (Identity roles), also call the template seeder for each existing tenant
    - Add a startup migration step: iterate existing tenants and ensure templates exist
    - Pattern: `using var scope = app.Services.CreateScope(); var db = scope.ServiceProvider.GetRequiredService<ApplicationDbContext>();` then iterate tenants
    - ALSO: Hook into CreateOrganizationCommand handler (in Application layer) — when a new org is created, seed templates. Since this plan can't modify Application directly, add a note in summary that Plan 05 or Plan 07 should add the seeding call to org creation.
    - For now, add startup seeding that ensures all existing tenants have templates.
  </action>
  <verify>
    `dotnet build` succeeds with 0 errors.
    PermissionAuthorizationHandler extends AuthorizationHandler<PermissionRequirement>.
    PermissionPolicyProvider parses "Permission:Entity:Operation" policy names.
    RoleTemplateSeeder creates Admin, Manager, Sales Rep, Viewer templates.
    DependencyInjection.cs calls AddPermissionAuthorization().
  </verify>
  <done>Authorization handler, policy provider, role template seeder created and wired into DI. [Authorize(Policy = "Permission:Entity:Operation")] works on any controller.</done>
</task>

</tasks>

<verification>
1. `dotnet build` succeeds with 0 errors
2. [Authorize(Policy = "Permission:Contact:View")] can be applied to a controller action without runtime errors
3. PermissionService caches effective permissions with 5-min TTL
4. Most-permissive-wins algorithm: All > Team > Own > None
5. RoleTemplateSeeder creates 4 template roles with correct permissions for all entity types
6. DependencyInjection.cs registers all authorization services
</verification>

<success_criteria>
- Permission engine fully wired: IAuthorizationPolicyProvider + IAuthorizationHandler + IPermissionService
- Four template roles seeded with correct CRUD scopes per entity type
- Cache with 5-min TTL and invalidation method
- Build passes with 0 errors
</success_criteria>

<output>
After completion, create `.planning/phases/02-core-infrastructure/02-04-SUMMARY.md`
</output>
