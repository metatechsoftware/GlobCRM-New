---
phase: 10-data-operations
plan: 03
type: execute
wave: 2
depends_on: ["10-01"]
files_modified:
  - src/GlobCRM.Infrastructure/Search/GlobalSearchService.cs
  - src/GlobCRM.Infrastructure/Search/SearchServiceExtensions.cs
  - src/GlobCRM.Api/Controllers/SearchController.cs
  - src/GlobCRM.Api/Program.cs
autonomous: true

must_haves:
  truths:
    - "User can search across Company, Contact, and Deal entities from a single endpoint"
    - "Search results are grouped by entity type with title, subtitle, and URL"
    - "Search respects RBAC permissions (user only sees entities they have View permission for)"
    - "Search uses PostgreSQL tsvector with prefix matching for partial word support"
    - "Search returns ranked results within each entity type"
  artifacts:
    - path: "src/GlobCRM.Infrastructure/Search/GlobalSearchService.cs"
      provides: "Cross-entity search using tsvector with permission-scoped queries"
      contains: "GlobalSearchService"
    - path: "src/GlobCRM.Api/Controllers/SearchController.cs"
      provides: "GET /api/search?q={term} endpoint returning grouped results"
      contains: "SearchController"
  key_links:
    - from: "src/GlobCRM.Infrastructure/Search/GlobalSearchService.cs"
      to: "ApplicationDbContext"
      via: "tsvector Matches + Rank queries on Company, Contact, Deal"
      pattern: "SearchVector\\.Matches"
    - from: "src/GlobCRM.Infrastructure/Search/GlobalSearchService.cs"
      to: "IPermissionService"
      via: "Permission scope check per entity type before querying"
      pattern: "GetEffectivePermissionAsync"
    - from: "src/GlobCRM.Api/Controllers/SearchController.cs"
      to: "src/GlobCRM.Infrastructure/Search/GlobalSearchService.cs"
      via: "DI injection of ISearchService"
      pattern: "ISearchService"
---

<objective>
Build the global search backend: GlobalSearchService using PostgreSQL tsvector queries with permission-scoped results, and SearchController API endpoint returning grouped results.

Purpose: Delivers cross-entity search capability (SRCH-01, SRCH-02, SRCH-03) so users can find companies, contacts, and deals from a single search interface.
Output: Search service implementation and REST API endpoint.
</objective>

<execution_context>
@/Users/metatech/.claude/get-shit-done/workflows/execute-plan.md
@/Users/metatech/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/10-data-operations/10-RESEARCH.md
@.planning/phases/10-data-operations/10-01-SUMMARY.md
@src/GlobCRM.Domain/Interfaces/ISearchService.cs
@src/GlobCRM.Infrastructure/Authorization/AuthorizationServiceExtensions.cs
@src/GlobCRM.Api/Controllers/DashboardsController.cs
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create GlobalSearchService with tsvector queries and permission scoping</name>
  <files>
    src/GlobCRM.Infrastructure/Search/GlobalSearchService.cs
    src/GlobCRM.Infrastructure/Search/SearchServiceExtensions.cs
    src/GlobCRM.Api/Program.cs
  </files>
  <action>
    **Create GlobalSearchService** (Infrastructure/Search/GlobalSearchService.cs):
    Implements ISearchService. Constructor injects: ApplicationDbContext, IPermissionService.

    `SearchAsync(string term, Guid userId, int maxPerType = 5)`:

    1. **Build tsquery with prefix matching:**
       For partial word support (e.g., "acm" matches "Acme"), construct a prefix query.
       Use `EF.Functions.ToTsQuery("english", prefixTerm)` where prefixTerm appends `:*` to each word.
       Helper method: `BuildPrefixQuery(string term)` â€” splits on whitespace, appends `:*` to each token, joins with `&`. Example: "john smi" becomes "john:* & smi:*".
       Fallback: if term has no alphanumeric chars after cleaning, return empty result.

    2. **For each searchable entity type (Company, Contact, Deal):**
       a. Check permission: `await _permissionService.GetEffectivePermissionAsync(userId, entityTypeName, "View")`
       b. If scope is None, skip this entity type
       c. Query using tsvector:
          ```csharp
          var tsQuery = EF.Functions.ToTsQuery("english", prefixTerm);
          var query = _db.Companies
              .Where(c => c.SearchVector.Matches(tsQuery))
              .OrderByDescending(c => c.SearchVector.Rank(tsQuery))
              .Take(maxPerType);
          ```
       d. Apply ownership scope if not PermissionScope.All:
          - Own: filter by OwnerId == userId
          - Team: get team member IDs, filter by OwnerId in team members
          - All: no filter
       e. Project to SearchHit: Id, Title (Name/FullName/Title), Subtitle (Industry/JobTitle/Pipeline.Name), EntityType string, Url (/companies/{id}, /contacts/{id}, /deals/{id})

    3. **Assemble results:** Group non-empty result sets into SearchGroup objects. Return GlobalSearchResult.

    Also search Activity, Quote, Request, and Product if those entities have SearchVector columns in the future. For now, only Company, Contact, Deal have tsvector (per research recommendation).

    **Create SearchServiceExtensions** (Search/SearchServiceExtensions.cs):
    ```csharp
    public static IServiceCollection AddSearchServices(this IServiceCollection services)
    {
        services.AddScoped<ISearchService, GlobalSearchService>();
        return services;
    }
    ```

    **Update Program.cs:** Add `builder.Services.AddSearchServices();` after existing service registrations.
  </action>
  <verify>
    `dotnet build` succeeds. GlobalSearchService implements ISearchService. SearchServiceExtensions registered in Program.cs.
  </verify>
  <done>
    GlobalSearchService queries Company, Contact, Deal tsvector columns with prefix matching, ranks results, respects RBAC permissions, and returns grouped SearchHit results.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create SearchController with search endpoint</name>
  <files>
    src/GlobCRM.Api/Controllers/SearchController.cs
  </files>
  <action>
    **Create SearchController** (Api/Controllers/SearchController.cs):
    Follow existing controller patterns. [Authorize] at controller level (any authenticated user can search).

    Endpoint:
    `GET /api/search?q={term}&maxPerType={5}`

    Implementation:
    1. Validate: term must be at least 2 characters, return 400 if too short
    2. Get userId from User claims (matching existing controller pattern)
    3. Call `_searchService.SearchAsync(term, userId, maxPerType)`
    4. Return 200 with GlobalSearchResult

    Response DTO (defined as record in controller file):
    ```csharp
    public record SearchResponse(
        List<SearchGroupDto> Groups,
        int TotalCount
    );
    public record SearchGroupDto(
        string EntityType,
        List<SearchHitDto> Items
    );
    public record SearchHitDto(
        Guid Id,
        string Title,
        string? Subtitle,
        string EntityType,
        string Url
    );
    ```

    Map from domain GlobalSearchResult/SearchHit to controller DTOs (or use domain types directly if they suffice since they're simple DTOs already).
  </action>
  <verify>
    `dotnet build` succeeds. `curl -X GET "http://localhost:5233/api/search?q=acme" -H "Authorization: Bearer {token}"` returns grouped search results. Test with existing seed data company/contact names.
  </verify>
  <done>
    GET /api/search?q={term} returns results grouped by entity type (Company, Contact, Deal) with ranking, partial matching, and RBAC permission scoping. Minimum 2-character query enforced.
  </done>
</task>

</tasks>

<verification>
- `dotnet build` passes
- GET /api/search?q=acme returns Company results from seed data
- Results respect RBAC permissions
- Prefix matching works (partial words return results)
- Results are ranked by relevance
- Each result has entityType, title, subtitle, url
</verification>

<success_criteria>
Global search backend is functional: single endpoint searches across Company, Contact, Deal using PostgreSQL tsvector with prefix matching, returns ranked results grouped by entity type, and respects per-entity RBAC permissions.
</success_criteria>

<output>
After completion, create `.planning/phases/10-data-operations/10-03-SUMMARY.md`
</output>
