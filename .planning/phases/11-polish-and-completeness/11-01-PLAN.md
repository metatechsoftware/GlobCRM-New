---
phase: 11-polish-and-completeness
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/GlobCRM.Domain/Entities/Note.cs
  - src/GlobCRM.Domain/Entities/Attachment.cs
  - src/GlobCRM.Infrastructure/Persistence/Configurations/NoteConfiguration.cs
  - src/GlobCRM.Infrastructure/Persistence/Configurations/AttachmentConfiguration.cs
  - src/GlobCRM.Infrastructure/Persistence/ApplicationDbContext.cs
  - src/GlobCRM.Infrastructure/Storage/AzureBlobStorageService.cs
  - src/GlobCRM.Infrastructure/DependencyInjection.cs
  - src/GlobCRM.Infrastructure/GlobCRM.Infrastructure.csproj
autonomous: true
must_haves:
  truths:
    - "Note and Attachment entities exist in the domain layer with correct properties"
    - "EF Core configurations apply tenant query filters, table mappings, and FK constraints"
    - "Database migration creates notes and attachments tables with RLS policies"
    - "AzureBlobStorageService implements IFileStorageService with tenant-partitioned blob paths"
    - "DI registration switches between Local and Azure storage based on configuration"
  artifacts:
    - path: "src/GlobCRM.Domain/Entities/Note.cs"
      provides: "Note entity with rich text body, polymorphic entity linking, author FK"
      contains: "class Note"
    - path: "src/GlobCRM.Domain/Entities/Attachment.cs"
      provides: "Generic attachment entity with EntityType/EntityId polymorphic linking"
      contains: "class Attachment"
    - path: "src/GlobCRM.Infrastructure/Persistence/Configurations/NoteConfiguration.cs"
      provides: "EF Core config with tenant query filter, table mapping, indexes"
      contains: "class NoteConfiguration"
    - path: "src/GlobCRM.Infrastructure/Persistence/Configurations/AttachmentConfiguration.cs"
      provides: "EF Core config with tenant query filter, table mapping, indexes"
      contains: "class AttachmentConfiguration"
    - path: "src/GlobCRM.Infrastructure/Storage/AzureBlobStorageService.cs"
      provides: "Azure Blob implementation of IFileStorageService"
      contains: "class AzureBlobStorageService"
  key_links:
    - from: "ApplicationDbContext"
      to: "Note, Attachment"
      via: "DbSet properties"
      pattern: "DbSet<Note>|DbSet<Attachment>"
    - from: "DependencyInjection.cs"
      to: "AzureBlobStorageService"
      via: "Conditional DI registration"
      pattern: "AzureBlobStorageService|IFileStorageService"
---

<objective>
Create backend domain entities for Note and Attachment, configure EF Core mappings with tenant isolation, generate database migration, and implement AzureBlobStorageService for cloud file storage.

Purpose: Establishes the data foundation for notes and generic entity attachments, plus production-ready cloud storage.
Output: Note.cs, Attachment.cs, EF Core configurations, migration, AzureBlobStorageService.cs
</objective>

<execution_context>
@/Users/metatech/.claude/get-shit-done/workflows/execute-plan.md
@/Users/metatech/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/11-polish-and-completeness/11-RESEARCH.md

@src/GlobCRM.Domain/Entities/ActivityAttachment.cs
@src/GlobCRM.Domain/Entities/ActivityLink.cs
@src/GlobCRM.Infrastructure/Storage/IFileStorageService.cs
@src/GlobCRM.Infrastructure/Storage/LocalFileStorageService.cs
@src/GlobCRM.Infrastructure/Persistence/ApplicationDbContext.cs
@src/GlobCRM.Infrastructure/DependencyInjection.cs
@src/GlobCRM.Infrastructure/Persistence/Configurations/ActivityAttachmentConfiguration.cs
@src/GlobCRM.Infrastructure/Persistence/Configurations/FeedItemConfiguration.cs
</context>

<tasks>

<task type="auto">
  <name>Task 1: Note and Attachment domain entities + EF Core configurations</name>
  <files>
    src/GlobCRM.Domain/Entities/Note.cs
    src/GlobCRM.Domain/Entities/Attachment.cs
    src/GlobCRM.Infrastructure/Persistence/Configurations/NoteConfiguration.cs
    src/GlobCRM.Infrastructure/Persistence/Configurations/AttachmentConfiguration.cs
    src/GlobCRM.Infrastructure/Persistence/ApplicationDbContext.cs
  </files>
  <action>
    Create Note entity in Domain/Entities/Note.cs following the polymorphic entity linking pattern from ActivityLink:
    - Id (Guid), TenantId (Guid), Title (string), Body (string, HTML from Quill), PlainTextBody (string?, stripped text for search/list display)
    - EntityType (string, e.g. "Company", "Contact", "Deal", "Quote", "Request"), EntityId (Guid), EntityName (string?, denormalized)
    - AuthorId (Guid?, nullable with SetNull FK), Author nav prop (ApplicationUser?)
    - CreatedAt (DateTimeOffset), UpdatedAt (DateTimeOffset)
    - IsSeedData (bool) for tenant seeder
    - Note is tenant-scoped (has TenantId + query filter + RLS)

    Create Attachment entity in Domain/Entities/Attachment.cs following ActivityAttachment pattern but with polymorphic linking:
    - Id (Guid), TenantId (Guid)
    - EntityType (string), EntityId (Guid) -- polymorphic link to any CRM entity
    - FileName (string), StoragePath (string), ContentType (string), FileSizeBytes (long)
    - UploadedById (Guid?, SetNull FK), UploadedBy nav prop (ApplicationUser?)
    - UploadedAt (DateTimeOffset)
    - Attachment is tenant-scoped (has TenantId + query filter + RLS)

    Create NoteConfiguration.cs:
    - Table name "notes" (snake_case matching codebase convention)
    - HasQueryFilter combining tenant AND NOT soft-delete is not needed (Note has no soft-delete, just tenant filter): .HasQueryFilter(n => n.TenantId == _tenantProvider.GetTenantId())
    - Actually, follow the exact pattern from other tenant-scoped configs. Check how CompanyConfiguration or FeedItemConfiguration does it.
    - Index on (TenantId, EntityType, EntityId) for entity-scoped note queries
    - Index on (TenantId, AuthorId) for author-scoped queries
    - AuthorId FK with SetNull delete behavior
    - Body as text column type for large HTML content
    - PlainTextBody as text column type

    Create AttachmentConfiguration.cs:
    - Table name "attachments"
    - HasQueryFilter for tenant isolation (match existing pattern)
    - Index on (TenantId, EntityType, EntityId) for entity-scoped attachment queries
    - UploadedById FK with SetNull delete behavior
    - StoragePath max length 500

    Add DbSet<Note> Notes and DbSet<Attachment> Attachments to ApplicationDbContext.
    Add the configurations to OnModelCreating via ApplyConfiguration (they should be auto-discovered if using ApplyConfigurationsFromAssembly, check existing pattern).

    Generate EF Core migration:
    ```
    cd src/GlobCRM.Api
    dotnet ef migrations add AddNotesAndAttachments --project ../GlobCRM.Infrastructure
    ```

    Add RLS policies via migrationBuilder.Sql() in the migration Up method (matching existing pattern from Phase 1):
    ```sql
    ALTER TABLE notes ENABLE ROW LEVEL SECURITY;
    CREATE POLICY tenant_isolation_notes ON notes USING (tenant_id::text = current_setting('app.current_tenant', true));
    ALTER TABLE notes FORCE ROW LEVEL SECURITY;

    ALTER TABLE attachments ENABLE ROW LEVEL SECURITY;
    CREATE POLICY tenant_isolation_attachments ON attachments USING (tenant_id::text = current_setting('app.current_tenant', true));
    ALTER TABLE attachments FORCE ROW LEVEL SECURITY;
    ```
  </action>
  <verify>
    `cd src/GlobCRM.Api && dotnet build` compiles without errors. Migration file exists in Migrations folder.
  </verify>
  <done>Note and Attachment entities exist with EF Core configurations, tenant query filters, indexes, and RLS policies. DbSets registered in ApplicationDbContext.</done>
</task>

<task type="auto">
  <name>Task 2: AzureBlobStorageService + conditional DI registration</name>
  <files>
    src/GlobCRM.Infrastructure/Storage/AzureBlobStorageService.cs
    src/GlobCRM.Infrastructure/DependencyInjection.cs
    src/GlobCRM.Infrastructure/GlobCRM.Infrastructure.csproj
  </files>
  <action>
    Add Azure.Storage.Blobs NuGet package to Infrastructure project:
    ```
    cd src/GlobCRM.Infrastructure
    dotnet add package Azure.Storage.Blobs --version 12.27.0
    ```

    Create AzureBlobStorageService.cs implementing IFileStorageService:
    - Constructor takes IConfiguration, reads "FileStorage:Azure:ConnectionString"
    - Creates BlobServiceClient from connection string
    - Container name: "attachments" (single container, tenant isolation via virtual directory)
    - SaveFileAsync: blob path = "{tenantId}/{category}/{fileName}", upload via BlobClient.UploadAsync with overwrite:true, return blob path
    - GetFileAsync: download blob to byte[], return null if blob not found (RequestFailedException with 404 status)
    - DeleteFileAsync: delete blob, ignore 404 (blob already gone)
    - All methods use CancellationToken

    Update DependencyInjection.cs to conditionally register storage:
    - Read configuration["FileStorage:Provider"] (default: "Local")
    - If "Azure": register AzureBlobStorageService as IFileStorageService (Scoped)
    - If "Local" (default): keep existing LocalFileStorageService registration
    - This ensures existing LocalFileStorageService still works for development

    Add to appsettings.Development.json (if not already present):
    ```json
    "FileStorage": {
      "Provider": "Local"
    }
    ```

    This makes AzureBlobStorageService code-complete but defaulting to LocalFileStorageService for development.
  </action>
  <verify>
    `cd src/GlobCRM.Api && dotnet build` compiles without errors. AzureBlobStorageService.cs exists and implements all three IFileStorageService methods.
  </verify>
  <done>AzureBlobStorageService implements IFileStorageService with tenant-partitioned Azure Blob paths. DI registration conditionally switches between Local (dev) and Azure (production) based on config. Existing code using IFileStorageService needs zero changes.</done>
</task>

</tasks>

<verification>
- `dotnet build` succeeds for the entire solution
- Note.cs has: Id, TenantId, Title, Body, PlainTextBody, EntityType, EntityId, EntityName, AuthorId, CreatedAt, UpdatedAt
- Attachment.cs has: Id, TenantId, EntityType, EntityId, FileName, StoragePath, ContentType, FileSizeBytes, UploadedById, UploadedAt
- Migration file creates notes and attachments tables with RLS policies
- ApplicationDbContext has DbSet<Note> and DbSet<Attachment>
- AzureBlobStorageService compiles with Azure.Storage.Blobs dependency
- DependencyInjection.cs registers IFileStorageService conditionally
</verification>

<success_criteria>
Note and Attachment domain entities fully defined with EF Core configurations, migration, and RLS policies. AzureBlobStorageService ready for production with LocalFileStorageService as development default.
</success_criteria>

<output>
After completion, create `.planning/phases/11-polish-and-completeness/11-01-SUMMARY.md`
</output>
