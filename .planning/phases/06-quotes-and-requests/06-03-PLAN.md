---
phase: 06-quotes-and-requests
plan: 03
type: execute
wave: 3
depends_on: ["06-02"]
files_modified:
  - src/GlobCRM.Api/Controllers/QuotesController.cs
  - src/GlobCRM.Api/Controllers/RequestsController.cs
  - src/GlobCRM.Infrastructure/Pdf/QuotePdfDocument.cs
  - src/GlobCRM.Infrastructure/Pdf/PdfServiceExtensions.cs
  - src/GlobCRM.Infrastructure/GlobCRM.Infrastructure.csproj
  - src/GlobCRM.Api/Program.cs
autonomous: true

must_haves:
  truths:
    - "User can CRUD quotes with line items via REST API"
    - "Quote totals are recalculated server-side on every create/update"
    - "User can generate PDF from a quote via GET /api/quotes/{id}/pdf"
    - "User can create a new version from an existing quote via POST /api/quotes/{id}/new-version"
    - "User can CRUD requests via REST API"
    - "Request status transitions are validated by RequestWorkflow before applying"
    - "Both controllers enforce RBAC permission policies"
  artifacts:
    - path: "src/GlobCRM.Api/Controllers/QuotesController.cs"
      provides: "Quote CRUD + PDF generation + versioning + status transition + timeline"
      contains: "class QuotesController"
    - path: "src/GlobCRM.Api/Controllers/RequestsController.cs"
      provides: "Request CRUD + status workflow + timeline"
      contains: "class RequestsController"
    - path: "src/GlobCRM.Infrastructure/Pdf/QuotePdfDocument.cs"
      provides: "QuestPDF IDocument for quote PDF rendering"
      contains: "class QuotePdfDocument"
  key_links:
    - from: "src/GlobCRM.Api/Controllers/QuotesController.cs"
      to: "src/GlobCRM.Infrastructure/Pdf/QuotePdfDocument.cs"
      via: "PDF generation in GeneratePdf endpoint"
      pattern: "QuotePdfDocument"
    - from: "src/GlobCRM.Api/Controllers/RequestsController.cs"
      to: "src/GlobCRM.Domain/Entities/RequestWorkflow.cs"
      via: "Status transition validation"
      pattern: "RequestWorkflow.CanTransition"
---

<objective>
Build the QuotesController (CRUD + PDF + versioning + status) and RequestsController (CRUD + status workflow), plus QuestPDF infrastructure for quote PDF generation.

Purpose: Provide the complete REST API for quote and request management that the Angular frontend will consume.
Output: Two API controllers, QuestPDF document class, PDF service registration
</objective>

<execution_context>
@/Users/metatech/.claude/get-shit-done/workflows/execute-plan.md
@/Users/metatech/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/06-quotes-and-requests/06-RESEARCH.md
@.planning/phases/06-quotes-and-requests/06-01-SUMMARY.md
@.planning/phases/06-quotes-and-requests/06-02-SUMMARY.md

# Pattern references
@src/GlobCRM.Api/Controllers/DealsController.cs
@src/GlobCRM.Api/Controllers/ActivitiesController.cs
@src/GlobCRM.Api/Controllers/CompaniesController.cs
@src/GlobCRM.Domain/Entities/ActivityWorkflow.cs
@src/GlobCRM.Domain/Entities/RequestWorkflow.cs
</context>

<tasks>

<task type="auto">
  <name>Task 1: Install QuestPDF, create QuotePdfDocument, and build QuotesController</name>
  <files>
    src/GlobCRM.Infrastructure/GlobCRM.Infrastructure.csproj
    src/GlobCRM.Infrastructure/Pdf/QuotePdfDocument.cs
    src/GlobCRM.Infrastructure/Pdf/PdfServiceExtensions.cs
    src/GlobCRM.Api/Controllers/QuotesController.cs
    src/GlobCRM.Api/Program.cs
  </files>
  <action>
    **Step 1: Install QuestPDF**
    Run: `dotnet add src/GlobCRM.Infrastructure/GlobCRM.Infrastructure.csproj package QuestPDF --version 2026.2.0`

    **Step 2: Create PdfServiceExtensions** (src/GlobCRM.Infrastructure/Pdf/PdfServiceExtensions.cs):
    - Static class with AddPdfServices(this IServiceCollection services) extension method
    - Inside: QuestPDF.Settings.License = LicenseType.Community;
    - This is called from Program.cs at startup

    **Step 3: Register in Program.cs:**
    - Add `builder.Services.AddPdfServices();` near existing service registrations
    - Add the using statement for the Pdf namespace

    **Step 4: Create QuotePdfDocument** (src/GlobCRM.Infrastructure/Pdf/QuotePdfDocument.cs):
    - Implement IDocument interface from QuestPDF
    - Accept a QuotePdfModel record (define as nested class or separate file):
      - OrganizationName (string), QuoteNumber, VersionNumber, Title, Description?
      - ContactName?, CompanyName?, IssueDate (DateOnly), ExpiryDate? (DateOnly)
      - LineItems (list of line item models), Subtotal, DiscountTotal, TaxTotal, GrandTotal (decimal)
      - Notes? (string), Status (string)
    - Compose method: A4 page, 40pt margin, 10pt default text
    - Header: Organization name (18pt bold), quote number + version, issue date, expiry date, contact/company
    - Content: Title (14pt bold), description, line items table with columns: #, Description, Qty, Unit Price, Discount%, Tax%, Total. Then totals section (Subtotal, Discount, Tax, Grand Total bold 14pt). Then Notes section if present.
    - Footer: Page X of Y centered
    - Follow the QuestPDF pattern from the research document exactly

    **Step 5: Create QuotesController** (src/GlobCRM.Api/Controllers/QuotesController.cs):
    - Follow DealsController pattern for CRUD + ActivitiesController for workflow
    - Route: api/quotes, [Authorize]
    - DI: IQuoteRepository, IPermissionService, ICustomFieldRepository, CustomFieldValidator, ITenantProvider, ApplicationDbContext, ILogger

    Endpoints:
    1. **GET /api/quotes** [Permission:Quote:View] - Paginated list with EntityQueryParams, returns QuoteListDto (id, quoteNumber, title, status, grandTotal, contactName, companyName, dealTitle, ownerName, versionNumber, issueDate, createdAt)
    2. **GET /api/quotes/{id}** [Permission:Quote:View] - Detail with line items, returns QuoteDetailDto (all list fields + description, notes, expiryDate, lineItems[], customFields, originalQuoteId, versions[])
    3. **POST /api/quotes** [Permission:Quote:Create] - Create quote with line items. Accept CreateQuoteRequest (title, description, dealId?, contactId?, companyId?, issueDate, expiryDate?, notes, lineItems[]). Auto-generate QuoteNumber using COALESCE(MAX) pattern: `SELECT COALESCE(MAX(CAST(SUBSTRING(quote_number FROM 3) AS INT)), 0) + 1 FROM quotes WHERE tenant_id = @tenantId` or simpler: count existing + 1, format as Q-{padded}. Recalculate ALL line item totals and quote totals server-side using QuoteCalculator logic (see research). Set Status = Draft, VersionNumber = 1. Validate custom fields.
    4. **PUT /api/quotes/{id}** [Permission:Quote:Update] - Update quote header + replace all line items (batch replacement: delete old, insert new). Recalculate ALL totals. Do NOT allow status change via PUT. Validate custom fields. Use ownership scope check.
    5. **DELETE /api/quotes/{id}** [Permission:Quote:Delete] - Soft or hard delete. Use ownership scope check.
    6. **PATCH /api/quotes/{id}/status** [Permission:Quote:Update] - Change status. Define QuoteWorkflow transitions: Draft->[Sent], Sent->[Accepted, Rejected, Expired, Draft], Accepted->[], Rejected->[Draft], Expired->[Draft]. Validate transition. Create QuoteStatusHistory record. Use ownership scope check.
    7. **GET /api/quotes/{id}/pdf** [Permission:Quote:View] - Generate PDF on-demand. Load quote with line items, build QuotePdfModel, create QuotePdfDocument, call GeneratePdf() to get byte[], return File(bytes, "application/pdf", filename). Filename: Quote-{number}-v{version}.pdf.
    8. **POST /api/quotes/{id}/new-version** [Permission:Quote:Create] - Deep clone quote + all line items. Increment VersionNumber. Set OriginalQuoteId to original.OriginalQuoteId ?? original.Id. Reset Status to Draft. Keep same QuoteNumber. Set new IssueDate to today. Return 201 with new quote.
    9. **GET /api/quotes/{id}/timeline** [Permission:Quote:View] - Timeline aggregation: creation event + status changes from QuoteStatusHistory, ordered by date desc.

    Define all DTOs inline in the controller file (following existing controller pattern):
    - QuoteListDto, QuoteDetailDto, QuoteLineItemDto, CreateQuoteRequest, CreateQuoteLineItemRequest, UpdateQuoteRequest, UpdateQuoteLineItemRequest, UpdateQuoteStatusRequest
    - FluentValidation: CreateQuoteRequestValidator (title 3-500 chars, at least 1 line item, line item quantity > 0, unitPrice >= 0)

    Include a static QuoteCalculator helper class (or static methods) for recalculating line item and quote totals -- matches research pattern using Math.Round(value, 2) for amounts.

    QuoteWorkflow transitions (define as static dictionary in controller or separate class):
    - Draft -> [Sent]
    - Sent -> [Accepted, Rejected, Expired, Draft]
    - Accepted -> [] (terminal)
    - Rejected -> [Draft] (revision)
    - Expired -> [Draft] (revision)
  </action>
  <verify>dotnet build -- should compile with 0 errors. QuotesController has 9 endpoints. QuestPDF package installed.</verify>
  <done>QuotesController has 9 endpoints (list, detail, create, update, delete, status, pdf, new-version, timeline). PDF generates A4 document with line items table and totals. All line item calculations done server-side with Math.Round. QuoteWorkflow validates status transitions. FluentValidation on create request.</done>
</task>

<task type="auto">
  <name>Task 2: Build RequestsController with CRUD, status workflow, and timeline</name>
  <files>
    src/GlobCRM.Api/Controllers/RequestsController.cs
  </files>
  <action>
    Create RequestsController following ActivitiesController pattern:

    - Route: api/requests, [Authorize]
    - DI: IRequestRepository, IPermissionService, ICustomFieldRepository, CustomFieldValidator, ITenantProvider, ApplicationDbContext, ILogger

    Endpoints:
    1. **GET /api/requests** [Permission:Request:View] - Paginated list with EntityQueryParams, returns RequestListDto (id, subject, status, priority, category, contactName, companyName, ownerName, assignedToName, createdAt, resolvedAt)
    2. **GET /api/requests/{id}** [Permission:Request:View] - Detail returns RequestDetailDto (all list fields + description, contactId, companyId, ownerId, assignedToId, closedAt, customFields, allowedTransitions[])
    3. **POST /api/requests** [Permission:Request:Create] - Create with CreateRequestRequest (subject, description?, priority as string, category?, contactId?, companyId?, assignedToId?, customFields?). Status starts at New. Use Enum.TryParse for priority (matching Activity pattern). Validate custom fields. Set OwnerId to current user.
    4. **PUT /api/requests/{id}** [Permission:Request:Update] - Update request fields. Do NOT allow status change via PUT (use PATCH /status). Validate custom fields. Use dual-ownership scope check (OwnerId OR AssignedToId, matching Activity pattern).
    5. **DELETE /api/requests/{id}** [Permission:Request:Delete] - Delete with ownership scope check.
    6. **PATCH /api/requests/{id}/status** [Permission:Request:Update] - Change status using RequestWorkflow.CanTransition validation. If transitioning to Resolved, set ResolvedAt. If transitioning to Closed, set ClosedAt. If reopening (back to InProgress/New), clear ResolvedAt/ClosedAt. Use dual-ownership scope check.
    7. **GET /api/requests/{id}/allowed-transitions** [Permission:Request:View] - Return RequestWorkflow.GetAllowedTransitions(currentStatus) for frontend drop targets / button rendering.
    8. **GET /api/requests/{id}/timeline** [Permission:Request:View] - Timeline aggregation: creation event + any status change events (if we add RequestStatusHistory -- OR just creation + current status for simplicity since Requests don't have a separate status history table). For simplicity, return creation event and infer status changes from ResolvedAt/ClosedAt timestamps.

    Define all DTOs inline in the controller file:
    - RequestListDto, RequestDetailDto, CreateRequestRequest, UpdateRequestRequest, UpdateRequestStatusRequest
    - FluentValidation: CreateRequestRequestValidator (subject 3-500 chars, priority must be valid enum string)

    Note: Requests are simpler than Activities -- no sub-resources (comments, attachments, time entries). Just CRUD + workflow.
  </action>
  <verify>dotnet build -- should compile with 0 errors. RequestsController has 8 endpoints.</verify>
  <done>RequestsController has 8 endpoints (list, detail, create, update, delete, status, allowed-transitions, timeline). Status transitions validated by RequestWorkflow. Dual-ownership scope on all mutating endpoints. FluentValidation on create request.</done>
</task>

</tasks>

<verification>
- `dotnet build` compiles with 0 errors
- QuotesController.cs exists with 9 endpoints
- RequestsController.cs exists with 8 endpoints
- QuotePdfDocument.cs generates valid PDF bytes
- QuestPDF 2026.2.0 in Infrastructure.csproj
- PdfServiceExtensions registered in Program.cs
</verification>

<success_criteria>
- All 17 REST endpoints created across both controllers
- Quote create/update recalculates all line item and quote totals server-side
- PDF endpoint returns application/pdf with proper filename
- Quote versioning deep-clones header + line items with incremented version
- Request status transitions validated by RequestWorkflow
- Both controllers use Permission:Entity:Operation policy authorization
- FluentValidation on create requests
</success_criteria>

<output>
After completion, create `.planning/phases/06-quotes-and-requests/06-03-SUMMARY.md`
</output>
