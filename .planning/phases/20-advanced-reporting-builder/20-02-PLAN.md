---
phase: 20-advanced-reporting-builder
plan: 02
type: execute
wave: 2
depends_on: [20-01]
files_modified:
  - src/GlobCRM.Infrastructure/Reporting/ReportFieldMetadataService.cs
  - src/GlobCRM.Infrastructure/Reporting/ReportQueryEngine.cs
  - src/GlobCRM.Infrastructure/Reporting/ReportingServiceExtensions.cs
autonomous: true
requirements: [RPT-01, RPT-02, RPT-03, RPT-07]

must_haves:
  truths:
    - "ReportFieldMetadataService returns system, custom, formula, and related entity fields for any CRM entity type"
    - "ReportQueryEngine can dynamically filter any CRM entity using nested AND/OR filter groups"
    - "ReportQueryEngine can group results by any field and apply aggregations (count, sum, average, min, max)"
    - "Related entity fields one level deep are accessible in field metadata and query results"
  artifacts:
    - path: "src/GlobCRM.Infrastructure/Reporting/ReportFieldMetadataService.cs"
      provides: "Field discovery service combining FieldRegistryService + custom fields + related entity fields"
      contains: "class ReportFieldMetadataService"
    - path: "src/GlobCRM.Infrastructure/Reporting/ReportQueryEngine.cs"
      provides: "Dynamic query builder for report execution with filter expressions, grouping, and aggregation"
      contains: "class ReportQueryEngine"
    - path: "src/GlobCRM.Infrastructure/Reporting/ReportingServiceExtensions.cs"
      provides: "DI registration for all reporting services"
      contains: "AddReportingServices"
  key_links:
    - from: "src/GlobCRM.Infrastructure/Reporting/ReportFieldMetadataService.cs"
      to: "src/GlobCRM.Infrastructure/FormulaFields/FieldRegistryService.cs"
      via: "Injection for system field definitions"
      pattern: "FieldRegistryService"
    - from: "src/GlobCRM.Infrastructure/Reporting/ReportQueryEngine.cs"
      to: "src/GlobCRM.Infrastructure/Persistence/ApplicationDbContext.cs"
      via: "DbContext for dynamic entity queries"
      pattern: "ApplicationDbContext"
---

<objective>
Build the ReportFieldMetadataService (field discovery per entity type including related entity fields) and ReportQueryEngine (dynamic query builder with Expression trees for filtering and System.Linq.Dynamic.Core for grouping/aggregation).

Purpose: These two services form the core engine that powers report execution -- without them, reports cannot discover available fields or execute queries.
Output: ReportFieldMetadataService.cs, ReportQueryEngine.cs, ReportingServiceExtensions.cs
</objective>

<execution_context>
@/Users/metatech/.claude/get-shit-done/workflows/execute-plan.md
@/Users/metatech/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/20-advanced-reporting-builder/20-RESEARCH.md
@.planning/phases/20-advanced-reporting-builder/20-01-SUMMARY.md

# Key patterns:
@src/GlobCRM.Infrastructure/FormulaFields/FieldRegistryService.cs
@src/GlobCRM.Infrastructure/FormulaFields/FormulaEvaluationService.cs
@src/GlobCRM.Infrastructure/Services/DashboardAggregationService.cs
@src/GlobCRM.Infrastructure/Persistence/ApplicationDbContext.cs
@src/GlobCRM.Domain/Entities/Report.cs
</context>

<tasks>

<task type="auto">
  <name>Task 1: ReportFieldMetadataService — field discovery for all entity types with related entity fields</name>
  <files>
    src/GlobCRM.Infrastructure/Reporting/ReportFieldMetadataService.cs
  </files>
  <action>
    Create `ReportFieldMetadataService` in `src/GlobCRM.Infrastructure/Reporting/`.

    **Purpose:** Given an entity type string (e.g., "Contact"), return all available fields grouped by category: system, custom, formula, and related entity fields.

    **Inject:** FieldRegistryService (for system fields), ICustomFieldRepository (for custom + formula fields).

    **Method:** `Task<ReportFieldMetadataResult> GetFieldsForEntityTypeAsync(string entityType)`

    **ReportFieldMetadataResult** (record or class in same file):
    - `List<ReportFieldInfo> SystemFields`
    - `List<ReportFieldInfo> CustomFields`
    - `List<ReportFieldInfo> FormulaFields`
    - `List<ReportFieldInfo> RelatedFields`

    **ReportFieldInfo** (record):
    - `string FieldId` — e.g., "name", "custom_field_name", "related.Company.name"
    - `string Label` — display name, e.g., "Company > Name"
    - `string Category` — "system", "custom", "formula", "related"
    - `string DataType` — "string", "number", "date", "boolean", "currency"
    - `bool IsAggregatable` — true for number, currency, formula-number fields
    - `bool IsGroupable` — true for all except formula fields (can't GROUP BY formula in SQL)
    - `string? RelatedEntity` — null for direct fields, "Company" for related.Company.name
    - `string? RelatedField` — null for direct fields, "name" for related.Company.name

    **System fields** — Use FieldRegistryService.GetAvailableFields() for each entity type. Map FieldDefinition to ReportFieldInfo. Mark numeric types as aggregatable. All system fields are groupable.

    **Custom fields** — Call ICustomFieldRepository.GetFieldsByEntityTypeAsync(entityType). Map custom fields to ReportFieldInfo. Number/Currency custom fields are aggregatable. Skip Formula type from custom category (add to formula category instead).

    **Formula fields** — Filter custom field definitions where Type == Formula. Map to ReportFieldInfo. Aggregatable only if FormulaResultType == "number". NOT groupable (computed server-side, can't use in SQL GROUP BY). NOT filterable in SQL (but can be used as display columns).

    **Related entity fields** — Build from the relationship map documented in research (20-RESEARCH.md "Entity Relationship Map" section):
    - Contact -> Company (Name, Industry, Website, Phone, City, Country), Owner (FirstName, LastName, Email)
    - Deal -> Company (Name, Industry), Stage (Name), Pipeline (Name), Owner (FirstName, LastName, Email)
    - Lead -> Stage (Name), Source (Name), Owner (FirstName, LastName, Email)
    - Activity -> Owner (FirstName, LastName, Email), AssignedTo (FirstName, LastName, Email)
    - Quote -> Contact (FirstName, LastName, Email), Company (Name), Deal (Title, Value), Owner
    - Request -> Contact (FirstName, LastName, Email), Company (Name), Owner, AssignedTo
    - Product -> (none)

    FieldId format for related fields: `"related.{RelatedEntity}.{fieldName}"` (e.g., `"related.Company.name"`, `"related.Stage.name"`)
    Label format: `"{RelatedEntity} > {FieldLabel}"` (e.g., `"Company > Name"`, `"Stage > Name"`)

    Use a private method `GetRelatedFieldsForEntityType(string entityType)` with a switch expression returning List<ReportFieldInfo> for each entity type's relationships.
  </action>
  <verify>Build succeeds: `cd src/GlobCRM.Api && dotnet build`</verify>
  <done>ReportFieldMetadataService returns system, custom, formula, and related entity fields for all 8 CRM entity types (Contact, Deal, Company, Lead, Activity, Quote, Request, Product).</done>
</task>

<task type="auto">
  <name>Task 2: ReportQueryEngine — dynamic query execution with filter expressions, grouping, and aggregation</name>
  <files>
    src/GlobCRM.Infrastructure/Reporting/ReportQueryEngine.cs
    src/GlobCRM.Infrastructure/Reporting/ReportingServiceExtensions.cs
  </files>
  <action>
    Create `ReportQueryEngine` in `src/GlobCRM.Infrastructure/Reporting/`.

    **Inject:** ApplicationDbContext, FormulaEvaluationService, ICustomFieldRepository.

    **Core method:** `Task<ReportExecutionResult> ExecuteReportAsync(Report report, int page, int pageSize, Guid userId, PermissionScope scope, List<Guid>? teamMemberIds, ReportFilterCondition? drillDownFilter = null)`

    **ReportExecutionResult** (record or class in same file):
    - `List<Dictionary<string, object?>> Rows` — flat row data
    - `int TotalCount` — total rows before pagination
    - `List<ReportAggregateResult>? Aggregates` — aggregate values when grouping is active
    - `List<string> ColumnHeaders` — ordered field labels

    **ReportAggregateResult** (record):
    - `string FieldId`, `string Label`, `AggregationType Aggregation`, `object? Value`

    **Execution flow:**

    1. **Resolve base query:** Switch on report.EntityType to get the correct IQueryable:
       - "Contact" -> `_db.Contacts.Include(c => c.Company)`
       - "Deal" -> `_db.Deals.Include(d => d.Stage).Include(d => d.Pipeline).Include(d => d.Company)`
       - "Company" -> `_db.Companies`
       - "Lead" -> `_db.Leads.Include(l => l.Stage).Include(l => l.Source)`
       - "Activity" -> `_db.Activities`
       - "Quote" -> `_db.Quotes.Include(q => q.Contact).Include(q => q.Company).Include(q => q.Deal)`
       - "Request" -> `_db.Requests.Include(r => r.Contact).Include(r => r.Company)`
       - "Product" -> `_db.Products`
       Add .Include() calls only for related entities that appear in the report's field list.

    2. **Apply ownership scope:** Reuse the existing pattern from repository filter methods — if scope is Own, filter by OwnerId == userId; if Team, filter by OwnerId in teamMemberIds; if All, no filter.

    3. **Apply filter groups:** Build Expression<Func<T, bool>> from the report's ReportFilterGroup using a recursive method `BuildFilterGroupExpression<T>()`:
       - For each ReportFilterCondition, build a property access expression (handle nested "related.Company.name" by splitting on "." and building member access chain)
       - Support operators: equals, not_equals, contains, not_contains, greater_than, less_than, greater_than_or_equal, less_than_or_equal, between, is_empty, is_not_empty
       - Combine conditions within a group using AND or OR based on FilterLogic
       - Recurse into child groups
       - If drillDownFilter is provided, add it as an additional AND condition

    4. **If no grouping:** Execute flat query:
       - Get total count
       - Apply pagination (Skip/Take)
       - Load entities to memory
       - Project selected fields into Dictionary<string, object?> rows
       - For related fields (e.g., "related.Company.name"), navigate the entity graph
       - For formula fields, run FormulaEvaluationService on each entity row
       - Return ReportExecutionResult with rows, totalCount, and null aggregates

    5. **If grouping active:** Execute grouped query using System.Linq.Dynamic.Core:
       - Build GroupBy string from grouping fields (e.g., `"new(Stage.Name as GroupKey)"` for "related.Stage.name")
       - For date fields with DateTruncation, use EF.Functions.DateTruncate or extract Year/Month
       - Build Select string with aggregate functions: `"new(Key.GroupKey, Count() as Count, Sum(Value) as SumValue)"`
       - Execute the dynamic query
       - Map results to rows + aggregates
       - For grouped results: each row is a group with the group key and aggregate values
       - Return ReportExecutionResult with grouped rows and aggregate summary

    **Important implementation notes:**
    - Use System.Linq.Dynamic.Core's `DynamicQueryableExtensions.GroupBy()` and `.Select()` for grouping — this avoids hand-rolling massive expression trees
    - For custom field filtering: custom fields are JSONB (`Dictionary<string, object?>`), so filter by extracting values at the application level after initial SQL-translated filters. Apply SQL-translatable filters first, then custom field filters in-memory on the smaller result set.
    - For formula field display: load entities, compute formulas via FormulaEvaluationService, then project into result rows. Do NOT attempt SQL-level formula computation.
    - Aggregation on custom fields: support only system fields and formula number fields for SQL-level aggregation. Custom field numeric aggregation is done in-memory with a 10K row guard.
    - Wrap query execution in try-catch. On EF Core translation failure, log the error and return a user-friendly error message.

    **ReportingServiceExtensions.cs** — Create in `src/GlobCRM.Infrastructure/Reporting/`:
    ```csharp
    public static class ReportingServiceExtensions
    {
        public static IServiceCollection AddReportingServices(this IServiceCollection services)
        {
            services.AddScoped<ReportFieldMetadataService>();
            services.AddScoped<ReportQueryEngine>();
            return services;
        }
    }
    ```
    Wire into DependencyInjection.cs: `services.AddReportingServices();`
  </action>
  <verify>Build succeeds: `cd src/GlobCRM.Api && dotnet build`</verify>
  <done>ReportQueryEngine can execute dynamic queries against any CRM entity type with nested AND/OR filters, related entity field access, grouping with aggregation via System.Linq.Dynamic.Core, and formula field evaluation on results.</done>
</task>

</tasks>

<verification>
- `dotnet build` passes with 0 errors
- ReportFieldMetadataService handles all 8 entity types with related fields
- ReportQueryEngine handles flat queries (no grouping) with filter expressions
- ReportQueryEngine handles grouped queries with System.Linq.Dynamic.Core
- Both services registered via AddReportingServices()
</verification>

<success_criteria>
The report engine core is operational: field metadata discovers all available fields per entity type (including related entity fields one level deep), and the query engine can dynamically execute any report definition against any CRM entity with filtering, grouping, and aggregation.
</success_criteria>

<output>
After completion, create `.planning/phases/20-advanced-reporting-builder/20-02-SUMMARY.md`
</output>
