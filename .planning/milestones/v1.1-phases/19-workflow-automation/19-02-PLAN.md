---
phase: 19-workflow-automation
plan: 02
type: execute
wave: 2
depends_on: [19-01]
files_modified:
  - src/GlobCRM.Infrastructure/Workflows/WorkflowDomainEventHandler.cs
  - src/GlobCRM.Infrastructure/Workflows/WorkflowExecutionService.cs
  - src/GlobCRM.Infrastructure/Workflows/WorkflowConditionEvaluator.cs
  - src/GlobCRM.Infrastructure/Workflows/WorkflowActionExecutor.cs
  - src/GlobCRM.Infrastructure/Workflows/WorkflowLoopGuard.cs
  - src/GlobCRM.Infrastructure/Workflows/Actions/UpdateFieldAction.cs
  - src/GlobCRM.Infrastructure/Workflows/Actions/SendNotificationAction.cs
  - src/GlobCRM.Infrastructure/Workflows/Actions/CreateActivityAction.cs
  - src/GlobCRM.Infrastructure/Workflows/Actions/SendEmailAction.cs
  - src/GlobCRM.Infrastructure/Workflows/Actions/FireWebhookAction.cs
  - src/GlobCRM.Infrastructure/Workflows/Actions/EnrollInSequenceAction.cs
  - src/GlobCRM.Infrastructure/Workflows/DateTriggerScanService.cs
  - src/GlobCRM.Infrastructure/Workflows/WorkflowServiceExtensions.cs
  - src/GlobCRM.Infrastructure/DependencyInjection.cs
autonomous: true
requirements:
  - WFLOW-01
  - WFLOW-02
  - WFLOW-03
  - WFLOW-04
  - WFLOW-05
  - WFLOW-06
  - WFLOW-07
  - WFLOW-08
  - WFLOW-09
  - WFLOW-10

must_haves:
  truths:
    - "Domain events from entity saves trigger matching workflows and enqueue execution jobs"
    - "Workflow execution evaluates AND/OR conditions and runs actions sequentially with per-action continue-on-error"
    - "All 6 core action types execute using existing infrastructure (NotificationDispatcher, TemplateRenderService, WebhookDeliveryService, SequenceExecutionService)"
    - "If/else branch nodes route execution along matching path"
    - "Wait/delay nodes schedule remaining actions via Hangfire delayed jobs"
    - "Date-based triggers fire via recurring Hangfire scan for matching date field conditions"
    - "Loop guard prevents infinite cascading with depth limit of 5 and processed pair tracking"
  artifacts:
    - path: "src/GlobCRM.Infrastructure/Workflows/WorkflowDomainEventHandler.cs"
      provides: "IDomainEventHandler matching domain events to active workflows"
      contains: "IDomainEventHandler"
    - path: "src/GlobCRM.Infrastructure/Workflows/WorkflowExecutionService.cs"
      provides: "Hangfire job executing workflow with condition eval and action dispatch"
      contains: "ExecuteAsync"
    - path: "src/GlobCRM.Infrastructure/Workflows/WorkflowConditionEvaluator.cs"
      provides: "AND/OR condition group evaluation with field-change operators"
      contains: "changed_to"
    - path: "src/GlobCRM.Infrastructure/Workflows/WorkflowLoopGuard.cs"
      provides: "AsyncLocal depth tracking and duplicate prevention"
      contains: "MaxDepth"
    - path: "src/GlobCRM.Infrastructure/Workflows/DateTriggerScanService.cs"
      provides: "Recurring Hangfire job scanning for date-based trigger matches"
      contains: "ScanAsync"
  key_links:
    - from: "WorkflowDomainEventHandler"
      to: "WorkflowExecutionService"
      via: "Hangfire Enqueue on workflows queue"
      pattern: "Enqueue<WorkflowExecutionService>"
    - from: "WorkflowExecutionService"
      to: "WorkflowActionExecutor"
      via: "Sequential action dispatch with continue-on-error"
      pattern: "ExecuteAsync.*action"
    - from: "WorkflowActionExecutor"
      to: "6 action implementations"
      via: "ActionType switch dispatch"
      pattern: "ActionType.*switch"
---

<objective>
Build the workflow execution engine: domain event handler, condition evaluator, action executor with all 6 action types, branch/wait node support, loop prevention guard, and date-based trigger scanner.

Purpose: This is the core orchestration layer — it listens for entity lifecycle events, evaluates trigger conditions, and dispatches actions using existing infrastructure (NotificationDispatcher, TemplateRenderService, WebhookDeliveryService, SequenceExecutionService). The engine must handle branching, delays, and cascading loop prevention.

Output: WorkflowDomainEventHandler (IDomainEventHandler), WorkflowExecutionService (Hangfire job), WorkflowConditionEvaluator, WorkflowActionExecutor, 6 action implementations, WorkflowLoopGuard, DateTriggerScanService, and DI registration.
</objective>

<execution_context>
@/Users/metatech/.claude/get-shit-done/workflows/execute-plan.md
@/Users/metatech/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/phases/19-workflow-automation/19-RESEARCH.md
@.planning/phases/19-workflow-automation/19-01-SUMMARY.md
@src/GlobCRM.Infrastructure/Webhooks/WebhookDomainEventHandler.cs
@src/GlobCRM.Infrastructure/Webhooks/WebhookDeliveryService.cs
@src/GlobCRM.Infrastructure/Webhooks/WebhookServiceExtensions.cs
@src/GlobCRM.Domain/Interfaces/IDomainEvent.cs
@src/GlobCRM.Infrastructure/BackgroundJobs/TenantScope.cs
@src/GlobCRM.Infrastructure/BackgroundJobs/TenantJobFilter.cs
@src/GlobCRM.Infrastructure/Sequences/SequenceExecutionService.cs
@src/GlobCRM.Infrastructure/EmailTemplates/TemplateRenderService.cs
@src/GlobCRM.Infrastructure/EmailTemplates/MergeFieldService.cs
</context>

<tasks>

<task type="auto">
  <name>Task 1: Domain event handler, condition evaluator, loop guard, and execution service</name>
  <files>
    src/GlobCRM.Infrastructure/Workflows/WorkflowDomainEventHandler.cs
    src/GlobCRM.Infrastructure/Workflows/WorkflowExecutionService.cs
    src/GlobCRM.Infrastructure/Workflows/WorkflowConditionEvaluator.cs
    src/GlobCRM.Infrastructure/Workflows/WorkflowLoopGuard.cs
    src/GlobCRM.Infrastructure/Workflows/WorkflowActionExecutor.cs
  </files>
  <action>
Create the core execution pipeline. Mirror the WebhookDomainEventHandler pattern precisely.

**WorkflowLoopGuard.cs:**
- `MaxDepth = 5` constant (per research recommendation, conservative for CRM)
- `AsyncLocal&lt;int&gt; _currentDepth` for execution depth tracking
- `AsyncLocal&lt;HashSet&lt;string&gt;?&gt; _processedPairs` tracking `{workflowId}:{entityId}` pairs
- `CanExecute(Guid tenantId)` — returns `_currentDepth.Value < MaxDepth`
- `TryMarkProcessed(Guid workflowId, Guid entityId)` — adds to set, returns false if already present
- `IncrementDepth()` returns IDisposable DepthScope that decrements on dispose
- NOTE on Hangfire boundary: AsyncLocal does NOT survive across Hangfire job boundaries. The execution depth must be passed as a Hangfire job parameter and restored at the start of WorkflowExecutionService.ExecuteAsync(). The loop guard's AsyncLocal is for within-request cascading (when an action's SaveChanges re-enters the handler synchronously).

**WorkflowDomainEventHandler.cs** (implements IDomainEventHandler):
- Constructor injects: `IBackgroundJobClient`, `IWorkflowRepository`, `ITenantProvider`, `WorkflowLoopGuard`, `IMemoryCache`, `ILogger`
- `EligibleEntities` static HashSet: "Contact", "Company", "Deal", "Lead", "Activity" (same as webhooks)
- `CacheDuration = 60 seconds` (same TTL as webhooks)
- `HandleAsync(DomainEvent, CancellationToken)`:
  1. Check `EligibleEntities.Contains(domainEvent.EntityName)` — early return
  2. Get tenantId from ITenantProvider — early return if null
  3. Check `_loopGuard.CanExecute(tenantId)` — early return if depth exceeded (prevents cascading)
  4. Load active workflows from cache: `GetOrCreateAsync` with key `workflow_active_{tenantId}_{entityType}`, calls `_workflowRepository.GetActiveWorkflowsAsync(entityType)`
  5. For each workflow, check if ANY trigger matches the domain event:
     - RecordCreated trigger + EventType == "Created"
     - RecordUpdated trigger + EventType == "Updated"
     - RecordDeleted trigger + EventType == "Deleted"
     - FieldChanged trigger + EventType == "Updated" + ChangedProperties contains the trigger's FieldName
     - (DateBased triggers are handled by DateTriggerScanService, not here)
  6. For matching workflows: build `WorkflowTriggerContext` record (workflowId, entityId, entityType, tenantId, triggerType, eventType, changedProperties serialized as JSON string, oldPropertyValues serialized as JSON string, currentDepth from loop guard)
  7. Enqueue: `_jobClient.Enqueue<WorkflowExecutionService>("workflows", svc => svc.ExecuteAsync(context))`
  8. Wrap each iteration in try/catch — one workflow failure doesn't block others
- `InvalidateCache(Guid tenantId)` — removes all cache keys matching `workflow_active_{tenantId}_*` pattern. Call from API controller on workflow CRUD.

**WorkflowTriggerContext** (record, serializable for Hangfire):
- `WorkflowId` (Guid), `EntityId` (Guid), `EntityType` (string), `TenantId` (Guid)
- `TriggerType` (string), `EventType` (string)
- `ChangedPropertiesJson` (string? — serialized dictionary), `OldPropertyValuesJson` (string? — serialized dictionary)
- `CurrentDepth` (int — passed through Hangfire for cross-job depth tracking per research open question #2)

**WorkflowConditionEvaluator.cs:**
- `Evaluate(List&lt;WorkflowConditionGroup&gt; conditionGroups, DomainEvent domainEvent, Dictionary&lt;string, object?&gt; entityData)` — returns bool
- OR logic across groups: `conditionGroups.Any(group => EvaluateGroup(...))`
- AND logic within group: `group.Conditions.All(condition => EvaluateCondition(...))`
- If conditionGroups is empty, return true (no conditions = always pass)
- Operators (matching research pattern):
  - `equals`, `not_equals` — string comparison
  - `gt`, `gte`, `lt`, `lte` — numeric comparison with decimal.TryParse
  - `contains` — string Contains
  - `changed_to` — check ChangedProperties contains field AND value matches (per locked decision)
  - `changed_from_to` — check OldPropertyValues[field] == FromValue AND ChangedProperties[field] == Value (per locked decision: "from" value is optional, so if FromValue is null, only check the "to" value)
  - `is_null`, `is_not_null` — null checks
- `GetFieldValue(string field, Dictionary&lt;string, object?&gt; entityData)` — resolves field from entity data dictionary (supports nested custom fields via dot notation)

**WorkflowExecutionService.cs** (Hangfire job):
- `QueueName = "workflows"` constant
- Constructor injects: `IWorkflowRepository`, `WorkflowConditionEvaluator`, `WorkflowActionExecutor`, `WorkflowLoopGuard`, `ApplicationDbContext`, `ILogger`
- `[AutomaticRetry(Attempts = 2)]` attribute
- `ExecuteAsync(WorkflowTriggerContext context)`:
  1. Set TenantScope for background job tenant context
  2. Set loop guard depth from `context.CurrentDepth` (restore AsyncLocal state across Hangfire boundary)
  3. Increment depth via `_loopGuard.IncrementDepth()` (disposable)
  4. Check `_loopGuard.TryMarkProcessed(context.WorkflowId, context.EntityId)` — skip if already processed
  5. Load workflow by ID from repository. Return if null or not active.
  6. Create WorkflowExecutionLog with trigger info
  7. Deserialize ChangedProperties and OldPropertyValues from JSON strings
  8. Build entity data dictionary by loading the actual entity from DbContext (Contact/Company/Deal/Lead/Activity by EntityId)
  9. Evaluate conditions: call `_conditionEvaluator.Evaluate(workflow.Definition.Conditions, domainEvent, entityData)`. If conditions fail, log as Skipped and return.
  10. Execute actions by traversing the workflow graph:
      - Start from trigger node, follow connections to find ordered action sequence
      - For Branch nodes: evaluate branch condition, follow "yes" or "no" output connection
      - For Wait nodes: schedule remaining actions as a NEW Hangfire delayed job with the configured delay (TimeSpan), passing the continuation context (remaining node IDs, execution log ID, depth)
      - For Action nodes: call `_actionExecutor.ExecuteAsync(action, entityData, context)` and log result
      - Per locked decision: each action has ContinueOnError flag. If false and action fails, halt execution. If true, continue to next action.
  11. Update WorkflowExecutionLog with final status (Succeeded/PartiallyFailed/Failed)
  12. Update workflow.ExecutionCount++ and LastExecutedAt
  13. SaveChangesAsync

**WorkflowActionExecutor.cs:**
- Constructor injects all 6 action implementations via DI
- `ExecuteAsync(WorkflowActionConfig action, Dictionary&lt;string, object?&gt; entityData, WorkflowTriggerContext context)`:
  - Switch on `action.ActionType`:
    - `UpdateField` → `_updateFieldAction.ExecuteAsync(action.Config, entityData, context)`
    - `SendNotification` → `_sendNotificationAction.ExecuteAsync(action.Config, entityData, context)`
    - `CreateActivity` → `_createActivityAction.ExecuteAsync(action.Config, entityData, context)`
    - `SendEmail` → `_sendEmailAction.ExecuteAsync(action.Config, entityData, context)`
    - `FireWebhook` → `_fireWebhookAction.ExecuteAsync(action.Config, entityData, context)`
    - `EnrollInSequence` → `_enrollInSequenceAction.ExecuteAsync(action.Config, entityData, context)`
    - `Branch`, `Wait` — handled by execution service graph traversal, not action executor
    - Default → throw NotSupportedException
  </action>
  <verify>Build `cd src/GlobCRM.Api && dotnet build` succeeds with 0 errors. All 5 files exist in Infrastructure/Workflows/.</verify>
  <done>WorkflowDomainEventHandler matches domain events to cached active workflows and enqueues Hangfire jobs. WorkflowExecutionService evaluates conditions and traverses the workflow graph with branch/wait support. WorkflowConditionEvaluator supports all AND/OR operators including changed_to and changed_from_to. WorkflowLoopGuard enforces depth 5 limit with AsyncLocal + Hangfire parameter passthrough.</done>
</task>

<task type="auto">
  <name>Task 2: Six action implementations, date trigger scan, and DI registration</name>
  <files>
    src/GlobCRM.Infrastructure/Workflows/Actions/UpdateFieldAction.cs
    src/GlobCRM.Infrastructure/Workflows/Actions/SendNotificationAction.cs
    src/GlobCRM.Infrastructure/Workflows/Actions/CreateActivityAction.cs
    src/GlobCRM.Infrastructure/Workflows/Actions/SendEmailAction.cs
    src/GlobCRM.Infrastructure/Workflows/Actions/FireWebhookAction.cs
    src/GlobCRM.Infrastructure/Workflows/Actions/EnrollInSequenceAction.cs
    src/GlobCRM.Infrastructure/Workflows/DateTriggerScanService.cs
    src/GlobCRM.Infrastructure/Workflows/WorkflowServiceExtensions.cs
    src/GlobCRM.Infrastructure/DependencyInjection.cs
  </files>
  <action>
Implement all 6 action types using existing infrastructure and the date trigger scanner. Each action reuses an existing service — Phase 19 is an orchestration layer, not reimplementation.

**UpdateFieldAction.cs:**
- Injects `ApplicationDbContext`
- Reads config: `FieldName`, `Value`, `IsDynamic` (bool), `DynamicSourceField` (string?)
- Per locked decision: supports both static values AND dynamic mapping from trigger entity fields (merge-field-style picker)
- If `IsDynamic`, resolve value from entityData using DynamicSourceField
- Load entity from DbContext by context.EntityType + context.EntityId
- Set property value via reflection (for standard properties) or update CustomFields JSONB (for custom fields)
- SaveChangesAsync — this WILL trigger DomainEventInterceptor, which re-enters WorkflowDomainEventHandler. The loop guard prevents infinite recursion.

**SendNotificationAction.cs:**
- Injects `NotificationDispatcher`, `ApplicationDbContext` (for user/team resolution)
- Reads config: `Title`, `Message`, `RecipientType` ("record_owner", "deal_owner", "specific_user", "team"), `RecipientId` (Guid?)
- Per locked decision: dynamic recipient resolution
- Resolve recipient(s):
  - "record_owner": load entity, get OwnerId/AssignedToUserId property
  - "deal_owner": load related deal, get OwnerId
  - "specific_user": use RecipientId directly
  - "team": load team members by RecipientId (team ID)
- Call `_notificationDispatcher.DispatchAsync()` for each recipient with Title/Message and NotificationType.WorkflowAction (add to NotificationType enum)

**CreateActivityAction.cs:**
- Injects `ApplicationDbContext`
- Reads config: `Subject`, `Type` (ActivityType), `Priority` (ActivityPriority), `DueDateOffsetDays` (int), `AssigneeType` ("record_owner", "deal_owner", "specific_user"), `AssigneeId` (Guid?)
- Per locked decision: dynamic assignment with record owner and deal owner as first-class options
- Resolve assignee using same pattern as SendNotificationAction
- Create Activity entity with:
  - Subject from config (support merge field placeholders like {{contact.name}} by resolving from entityData)
  - DueDate = DateTimeOffset.UtcNow.AddDays(DueDateOffsetDays)
  - AssignedToUserId = resolved assignee
  - Status = ActivityStatus.Open
  - Related entity: set ContactId/CompanyId/DealId/LeadId based on context.EntityType
- SaveChangesAsync

**SendEmailAction.cs:**
- Injects `TemplateRenderService`, `MergeFieldService`, `IEmailService`
- Reads config: `EmailTemplateId` (Guid), `RecipientField` (string, default "email")
- Load email template by ID from DbContext
- Resolve merge data via MergeFieldService for the entity (same as Phase 14 preview endpoint)
- Render template: `_templateRenderService.RenderAsync(template.HtmlBody, mergeData)`
- Render subject: `_templateRenderService.RenderAsync(template.Subject, mergeData)`
- Get recipient email from entityData[RecipientField]
- Send via `_emailService.SendRawEmailAsync(recipientEmail, renderedSubject, renderedHtml)`

**FireWebhookAction.cs:**
- Injects `IHttpClientFactory`, `WebhookSsrfValidator`, `ILogger`
- Reads config: `Url` (string), `Headers` (Dictionary?), `PayloadTemplate` (string?)
- Validate URL via WebhookSsrfValidator (reuse existing SSRF protection)
- Build payload: if PayloadTemplate provided, resolve merge fields from entityData; else serialize entityData as JSON
- Create HTTP POST request with payload and custom headers
- Use named HttpClient "WebhookDelivery" (already registered by WebhookServiceExtensions)
- Log response status. Do NOT retry here — the workflow's ContinueOnError handles failure.

**EnrollInSequenceAction.cs:**
- Injects `ISequenceEnrollmentRepository`, `IEmailSequenceRepository`, `SequenceExecutionService`
- Reads config: `SequenceId` (Guid)
- Requires entity to be a Contact (check context.EntityType == "Contact"). If not, throw InvalidOperationException.
- Check if contact is already enrolled in this sequence (skip if so)
- Create SequenceEnrollment: SequenceId, ContactId = context.EntityId, Status = Active, CurrentStepNumber = 1
- Schedule first step execution via Hangfire (same pattern as manual enrollment in SequencesController)

**DateTriggerScanService.cs:**
- Follows DueDateNotificationService pattern exactly — Hangfire recurring job
- `JobId = "workflow-date-trigger-scan"` constant
- `[AutomaticRetry(Attempts = 1)]` attribute
- `ScanAsync()`:
  1. Load all active workflows with date-based triggers across all tenants (IgnoreQueryFilters, same as DueDateNotificationService)
  2. For each workflow, parse DateBased triggers from definition: FieldName, DateOffsetDays, PreferredTime
  3. Query entities where `dateField + offset` falls within scan window (last hour for hourly scan)
  4. For each matching entity, check WorkflowExecutionLog to prevent duplicate firing (unique per workflow+entity within trigger window)
  5. For new matches: enqueue WorkflowExecutionService job with TriggerType "DateBased"
- Register as recurring job: `RecurringJob.AddOrUpdate&lt;DateTriggerScanService&gt;(JobId, svc => svc.ScanAsync(), Cron.Hourly)`

**WorkflowServiceExtensions.cs:**
- `AddWorkflowServices(this IServiceCollection services)`:
  - `services.AddScoped&lt;IDomainEventHandler, WorkflowDomainEventHandler&gt;()` (registers alongside WebhookDomainEventHandler)
  - `services.AddScoped&lt;WorkflowExecutionService&gt;()`
  - `services.AddScoped&lt;WorkflowConditionEvaluator&gt;()`
  - `services.AddScoped&lt;WorkflowActionExecutor&gt;()`
  - `services.AddScoped&lt;WorkflowLoopGuard&gt;()`
  - `services.AddScoped&lt;UpdateFieldAction&gt;()`
  - `services.AddScoped&lt;SendNotificationAction&gt;()`
  - `services.AddScoped&lt;CreateActivityAction&gt;()`
  - `services.AddScoped&lt;SendEmailAction&gt;()`
  - `services.AddScoped&lt;FireWebhookAction&gt;()`
  - `services.AddScoped&lt;EnrollInSequenceAction&gt;()`
  - `services.AddScoped&lt;DateTriggerScanService&gt;()`
  - `services.AddScoped&lt;IWorkflowRepository, WorkflowRepository&gt;()` (move from DependencyInjection.cs to here)

**DependencyInjection.cs:**
- Remove the `services.AddScoped<IWorkflowRepository, WorkflowRepository>()` line added in 19-01 from `DependencyInjection.cs` — it is now covered by `AddWorkflowServices()` in WorkflowServiceExtensions.cs. This prevents double-registration.
- Add `services.AddWorkflowServices()` call (replaces the removed line and adds all other workflow services)
- Add `NotificationType.WorkflowAction` to NotificationType enum (if not already there)

**Program.cs note:** The recurring job registration for DateTriggerScanService should be added where other recurring jobs are registered (same location as existing DueDateNotification if present, otherwise after app.UseEndpoints).
  </action>
  <verify>Build `cd src/GlobCRM.Api && dotnet build` succeeds with 0 errors. All 6 action files exist in Infrastructure/Workflows/Actions/. DateTriggerScanService.cs, WorkflowServiceExtensions.cs exist.</verify>
  <done>All 6 action types implemented reusing existing infrastructure. DateTriggerScanService scans hourly for date-based trigger matches. WorkflowServiceExtensions registers all services. DomainEventHandler registered alongside WebhookDomainEventHandler. Complete execution pipeline operational: event → handler → Hangfire job → condition eval → graph traversal → action dispatch.</done>
</task>

</tasks>

<verification>
1. `cd src/GlobCRM.Api && dotnet build` — 0 errors
2. WorkflowDomainEventHandler implements IDomainEventHandler and is registered in DI
3. WorkflowExecutionService handles branch nodes (if/else routing) and wait nodes (Hangfire delayed scheduling)
4. WorkflowConditionEvaluator supports all operators including changed_to and changed_from_to
5. WorkflowLoopGuard MaxDepth = 5, depth passes through Hangfire job parameters
6. All 6 action types delegate to existing services (NotificationDispatcher, TemplateRenderService, WebhookSsrfValidator, SequenceExecutionService)
7. DateTriggerScanService registered as hourly recurring Hangfire job
</verification>

<success_criteria>
- Domain events from entity saves trigger workflow matching and execution via Hangfire
- Condition evaluation supports AND/OR grouping with field-change operators
- All 6 action types work: update field, send notification, create activity, send email, fire webhook, enroll in sequence
- Branch nodes route execution based on condition evaluation
- Wait nodes schedule remaining actions via Hangfire delayed jobs
- Loop guard prevents cascading beyond depth 5
- Date triggers fire on hourly scan schedule
</success_criteria>

<output>
After completion, create `.planning/phases/19-workflow-automation/19-02-SUMMARY.md`
</output>
