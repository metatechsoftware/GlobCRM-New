---
phase: 16-duplicate-detection-merge
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/GlobCRM.Domain/Entities/DuplicateMatchingConfig.cs
  - src/GlobCRM.Domain/Entities/MergeAuditLog.cs
  - src/GlobCRM.Domain/Entities/Contact.cs
  - src/GlobCRM.Domain/Entities/Company.cs
  - src/GlobCRM.Domain/Interfaces/IDuplicateDetectionService.cs
  - src/GlobCRM.Infrastructure/Persistence/ApplicationDbContext.cs
  - src/GlobCRM.Infrastructure/Persistence/Configurations/DuplicateMatchingConfigConfiguration.cs
  - src/GlobCRM.Infrastructure/Persistence/Configurations/MergeAuditLogConfiguration.cs
  - src/GlobCRM.Infrastructure/Persistence/Configurations/ContactConfiguration.cs
  - src/GlobCRM.Infrastructure/Persistence/Configurations/CompanyConfiguration.cs
  - src/GlobCRM.Infrastructure/Duplicates/DuplicateDetectionService.cs
  - src/GlobCRM.Infrastructure/Duplicates/ContactMergeService.cs
  - src/GlobCRM.Infrastructure/Duplicates/CompanyMergeService.cs
  - src/GlobCRM.Infrastructure/Duplicates/DuplicateServiceExtensions.cs
  - src/GlobCRM.Infrastructure/GlobCRM.Infrastructure.csproj
  - scripts/rls-setup.sql
autonomous: true
requirements: [DUP-04, DUP-06, DUP-07]

must_haves:
  truths:
    - "DuplicateDetectionService returns scored duplicate matches for contacts using two-tier pg_trgm + FuzzySharp"
    - "DuplicateDetectionService returns scored duplicate matches for companies using two-tier pg_trgm + FuzzySharp"
    - "ContactMergeService transfers all 12 FK/polymorphic references from loser to survivor in a single transaction"
    - "CompanyMergeService transfers all 11 FK/polymorphic references from loser to survivor in a single transaction"
    - "Merged contact/company records have MergedIntoId set and are excluded from list queries via global query filter"
  artifacts:
    - path: "src/GlobCRM.Domain/Entities/DuplicateMatchingConfig.cs"
      provides: "Tenant-scoped matching rules entity"
      contains: "SimilarityThreshold"
    - path: "src/GlobCRM.Domain/Entities/MergeAuditLog.cs"
      provides: "Merge operation audit trail entity"
      contains: "SurvivorId"
    - path: "src/GlobCRM.Infrastructure/Duplicates/DuplicateDetectionService.cs"
      provides: "Two-tier duplicate detection"
      contains: "TrigramsSimilarity"
    - path: "src/GlobCRM.Infrastructure/Duplicates/ContactMergeService.cs"
      provides: "Contact merge with FK transfer"
      contains: "MergedIntoId"
    - path: "src/GlobCRM.Infrastructure/Duplicates/CompanyMergeService.cs"
      provides: "Company merge with FK transfer"
      contains: "MergedIntoId"
  key_links:
    - from: "DuplicateDetectionService"
      to: "ApplicationDbContext"
      via: "EF.Functions.TrigramsSimilarity() + FuzzySharp scoring"
      pattern: "TrigramsSimilarity.*FuzzySharp"
    - from: "ContactMergeService"
      to: "ApplicationDbContext"
      via: "Single transaction with BeginTransactionAsync"
      pattern: "BeginTransactionAsync.*SaveChangesAsync.*CommitAsync"
---

<objective>
Build the complete backend foundation for duplicate detection and merge: domain entities (DuplicateMatchingConfig, MergeAuditLog, MergedIntoId on Contact/Company), pg_trgm extension with GIN trigram indexes, the two-tier DuplicateDetectionService (pg_trgm pre-filter + FuzzySharp scoring), and ContactMergeService/CompanyMergeService with full FK relationship transfer.

Purpose: All backend data layer and service logic must exist before the API controllers (Plan 02) can expose endpoints.
Output: Domain entities, EF configurations, migration, detection service, merge services, DI registration.
</objective>

<execution_context>
@/Users/metatech/.claude/get-shit-done/workflows/execute-plan.md
@/Users/metatech/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/16-duplicate-detection-merge/16-RESEARCH.md
@src/GlobCRM.Domain/Entities/Contact.cs
@src/GlobCRM.Domain/Entities/Company.cs
@src/GlobCRM.Infrastructure/Persistence/ApplicationDbContext.cs
@src/GlobCRM.Infrastructure/Persistence/Configurations/ContactConfiguration.cs
@src/GlobCRM.Infrastructure/Persistence/Configurations/CompanyConfiguration.cs
@src/GlobCRM.Api/Controllers/LeadsController.cs (conversion pattern reference for merge transaction)
</context>

<tasks>

<task type="auto">
  <name>Task 1: Domain entities, EF configurations, pg_trgm extension, and migration</name>
  <files>
    src/GlobCRM.Domain/Entities/DuplicateMatchingConfig.cs
    src/GlobCRM.Domain/Entities/MergeAuditLog.cs
    src/GlobCRM.Domain/Entities/Contact.cs
    src/GlobCRM.Domain/Entities/Company.cs
    src/GlobCRM.Infrastructure/Persistence/ApplicationDbContext.cs
    src/GlobCRM.Infrastructure/Persistence/Configurations/DuplicateMatchingConfigConfiguration.cs
    src/GlobCRM.Infrastructure/Persistence/Configurations/MergeAuditLogConfiguration.cs
    src/GlobCRM.Infrastructure/Persistence/Configurations/ContactConfiguration.cs
    src/GlobCRM.Infrastructure/Persistence/Configurations/CompanyConfiguration.cs
    scripts/rls-setup.sql
  </files>
  <action>
    1. **Create DuplicateMatchingConfig entity** (src/GlobCRM.Domain/Entities/DuplicateMatchingConfig.cs):
       - Properties: Id (Guid), TenantId (Guid), EntityType (string — "Contact" or "Company"), AutoDetectionEnabled (bool, default true), SimilarityThreshold (int, default 70), MatchingFields (List of string, JSONB), CreatedAt, UpdatedAt
       - Follow existing entity patterns (see CustomFieldDefinition for JSONB List pattern)

    2. **Create MergeAuditLog entity** (src/GlobCRM.Domain/Entities/MergeAuditLog.cs):
       - Properties: Id (Guid), TenantId (Guid), EntityType (string), SurvivorId (Guid), LoserId (Guid), MergedByUserId (Guid), FieldSelections (Dictionary of string to object?, JSONB), TransferCounts (Dictionary of string to int, JSONB), MergedAt (DateTimeOffset)
       - Navigation: MergedByUser (ApplicationUser)

    3. **Add merge fields to Contact entity** (modify Contact.cs):
       - Add nullable MergedIntoId (Guid?), MergedAt (DateTimeOffset?), MergedByUserId (Guid?)
       - These enable soft-delete with redirect on merged records

    4. **Add merge fields to Company entity** (modify Company.cs):
       - Same three properties as Contact: MergedIntoId, MergedAt, MergedByUserId

    5. **Create EF configurations**:
       - DuplicateMatchingConfigConfiguration: Table "duplicate_matching_configs", snake_case columns, TenantId required, JSONB for MatchingFields, unique constraint on (TenantId, EntityType)
       - MergeAuditLogConfiguration: Table "merge_audit_logs", snake_case columns, TenantId required, JSONB for FieldSelections and TransferCounts, FK to ApplicationUser for MergedByUserId

    6. **Modify ContactConfiguration**: Add column mappings for merged_into_id, merged_at, merged_by_user_id. Add index on merged_into_id.

    7. **Modify CompanyConfiguration**: Same column mappings and index as Contact.

    8. **Update ApplicationDbContext**:
       - Add DbSet for DuplicateMatchingConfig and MergeAuditLog
       - Add `modelBuilder.HasPostgresExtension("pg_trgm")` in OnModelCreating
       - Add global query filter for DuplicateMatchingConfig (TenantId)
       - Add global query filter for MergeAuditLog (TenantId)
       - Update existing Contact query filter to also exclude merged records: `.HasQueryFilter(c => c.TenantId == tenantId && c.MergedIntoId == null)`
       - Update existing Company query filter to also exclude merged records: `.HasQueryFilter(c => c.TenantId == tenantId && c.MergedIntoId == null)`

    9. **Generate EF migration** (run from src/GlobCRM.Api):
       `dotnet ef migrations add AddDuplicateDetection --context ApplicationDbContext --output-dir Persistence/Migrations/App --project ../GlobCRM.Infrastructure`
       After generation, manually add raw SQL in the Up() method for trigram GIN indexes:
       - `CREATE INDEX idx_contacts_name_trgm ON contacts USING gin ((first_name || ' ' || last_name) gin_trgm_ops);`
       - `CREATE INDEX idx_contacts_email_trgm ON contacts USING gin (email gin_trgm_ops);`
       - `CREATE INDEX idx_companies_name_trgm ON companies USING gin (name gin_trgm_ops);`
       - `CREATE INDEX idx_companies_website_trgm ON companies USING gin (website gin_trgm_ops);`
       Add corresponding DROP INDEX statements in Down().

    10. **Update RLS script** (scripts/rls-setup.sql): Add RLS policies for duplicate_matching_configs and merge_audit_logs tables following existing pattern.

    11. **Apply migration**: `dotnet ef database update --context ApplicationDbContext --project ../GlobCRM.Infrastructure`
  </action>
  <verify>
    `cd src/GlobCRM.Api && dotnet build` succeeds with 0 errors.
    Migration applied successfully. Database has pg_trgm extension, new tables, and trigram GIN indexes.
    Query `SELECT * FROM pg_indexes WHERE indexname LIKE 'idx_%_trgm';` returns 4 rows.
  </verify>
  <done>
    DuplicateMatchingConfig and MergeAuditLog entities exist with EF configurations. Contact and Company have MergedIntoId, MergedAt, MergedByUserId columns. pg_trgm extension enabled with GIN trigram indexes on contacts (name, email) and companies (name, website). Global query filters exclude merged records from list queries. RLS policies protect new tables.
  </done>
</task>

<task type="auto">
  <name>Task 2: DuplicateDetectionService, ContactMergeService, CompanyMergeService, and DI registration</name>
  <files>
    src/GlobCRM.Domain/Interfaces/IDuplicateDetectionService.cs
    src/GlobCRM.Infrastructure/Duplicates/DuplicateDetectionService.cs
    src/GlobCRM.Infrastructure/Duplicates/ContactMergeService.cs
    src/GlobCRM.Infrastructure/Duplicates/CompanyMergeService.cs
    src/GlobCRM.Infrastructure/Duplicates/DuplicateServiceExtensions.cs
    src/GlobCRM.Infrastructure/GlobCRM.Infrastructure.csproj
  </files>
  <action>
    1. **Install FuzzySharp**: Add `<PackageReference Include="FuzzySharp" Version="2.0.2" />` to GlobCRM.Infrastructure.csproj.

    2. **Create IDuplicateDetectionService interface** (src/GlobCRM.Domain/Interfaces/IDuplicateDetectionService.cs):
       ```
       public interface IDuplicateDetectionService
       {
           Task<List<DuplicateMatch>> FindContactDuplicatesAsync(string? firstName, string? lastName, string? email, int threshold, Guid? excludeId = null);
           Task<List<DuplicateMatch>> FindCompanyDuplicatesAsync(string? name, string? website, int threshold, Guid? excludeId = null);
           Task<List<DuplicatePair>> ScanContactDuplicatesAsync(int threshold, int page, int pageSize);
           Task<List<DuplicatePair>> ScanCompanyDuplicatesAsync(int threshold, int page, int pageSize);
       }
       ```
       Also define DuplicateMatch record (EntityId, FullName, Email, Score, UpdatedAt) and DuplicatePair record (RecordA, RecordB, Score) in the same file or a separate models file in Domain.

    3. **Create DuplicateDetectionService** (src/GlobCRM.Infrastructure/Duplicates/DuplicateDetectionService.cs):
       - Inject ApplicationDbContext
       - **FindContactDuplicatesAsync**: Two-tier approach per research:
         * Tier 1: pg_trgm query using `EF.Functions.TrigramsSimilarity(c.FirstName + " " + c.LastName, fullName) > dbThreshold` where dbThreshold is threshold/100.0 * 0.5 (lower than final to be inclusive). Also match on email if provided. Select top 50 candidates with Id, FirstName, LastName, Email, Phone, CompanyName, UpdatedAt.
         * Tier 2: FuzzySharp scoring — Name weight 50% using `Fuzz.TokenSortRatio`, Email weight 50% using `Fuzz.Ratio` (case-insensitive). If email is null on either side, name gets 100%. Filter by configuredThreshold, sort descending, take top 10.
       - **FindCompanyDuplicatesAsync**: Similar two-tier:
         * Tier 1: `EF.Functions.TrigramsSimilarity(c.Name, name) > dbThreshold`. Also match website/domain if provided.
         * Tier 2: Company name weight 60%, Domain weight 40%. Extract domain from Website URL by stripping protocol and path. Use `Fuzz.TokenSortRatio` for name, `Fuzz.Ratio` for domain.
       - **ScanContactDuplicatesAsync**: Batch mode for on-demand scan. Load contacts in batches, compare each against subsequent records using pg_trgm pre-filter. Return paginated DuplicatePair results sorted by score descending.
       - **ScanCompanyDuplicatesAsync**: Same pattern for companies.
       - Handle edge cases: null/empty fields gracefully (skip that field's weight and redistribute).

    4. **Create ContactMergeService** (src/GlobCRM.Infrastructure/Duplicates/ContactMergeService.cs):
       - Inject ApplicationDbContext
       - Method: `MergeAsync(Guid survivorId, Guid loserId, Dictionary<string, object?> fieldSelections, Guid mergedByUserId)`
       - Execute in single transaction (BeginTransactionAsync/CommitAsync pattern from Lead conversion):
         a. Load survivor and loser contacts (use IgnoreQueryFilters to handle edge cases)
         b. Apply field selections to survivor (iterate fieldSelections dictionary, set matching properties via reflection or explicit property map)
         c. Transfer all 12 FK/polymorphic references per the FK Reference Map in RESEARCH.md:
            - DealContacts: Check for conflicts (same DealId), delete conflicting loser links, update rest to survivorId
            - Quotes: UPDATE ContactId = survivorId WHERE ContactId = loserId
            - Requests: UPDATE ContactId = survivorId WHERE ContactId = loserId
            - EmailMessages: UPDATE LinkedContactId = survivorId WHERE LinkedContactId = loserId
            - EmailThreads: UPDATE LinkedContactId = survivorId WHERE LinkedContactId = loserId
            - Leads (converted_contact_id): UPDATE ConvertedContactId = survivorId WHERE ConvertedContactId = loserId
            - LeadConversions: UPDATE ContactId = survivorId WHERE ContactId = loserId
            - Notes (polymorphic): UPDATE EntityId = survivorId WHERE EntityType = "Contact" AND EntityId = loserId
            - Attachments (polymorphic): Same pattern
            - ActivityLinks (polymorphic): Check for conflicts (same ActivityId), delete conflicting, update rest
            - FeedItems (polymorphic): UPDATE EntityId = survivorId
            - Notifications (polymorphic): UPDATE EntityId = survivorId
         d. Set loser: MergedIntoId = survivorId, MergedAt = now, MergedByUserId = userId
         e. Create MergeAuditLog with FieldSelections, TransferCounts (counts of each transferred entity type)
         f. SaveChangesAsync, CommitAsync
       - Return the transfer counts dictionary for the confirmation response

    5. **Create CompanyMergeService** (src/GlobCRM.Infrastructure/Duplicates/CompanyMergeService.cs):
       - Same pattern as ContactMergeService but for Company FK references per RESEARCH.md:
         - Contacts: UPDATE CompanyId = survivorId WHERE CompanyId = loserId
         - Deals: UPDATE CompanyId = survivorId WHERE CompanyId = loserId
         - Quotes: UPDATE CompanyId = survivorId WHERE CompanyId = loserId
         - Requests: UPDATE CompanyId = survivorId WHERE CompanyId = loserId
         - EmailMessages: UPDATE LinkedCompanyId = survivorId WHERE LinkedCompanyId = loserId
         - EmailThreads: UPDATE LinkedCompanyId = survivorId WHERE LinkedCompanyId = loserId
         - Leads (converted_company_id): UPDATE ConvertedCompanyId = survivorId WHERE ConvertedCompanyId = loserId
         - LeadConversions: UPDATE CompanyId = survivorId WHERE CompanyId = loserId
         - Notes, Attachments, ActivityLinks, FeedItems, Notifications (all polymorphic with EntityType = "Company")

    6. **Create DuplicateServiceExtensions** (src/GlobCRM.Infrastructure/Duplicates/DuplicateServiceExtensions.cs):
       - `AddDuplicateServices(this IServiceCollection services)` registering DuplicateDetectionService as scoped, ContactMergeService as scoped, CompanyMergeService as scoped
       - Call from main DependencyInjection.cs / AddInfrastructure

    7. **Register in DI**: Add `services.AddDuplicateServices()` call in the Infrastructure DependencyInjection.cs AddInfrastructure method.
  </action>
  <verify>
    `cd src/GlobCRM.Api && dotnet build` succeeds with 0 errors.
    FuzzySharp package is in the project file.
    DuplicateDetectionService, ContactMergeService, CompanyMergeService are registered in DI container.
  </verify>
  <done>
    Two-tier DuplicateDetectionService uses pg_trgm for database pre-filtering and FuzzySharp for weighted in-memory scoring. ContactMergeService transfers all 12 Contact FK/polymorphic references in a single transaction. CompanyMergeService transfers all 11 Company FK/polymorphic references in a single transaction. Both merge services create MergeAuditLog entries and set MergedIntoId on the loser record. All services registered in DI.
  </done>
</task>

</tasks>

<verification>
1. `cd src/GlobCRM.Api && dotnet build` — 0 errors
2. Database has pg_trgm extension: `SELECT * FROM pg_extension WHERE extname = 'pg_trgm';` returns 1 row
3. Trigram indexes exist: `SELECT indexname FROM pg_indexes WHERE indexname LIKE 'idx_%_trgm';` returns 4 rows
4. New tables exist: duplicate_matching_configs, merge_audit_logs
5. Contact and Company tables have merged_into_id, merged_at, merged_by_user_id columns
6. FuzzySharp 2.0.2 is in GlobCRM.Infrastructure.csproj
</verification>

<success_criteria>
- DuplicateDetectionService resolves from DI and has both contact and company duplicate detection methods
- ContactMergeService and CompanyMergeService resolve from DI with full FK reference transfer
- pg_trgm extension and GIN indexes are applied to the database
- Contact and Company entities have MergedIntoId field with global query filter excluding merged records
- MergeAuditLog preserves complete audit trail of merge operations
- Build passes with 0 errors
</success_criteria>

<output>
After completion, create `.planning/phases/16-duplicate-detection-merge/16-01-SUMMARY.md`
</output>
