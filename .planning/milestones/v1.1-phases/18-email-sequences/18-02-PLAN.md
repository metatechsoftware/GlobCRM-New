---
phase: 18-email-sequences
plan: 02
type: execute
wave: 2
depends_on: [18-01]
files_modified:
  - src/GlobCRM.Infrastructure/Sequences/SequenceExecutionService.cs
  - src/GlobCRM.Infrastructure/Sequences/SequenceEmailSender.cs
  - src/GlobCRM.Infrastructure/Sequences/EmailTrackingService.cs
  - src/GlobCRM.Infrastructure/Sequences/SequenceReplyDetector.cs
  - src/GlobCRM.Infrastructure/Sequences/SequenceServiceExtensions.cs
  - src/GlobCRM.Api/Controllers/TrackingController.cs
  - src/GlobCRM.Infrastructure/Gmail/GmailSyncService.cs
  - src/GlobCRM.Domain/Enums/NotificationType.cs
  - src/GlobCRM.Infrastructure/DependencyInjection.cs
autonomous: true
requirements: [ESEQ-04, ESEQ-05]

must_haves:
  truths:
    - "Sequence execution service advances enrollments through steps via Hangfire scheduled jobs with proper delay calculation"
    - "Outbound sequence emails contain custom X-Sequence-Id, X-Sequence-Step-Id, X-Enrollment-Id headers for reply detection"
    - "Outbound sequence emails include tracking pixel and rewritten links for open/click tracking"
    - "Tracking pixel endpoint returns a 1x1 transparent GIF and records open events without authentication"
    - "Link click endpoint records click events and redirects to the original URL without authentication"
    - "GmailSyncService detects replies to sequence emails and auto-unenrolls contacts with notification"
    - "Paused/completed/unenrolled enrollments are skipped when their scheduled step job executes"
  artifacts:
    - path: "src/GlobCRM.Infrastructure/Sequences/SequenceExecutionService.cs"
      provides: "Hangfire job service that executes a sequence step: renders template, injects tracking, sends email, schedules next step"
      contains: "class SequenceExecutionService"
    - path: "src/GlobCRM.Infrastructure/Sequences/SequenceEmailSender.cs"
      provides: "Sends sequence emails via Gmail/SendGrid with custom MIME headers for reply detection"
      contains: "class SequenceEmailSender"
    - path: "src/GlobCRM.Infrastructure/Sequences/EmailTrackingService.cs"
      provides: "Tracking pixel injection, link URL rewriting, and base64url token encode/decode"
      contains: "class EmailTrackingService"
    - path: "src/GlobCRM.Infrastructure/Sequences/SequenceReplyDetector.cs"
      provides: "Checks inbound emails for sequence reply headers and auto-unenrolls with notification"
      contains: "class SequenceReplyDetector"
    - path: "src/GlobCRM.Api/Controllers/TrackingController.cs"
      provides: "Unauthenticated endpoints for open pixel and click redirect"
      contains: "class TrackingController"
  key_links:
    - from: "src/GlobCRM.Infrastructure/Sequences/SequenceExecutionService.cs"
      to: "src/GlobCRM.Infrastructure/Sequences/SequenceEmailSender.cs"
      via: "Calls SendSequenceEmailAsync after rendering template"
      pattern: "SendSequenceEmailAsync"
    - from: "src/GlobCRM.Infrastructure/Sequences/SequenceExecutionService.cs"
      to: "Hangfire IBackgroundJobClient"
      via: "Schedules next step job with computed delay"
      pattern: "_jobClient.Schedule"
    - from: "src/GlobCRM.Infrastructure/Gmail/GmailSyncService.cs"
      to: "src/GlobCRM.Infrastructure/Sequences/SequenceReplyDetector.cs"
      via: "Calls CheckForSequenceReplyAsync after syncing inbound message"
      pattern: "CheckForSequenceReplyAsync"
    - from: "src/GlobCRM.Api/Controllers/TrackingController.cs"
      to: "src/GlobCRM.Infrastructure/Sequences/EmailTrackingService.cs"
      via: "Calls RecordOpenAsync/RecordClickAsync on tracking events"
      pattern: "RecordOpenAsync|RecordClickAsync"
---

<objective>
Build the sequence execution engine (Hangfire job service), email sending with tracking injection and custom headers, unauthenticated tracking endpoints, and reply detection hook in GmailSyncService.

Purpose: This is the core automation machinery — the engine that actually sends sequence emails on schedule, tracks opens/clicks, and detects replies for auto-unenrollment.
Output: Execution service, email sender, tracking service, reply detector, tracking controller, and GmailSyncService integration.
</objective>

<execution_context>
@/Users/metatech/.claude/get-shit-done/workflows/execute-plan.md
@/Users/metatech/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/18-email-sequences/18-RESEARCH.md
@.planning/phases/18-email-sequences/18-01-SUMMARY.md
@.planning/phases/14-foundation-infrastructure-email-templates/14-01-SUMMARY.md
@.planning/phases/17-webhooks/17-02-SUMMARY.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Sequence execution engine, email sender, and tracking service</name>
  <files>
    src/GlobCRM.Infrastructure/Sequences/SequenceExecutionService.cs
    src/GlobCRM.Infrastructure/Sequences/SequenceEmailSender.cs
    src/GlobCRM.Infrastructure/Sequences/EmailTrackingService.cs
  </files>
  <action>
    Follow the WebhookDeliveryService pattern from Phase 17 for Hangfire job structure.

    **SequenceExecutionService.cs** — Hangfire job class on "emails" queue:
    - Method: `ExecuteStepAsync(Guid enrollmentId, int stepNumber, Guid tenantId)` with `[Queue("emails")]` and `[AutomaticRetry(Attempts = 3)]` attributes.
    - At start: `TenantScope.SetCurrentTenant(tenantId)` for tenant context.
    - Load enrollment via repository. **Critical guard:** If enrollment is null OR status != EnrollmentStatus.Active, return silently (handles pause/unenroll race condition per research pitfall 2).
    - Load step via `_sequenceRepository.GetStepAsync(enrollment.SequenceId, stepNumber)`. If null, return.
    - Load contact with Company include. If contact email is null, skip.
    - Resolve merge data via `_mergeFieldService.ResolveEntityDataAsync("contact", enrollment.ContactId)`.
    - Load template via repository. If null (template deleted), log warning and skip step, schedule next step anyway.
    - Render HTML body and subject (use step.SubjectOverride ?? template.Subject ?? "No Subject") via `_renderService.RenderAsync` with merge data.
    - Inject tracking via `_trackingService.InjectTracking(renderedHtml, enrollment.Id, stepNumber)`.
    - Send via `_emailSender.SendSequenceEmailAsync(...)`.
    - Update enrollment: CurrentStepNumber = stepNumber, LastStepSentAt = now, StepsSent++.
    - Check for next step. If exists: compute delay via `CalculateDelay(nextStep.DelayDays, nextStep.PreferredSendTime)`, schedule next job via `_jobClient.Schedule<SequenceExecutionService>(...)`, store the returned job ID on enrollment.HangfireJobId.
    - If no next step: set enrollment.Status = Completed, enrollment.CompletedAt = now.
    - Save enrollment update.
    - `CalculateDelay` method: If DelayDays == 0 and step is first, return TimeSpan.Zero. Otherwise compute target DateTime as now + DelayDays. If PreferredSendTime is set, adjust target to that time of day (using UTC for v1 simplicity per research open question 2). If target is in the past (same day, time already passed), add 1 day. Return target - now as TimeSpan.

    **SequenceEmailSender.cs** — Sends emails with custom MIME headers:
    - Inject dependencies: ApplicationDbContext (for email account lookup), GmailServiceFactory or IGmailSendService (check existing pattern), IEmailService (SendGrid fallback), ILogger.
    - Method: `SendSequenceEmailAsync(string toEmail, string subject, string htmlBody, Guid enrollmentId, int stepNumber, Guid sequenceId)` returning the GmailMessageId (string?) for tracking event storage.
    - Try to get the sequence creator's connected Gmail account. If available, construct MimeMessage via MimeKit:
      - Set From, To, Subject, Body (TextPart "html").
      - **Critical per locked decision:** Add custom headers: `mimeMessage.Headers.Add("X-Sequence-Id", sequenceId.ToString())`, same for X-Sequence-Step-Id (stepNumber.ToString()) and X-Enrollment-Id (enrollmentId.ToString()).
      - Send via Gmail API (follow GmailSendService.SendAsync pattern).
      - Return the Gmail message ID and thread ID. Create a "sent" SequenceTrackingEvent with GmailMessageId and GmailThreadId.
    - If no Gmail account: fall back to SendGrid via `_emailService.SendRawEmailAsync(toEmail, subject, htmlBody)`. Custom headers are not possible via SendGrid basic API, so reply detection won't work for SendGrid-sent emails. Return null for GmailMessageId. Still create "sent" tracking event.

    **EmailTrackingService.cs** — Tracking pixel injection, link wrapping, and event recording:
    - Constructor: inject IConfiguration (for base URL), ApplicationDbContext or SequenceTrackingEvent repository.
    - `InjectTracking(string html, Guid enrollmentId, int stepNumber)` method:
      - Generate token via `EncodeToken(enrollmentId, stepNumber)`.
      - Tracking pixel: Append `<img src="{baseUrl}/api/t/o/{token}" width="1" height="1" style="display:none" alt="" />` before `</body>` tag. If no `</body>`, append at end.
      - Link wrapping: Use regex to find all `href="(https?://[^"]+)"` in `<a>` tags. Replace with `href="{baseUrl}/api/t/c/{token}?u={urlEncoded}"`. Skip mailto: and tel: links.
      - Return modified HTML.
    - `EncodeToken(Guid enrollmentId, int stepNumber)` — Base64url of `{enrollmentId}:{stepNumber}` (per research: not crypto-secure, tracking is best-effort).
    - `DecodeToken(string token)` — Reverse of EncodeToken, returns (Guid enrollmentId, int stepNumber).
    - `RecordOpenAsync(Guid enrollmentId, int stepNumber, string? userAgent, string? ipAddress)` — Create SequenceTrackingEvent with EventType "open", save. Deduplicate: only create if no "open" event exists for same enrollment+step (unique opens only).
    - `RecordClickAsync(Guid enrollmentId, int stepNumber, string url, string? userAgent, string? ipAddress)` — Create SequenceTrackingEvent with EventType "click", include Url. Allow multiple clicks (no dedup — each click is valuable).
  </action>
  <verify>
    `cd src/GlobCRM.Api && dotnet build` succeeds with 0 errors. All 3 files exist in src/GlobCRM.Infrastructure/Sequences/.
  </verify>
  <done>
    SequenceExecutionService advances enrollments through steps via Hangfire with delay calculation. SequenceEmailSender sends via Gmail with custom headers or falls back to SendGrid. EmailTrackingService injects tracking pixel and wraps links, records open/click events.
  </done>
</task>

<task type="auto">
  <name>Task 2: Tracking controller, reply detector, and DI registration</name>
  <files>
    src/GlobCRM.Api/Controllers/TrackingController.cs
    src/GlobCRM.Infrastructure/Sequences/SequenceReplyDetector.cs
    src/GlobCRM.Infrastructure/Sequences/SequenceServiceExtensions.cs
    src/GlobCRM.Infrastructure/Gmail/GmailSyncService.cs
    src/GlobCRM.Domain/Enums/NotificationType.cs
    src/GlobCRM.Infrastructure/DependencyInjection.cs
  </files>
  <action>
    **TrackingController.cs** — Unauthenticated tracking endpoints (email clients don't send auth tokens):
    - Route: `[Route("api/t")]`, `[ApiController]`. Do NOT add `[Authorize]` attribute.
    - Static field: `private static readonly byte[] TransparentPixel = Convert.FromBase64String("R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7");` (1x1 transparent GIF, 43 bytes).
    - `[HttpGet("o/{token}")]` TrackOpen: Decode token, call `_trackingService.RecordOpenAsync(enrollmentId, stepNumber, Request.Headers.UserAgent, HttpContext.Connection.RemoteIpAddress?.ToString())`. Return `File(TransparentPixel, "image/gif")` with `[ResponseCache(NoStore = true)]`.
    - `[HttpGet("c/{token}")]` TrackClick: Decode token, decode `u` query parameter via `Uri.UnescapeDataString`, call `_trackingService.RecordClickAsync(enrollmentId, stepNumber, decodedUrl, ...)`. Return `Redirect(decodedUrl)`.
    - Wrap both endpoints in try/catch — tracking failures should NEVER affect email rendering. On error, return pixel/redirect anyway.
    - Add basic validation: if token decode fails, return pixel/redirect without recording (graceful degradation).

    **SequenceReplyDetector.cs** — Reply detection hook for GmailSyncService:
    - Method: `CheckForSequenceReplyAsync(EmailMessage inboundMessage)`.
    - Guard: if `!inboundMessage.IsInbound`, return.
    - Strategy per research: Check if this message's GmailThreadId matches a sent sequence email's GmailThreadId in SequenceTrackingEvent table. Query: `_db.SequenceTrackingEvents.Where(e => e.GmailThreadId == inboundMessage.GmailThreadId && e.EventType == "sent").OrderByDescending(e => e.CreatedAt).FirstOrDefaultAsync()`.
    - If no match, return. If match found, load enrollment.
    - Guard: if enrollment is null or enrollment.Status != EnrollmentStatus.Active, return.
    - Auto-unenroll per locked decision: Set enrollment.Status = EnrollmentStatus.Replied, enrollment.RepliedAt = now, enrollment.ReplyStepNumber = sequenceEmail.StepNumber.
    - If enrollment.HangfireJobId is not null, attempt `BackgroundJob.Delete(enrollment.HangfireJobId)` to cancel pending next step (per research recommendation, defense-in-depth).
    - Save enrollment.
    - Dispatch notification per locked decision: "John Smith replied to Step {N} of {SequenceName} and was unenrolled". Use NotificationDispatcher.DispatchAsync with try/catch (failures don't fail the reply detection).
    - Load sequence name and contact name for the notification message.

    **NotificationType.cs** — Add `SequenceReply` value to the enum.

    **GmailSyncService.cs** — Add reply detection hook:
    - Find the method that processes synced inbound messages (likely SyncSingleMessageAsync or similar).
    - After the message entity is created/saved, add: `await _replyDetector.CheckForSequenceReplyAsync(emailMessage);` wrapped in try/catch (reply detection failures must not break email sync).
    - Inject SequenceReplyDetector via constructor DI.

    **SequenceServiceExtensions.cs** — DI registration:
    - `AddSequenceServices(this IServiceCollection services)` method.
    - Register: SequenceExecutionService (scoped), SequenceEmailSender (scoped), EmailTrackingService (scoped), SequenceReplyDetector (scoped).
    - Register repositories from 18-01: EmailSequenceRepository, SequenceEnrollmentRepository (if not already registered).

    **DependencyInjection.cs** — Add `services.AddSequenceServices()` call in the AddInfrastructure method.
  </action>
  <verify>
    `cd src/GlobCRM.Api && dotnet build` succeeds with 0 errors. TrackingController, SequenceReplyDetector, and SequenceServiceExtensions exist. GmailSyncService has the reply detection hook.
  </verify>
  <done>
    TrackingController serves open pixel and click redirects without authentication. SequenceReplyDetector auto-unenrolls contacts on reply with in-app notification. GmailSyncService calls reply detector on inbound messages. All sequence services registered in DI.
  </done>
</task>

</tasks>

<verification>
1. `cd src/GlobCRM.Api && dotnet build` — 0 errors
2. TrackingController has no [Authorize] attribute and returns transparent GIF for open tracking
3. SequenceExecutionService checks enrollment.Status == Active before executing
4. SequenceEmailSender adds X-Sequence-Id, X-Sequence-Step-Id, X-Enrollment-Id custom headers
5. EmailTrackingService injects tracking pixel before &lt;/body&gt; and wraps href links
6. SequenceReplyDetector called from GmailSyncService with try/catch
7. All services registered via AddSequenceServices() in DependencyInjection.cs
</verification>

<success_criteria>
- Execution engine can schedule and execute sequence steps via Hangfire
- Outbound emails include custom MIME headers and tracking pixel/links
- Tracking endpoints record events without requiring authentication
- Reply detection auto-unenrolls contacts with notification
- All defensive guards in place (status checks, null checks, try/catch)
- Full solution builds with 0 errors
</success_criteria>

<output>
After completion, create `.planning/phases/18-email-sequences/18-02-SUMMARY.md`
</output>
