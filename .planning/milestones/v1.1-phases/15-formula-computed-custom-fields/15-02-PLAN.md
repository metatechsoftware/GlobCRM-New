---
phase: 15-formula-computed-custom-fields
plan: 02
type: execute
wave: 2
depends_on: ["15-01"]
files_modified:
  - src/GlobCRM.Api/Controllers/CustomFieldsController.cs
  - src/GlobCRM.Api/Controllers/DealsController.cs
  - src/GlobCRM.Api/Controllers/ContactsController.cs
  - src/GlobCRM.Api/Controllers/CompaniesController.cs
  - src/GlobCRM.Api/Controllers/LeadsController.cs
  - src/GlobCRM.Api/Controllers/ActivitiesController.cs
  - src/GlobCRM.Api/Controllers/QuotesController.cs
  - src/GlobCRM.Api/Controllers/RequestsController.cs
  - src/GlobCRM.Api/Controllers/ProductsController.cs
autonomous: true
requirements:
  - FORM-04
  - FORM-05

must_haves:
  truths:
    - "API endpoint validates formula expressions and returns syntax/field ref/circular dep errors"
    - "API endpoint previews formula result with sample or real entity data"
    - "API endpoint returns available fields (system + custom + formula) grouped by category for autocomplete"
    - "All entity list and detail API responses include computed formula field values in the customFields dictionary"
    - "Formula errors appear as __formulaError objects in the API response (not exceptions)"
    - "Formula-aware create/update on CustomFieldsController validates formulas and stores DependsOnFieldIds"
  artifacts:
    - path: "src/GlobCRM.Api/Controllers/CustomFieldsController.cs"
      provides: "validate-formula, preview-formula, field-registry endpoints, formula-aware create/update"
      contains: "validate-formula"
    - path: "src/GlobCRM.Api/Controllers/DealsController.cs"
      provides: "Formula evaluation injected into Deal DTO mapping"
      contains: "FormulaEvaluationService"
  key_links:
    - from: "src/GlobCRM.Api/Controllers/CustomFieldsController.cs"
      to: "src/GlobCRM.Infrastructure/FormulaFields/FormulaValidationService.cs"
      via: "validate-formula endpoint calls ValidateAsync"
      pattern: "FormulaValidationService"
    - from: "src/GlobCRM.Api/Controllers/DealsController.cs"
      to: "src/GlobCRM.Infrastructure/FormulaFields/FormulaEvaluationService.cs"
      via: "DTO mapping calls EvaluateFormulasForEntity"
      pattern: "EvaluateFormulasForEntity"
---

<objective>
Wire formula services into the API layer: add formula validation/preview/field-registry endpoints to CustomFieldsController, make Create/Update formula-aware (validate + store DependsOnFieldIds), and inject formula evaluation into every entity controller's DTO mapping so formula field values appear in API responses.

Purpose: Connects the formula engine (from Plan 01) to the REST API, making formula fields usable end-to-end on the backend. Every entity list/detail response will now include computed formula values.
Output: Three new API endpoints on CustomFieldsController, formula-aware CRUD, formula evaluation in all entity DTO responses.
</objective>

<execution_context>
@/Users/metatech/.claude/get-shit-done/workflows/execute-plan.md
@/Users/metatech/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/15-formula-computed-custom-fields/15-RESEARCH.md
@.planning/phases/15-formula-computed-custom-fields/15-CONTEXT.md
@.planning/phases/15-formula-computed-custom-fields/15-01-SUMMARY.md
@src/GlobCRM.Api/Controllers/CustomFieldsController.cs
@src/GlobCRM.Api/Controllers/DealsController.cs
@src/GlobCRM.Api/Controllers/ContactsController.cs
@src/GlobCRM.Api/Controllers/CompaniesController.cs
@src/GlobCRM.Api/Controllers/LeadsController.cs
</context>

<tasks>

<task type="auto">
  <name>Task 1: CustomFieldsController formula endpoints and formula-aware CRUD</name>
  <files>
    src/GlobCRM.Api/Controllers/CustomFieldsController.cs
  </files>
  <action>
    Add three new endpoints and update existing CRUD to be formula-aware:

    **1. POST /api/custom-fields/validate-formula** — Formula validation endpoint:
    - Request body: `ValidateFormulaRequest { EntityType, Expression, ExcludeFieldId? }`
    - Inject `FormulaValidationService` into controller constructor.
    - Call `_formulaValidationService.ValidateAsync(request.EntityType, request.Expression, request.ExcludeFieldId)`.
    - Return `{ valid: true/false, errors: string[] }`.
    - `[Authorize(Roles = "Admin")]` (already on controller).

    **2. POST /api/custom-fields/preview-formula** — Formula preview endpoint:
    - Request body: `PreviewFormulaRequest { EntityType, Expression, SampleEntityId? }`
    - Call `_formulaValidationService.PreviewAsync(request.EntityType, request.Expression, request.SampleEntityId)`.
    - Return `{ value: object?, error: string? }`.
    - `[Authorize(Roles = "Admin")]`.

    **3. GET /api/custom-fields/field-registry/{entityType}** — Available fields for autocomplete:
    - Inject `FieldRegistryService` and `ICustomFieldRepository` into controller.
    - Load custom fields: `var customFields = await _repository.GetFieldsByEntityTypeAsync(entityType)`.
    - Call `_fieldRegistry.GetAvailableFields(entityType, customFields)`.
    - Return the list of `FieldInfo` records directly.
    - Important: This endpoint needs `[AllowAnonymous]` removed — keep it Admin-only since it's for formula editing.

    **4. Update Create action** to be formula-aware:
    - After creating the entity, if `FieldType == Formula`:
      - Run formula validation via `FormulaValidationService.ValidateAsync()`. If errors, return 400 with validation errors.
      - Extract `DependsOnFieldIds` from validation (the referenced parameter names) and store them on the entity before save.
    - Map `FormulaExpression` and `FormulaResultType` from request to entity (if not already done in Plan 01 Task 1).

    **5. Update Update action** to handle formula field updates:
    - If the field is a Formula type and the request includes a new `FormulaExpression`:
      - Re-validate the formula expression.
      - Update `DependsOnFieldIds` from the new expression's parameter names.
      - Update `FormulaExpression` and optionally `FormulaResultType`.

    **6. Add request DTOs:**
    - `ValidateFormulaRequest { EntityType, Expression, ExcludeFieldId? }`
    - `PreviewFormulaRequest { EntityType, Expression, SampleEntityId? }`

    Note: Place routes carefully to avoid conflicts with existing `{entityType}` and `{id:guid}` routes. The literal segment "validate-formula" will match before the `{entityType}` parameter because ASP.NET Core prefers literal segments. Same for "preview-formula" and "field-registry".
  </action>
  <verify>
    - `cd src/GlobCRM.Api && dotnet build` compiles.
    - Three new endpoints exist: POST validate-formula, POST preview-formula, GET field-registry/{entityType}.
    - Create action validates formula and stores DependsOnFieldIds.
    - Update action re-validates formula on expression change.
  </verify>
  <done>
    CustomFieldsController has formula validation, preview, and field registry endpoints. Create and Update actions are formula-aware with server-side validation and dependency tracking. All endpoints compile and route correctly.
  </done>
</task>

<task type="auto">
  <name>Task 2: Inject formula evaluation into all entity controller DTO mappings</name>
  <files>
    src/GlobCRM.Api/Controllers/DealsController.cs
    src/GlobCRM.Api/Controllers/ContactsController.cs
    src/GlobCRM.Api/Controllers/CompaniesController.cs
    src/GlobCRM.Api/Controllers/LeadsController.cs
    src/GlobCRM.Api/Controllers/ActivitiesController.cs
    src/GlobCRM.Api/Controllers/QuotesController.cs
    src/GlobCRM.Api/Controllers/RequestsController.cs
    src/GlobCRM.Api/Controllers/ProductsController.cs
  </files>
  <action>
    For EACH entity controller that has entities with `CustomFields` (Deal, Contact, Company, Lead, Activity, Quote, Request, Product):

    **1. Inject FormulaEvaluationService** into the controller constructor:
    ```csharp
    private readonly FormulaEvaluationService _formulaEvaluator;
    ```
    Add to constructor parameters and assign.

    **2. Create a private helper method** in each controller:
    ```csharp
    private async Task<Dictionary<string, object?>> EnrichWithFormulas(
        string entityType, object entity, Dictionary<string, object?> customFields)
    {
        return await _formulaEvaluator.EvaluateFormulasForEntity(entityType, entity, customFields);
    }
    ```

    **3. Update EVERY DTO `FromEntity()` call path** to use formula-enriched custom fields:
    - The challenge: `FromEntity()` is a static method and can't call async services. There are two approaches:
      - **Option A (preferred):** Change the pattern to compute formula values BEFORE calling `FromEntity()`, then pass enriched customFields. Add a `customFields` parameter override to `FromEntity()` or create a new overload.
      - **Option B:** Change `FromEntity()` to accept a pre-computed `Dictionary<string, object?>` and use it instead of `entity.CustomFields`.

    **Implement Option A for each controller:**
    - In list endpoints (e.g., `GetAll`): After loading entities, batch-evaluate formulas once per entity type. Load formula definitions once (not per entity). For each entity, call `EnrichWithFormulas()` and pass the enriched dict to the DTO.
    - In detail endpoints (e.g., `GetById`): Call `EnrichWithFormulas()` for the single entity.

    **Specific pattern per controller:**

    For **DealsController** (primary example — others follow same pattern):
    - In `GetDeals` list endpoint: After loading deal entities, for each deal, enrich `customFields` and create DTO with enriched values.
    - In `GetDeal` detail endpoint: Enrich the single deal's customFields.
    - Modify `DealListDto.FromEntity` and `DealDetailDto.FromEntity` to accept an optional `Dictionary<string, object?>? formulaFields = null` parameter. If provided, merge into CustomFields. This avoids breaking existing callers.
    - Same pattern: Add a static method like `FromEntity(Deal entity, Dictionary<string, object?>? enrichedCustomFields = null)` where the enriched fields override `entity.CustomFields`.

    **Performance consideration:** For list endpoints with many entities:
    - Formula definitions are loaded once per request (FormulaEvaluationService should cache per entity type per request — it already does this via the repository call).
    - Each entity's formulas are evaluated individually but the definitions are shared.
    - This is acceptable for typical page sizes (25-100 rows).

    Apply the SAME pattern to: ContactsController, CompaniesController, LeadsController, ActivitiesController, QuotesController, RequestsController, ProductsController. Each has its own DTO with `CustomFields` that needs formula enrichment in both list and detail endpoints.

    **Critical:** Only enrich on READ operations (GET endpoints). Do NOT modify POST/PUT/DELETE operations — those should never include formula values in the entity's `CustomFields` JSONB (formulas are computed-on-read, never stored).
  </action>
  <verify>
    - `cd src/GlobCRM.Api && dotnet build` compiles.
    - FormulaEvaluationService is injected in all 8 entity controllers.
    - List and detail GET endpoints in all controllers call EnrichWithFormulas before building DTOs.
    - POST/PUT endpoints do NOT call formula evaluation.
    - DTOs accept optional enriched custom fields parameter.
  </verify>
  <done>
    All 8 entity controllers (Deal, Contact, Company, Lead, Activity, Quote, Request, Product) inject FormulaEvaluationService and enrich custom fields with computed formula values on all GET (list + detail) endpoints. DTOs accept enriched custom fields. POST/PUT operations are unchanged. Formula errors appear as __formulaError marker objects in the response.
  </done>
</task>

</tasks>

<verification>
- `cd src/GlobCRM.Api && dotnet build` succeeds
- POST /api/custom-fields/validate-formula endpoint exists and returns validation results
- POST /api/custom-fields/preview-formula endpoint exists and returns preview results
- GET /api/custom-fields/field-registry/{entityType} endpoint returns field list with categories
- All entity GET endpoints return computed formula values in customFields
- Formula errors serialized as `{ __formulaError: true, message: "..." }` in responses
</verification>

<success_criteria>
Formula validation, preview, and field registry API endpoints are functional. All entity controllers inject formula evaluation into DTO mapping for GET operations. API responses include computed formula field values. Formula CRUD is validated server-side with dependency tracking.
</success_criteria>

<output>
After completion, create `.planning/phases/15-formula-computed-custom-fields/15-02-SUMMARY.md`
</output>
