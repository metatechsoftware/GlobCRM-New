---
phase: 15-formula-computed-custom-fields
plan: 03
type: execute
wave: 3
depends_on: ["15-02"]
files_modified:
  - globcrm-web/src/app/core/custom-fields/custom-field.models.ts
  - globcrm-web/src/app/core/custom-fields/custom-field.service.ts
  - globcrm-web/src/app/features/settings/custom-fields/formula-editor/formula-editor.component.ts
  - globcrm-web/src/app/features/settings/custom-fields/formula-editor/formula-editor.component.html
  - globcrm-web/src/app/features/settings/custom-fields/formula-editor/formula-editor.component.scss
  - globcrm-web/src/app/features/settings/custom-fields/custom-field-edit-dialog.component.ts
  - globcrm-web/src/app/features/settings/custom-fields/custom-field-edit-dialog.component.html
autonomous: true
requirements:
  - FORM-01
  - FORM-05

must_haves:
  truths:
    - "Admin sees a formula editor section when creating/editing a Formula type custom field"
    - "Typing '[' in the formula editor triggers an autocomplete dropdown with available fields grouped by System/Custom/Formula categories"
    - "Formula editor shows real-time validation errors as admin types (syntax errors, unknown field references, circular dependencies)"
    - "Formula editor shows live preview of the computed result using sample or real entity data"
    - "Admin must select a result type (Number, Text, Date) for the formula field"
    - "Autocomplete inserts field reference names (not display labels) into the expression"
  artifacts:
    - path: "globcrm-web/src/app/features/settings/custom-fields/formula-editor/formula-editor.component.ts"
      provides: "Formula text input with autocomplete, validation, and live preview"
      contains: "FormulaEditorComponent"
    - path: "globcrm-web/src/app/core/custom-fields/custom-field.models.ts"
      provides: "Formula type in CustomFieldType enum, FieldInfo interface"
      contains: "Formula"
    - path: "globcrm-web/src/app/core/custom-fields/custom-field.service.ts"
      provides: "validateFormula, previewFormula, getFieldRegistry API methods"
      contains: "validateFormula"
  key_links:
    - from: "globcrm-web/src/app/features/settings/custom-fields/formula-editor/formula-editor.component.ts"
      to: "globcrm-web/src/app/core/custom-fields/custom-field.service.ts"
      via: "validates and previews formulas via service"
      pattern: "customFieldService.*validateFormula"
    - from: "globcrm-web/src/app/features/settings/custom-fields/custom-field-edit-dialog.component.ts"
      to: "globcrm-web/src/app/features/settings/custom-fields/formula-editor/formula-editor.component.ts"
      via: "embeds formula editor when fieldType is Formula"
      pattern: "app-formula-editor"
---

<objective>
Build the formula editor frontend component with autocomplete, real-time validation, and live preview. Integrate it into the existing custom-field-edit-dialog. Extend frontend models and service with formula-specific types and API methods.

Purpose: Gives admins the spreadsheet-like formula creation experience with field autocomplete, instant validation feedback, and live result preview — the core admin UX for formula fields.
Output: FormulaEditorComponent, updated custom-field-edit-dialog with formula section, extended models and service.
</objective>

<execution_context>
@/Users/metatech/.claude/get-shit-done/workflows/execute-plan.md
@/Users/metatech/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/15-formula-computed-custom-fields/15-RESEARCH.md
@.planning/phases/15-formula-computed-custom-fields/15-CONTEXT.md
@.planning/phases/15-formula-computed-custom-fields/15-02-SUMMARY.md
@globcrm-web/src/app/core/custom-fields/custom-field.models.ts
@globcrm-web/src/app/core/custom-fields/custom-field.service.ts
@globcrm-web/src/app/features/settings/custom-fields/custom-field-edit-dialog.component.ts
@globcrm-web/src/app/features/settings/custom-fields/custom-field-edit-dialog.component.html
</context>

<tasks>

<task type="auto">
  <name>Task 1: Extend frontend models and service with formula types and API methods</name>
  <files>
    globcrm-web/src/app/core/custom-fields/custom-field.models.ts
    globcrm-web/src/app/core/custom-fields/custom-field.service.ts
  </files>
  <action>
    **1. Update custom-field.models.ts:**

    - Add `Formula = 'formula'` to the `CustomFieldType` enum.
    - Add `[CustomFieldType.Formula]: 'Formula'` to `CUSTOM_FIELD_TYPE_LABELS`.
    - Add formula-specific properties to `CustomFieldDefinition` interface:
      ```typescript
      formulaExpression: string | null;
      formulaResultType: string | null;  // 'number' | 'text' | 'date'
      dependsOnFieldIds: string[] | null;
      ```
    - Add formula-specific properties to `CreateCustomFieldRequest`:
      ```typescript
      formulaExpression?: string;
      formulaResultType?: string;
      ```
    - Add formula-specific properties to `UpdateCustomFieldRequest`:
      ```typescript
      formulaExpression?: string;
      formulaResultType?: string;
      ```
    - Add new interfaces:
      ```typescript
      export interface FieldInfo {
        name: string;
        label: string;
        dataType: string;  // 'number' | 'text' | 'date' | 'boolean'
        category: string;  // 'System' | 'Custom' | 'Formula'
      }

      export interface ValidateFormulaRequest {
        entityType: string;
        expression: string;
        excludeFieldId?: string;
      }

      export interface ValidateFormulaResponse {
        valid: boolean;
        errors: string[];
      }

      export interface PreviewFormulaRequest {
        entityType: string;
        expression: string;
        sampleEntityId?: string;
      }

      export interface PreviewFormulaResponse {
        value: any;
        error: string | null;
      }

      /** Represents a formula error marker in customFields values */
      export interface FormulaError {
        __formulaError: boolean;
        message: string;
      }

      export function isFormulaError(value: any): value is FormulaError {
        return value && typeof value === 'object' && value.__formulaError === true;
      }
      ```

    **2. Update custom-field.service.ts:**

    Add three new methods:

    ```typescript
    /**
     * Validate a formula expression against an entity type's available fields.
     */
    validateFormula(request: ValidateFormulaRequest): Observable<ValidateFormulaResponse> {
      return this.api.post<ValidateFormulaResponse>('/api/custom-fields/validate-formula', request);
    }

    /**
     * Preview a formula result using sample or real entity data.
     */
    previewFormula(request: PreviewFormulaRequest): Observable<PreviewFormulaResponse> {
      return this.api.post<PreviewFormulaResponse>('/api/custom-fields/preview-formula', request);
    }

    /**
     * Get available fields for formula autocomplete, grouped by category.
     */
    getFieldRegistry(entityType: string): Observable<FieldInfo[]> {
      return this.api.get<FieldInfo[]>(`/api/custom-fields/field-registry/${entityType}`);
    }
    ```

    Import the new types in the service file.
  </action>
  <verify>
    - `cd globcrm-web && npx ng build --configuration development 2>&1 | head -20` compiles without errors (or check with `npx tsc --noEmit`).
    - `CustomFieldType.Formula` exists in the enum.
    - `FieldInfo`, `ValidateFormulaRequest`, `ValidateFormulaResponse`, `PreviewFormulaRequest`, `PreviewFormulaResponse`, `FormulaError`, `isFormulaError` all exported from models.
    - `CustomFieldService` has `validateFormula`, `previewFormula`, `getFieldRegistry` methods.
  </verify>
  <done>
    Frontend CustomFieldType includes Formula. All formula-specific interfaces and type guard exported from models. CustomFieldService has three new API methods for validation, preview, and field registry.
  </done>
</task>

<task type="auto">
  <name>Task 2: Build FormulaEditorComponent and integrate into custom-field-edit-dialog</name>
  <files>
    globcrm-web/src/app/features/settings/custom-fields/formula-editor/formula-editor.component.ts
    globcrm-web/src/app/features/settings/custom-fields/formula-editor/formula-editor.component.html
    globcrm-web/src/app/features/settings/custom-fields/formula-editor/formula-editor.component.scss
    globcrm-web/src/app/features/settings/custom-fields/custom-field-edit-dialog.component.ts
    globcrm-web/src/app/features/settings/custom-fields/custom-field-edit-dialog.component.html
  </files>
  <action>
    **Part A: Create FormulaEditorComponent** (`formula-editor/` subdirectory):

    **formula-editor.component.ts:**
    - Standalone component with `ChangeDetectionStrategy.OnPush`.
    - Inputs: `entityType = input.required<string>()`, `initialFormula = input<string>('')`, `excludeFieldId = input<string | null>(null)`.
    - Outputs: `formulaChange = output<string>()`, `validationChange = output<{ valid: boolean; errors: string[] }>()`.
    - Inject `CustomFieldService`.
    - Signals:
      - `formulaControl = new FormControl('')` (reactive form control for the textarea).
      - `availableFields = signal<FieldInfo[]>([])` — loaded from field-registry API on init.
      - `showAutocomplete = signal(false)` — toggled when user types `[`.
      - `autocompleteFilter = signal('')` — text typed after `[` for filtering.
      - `autocompletePosition = signal({ top: 0, left: 0 })` — position near cursor.
      - `validationErrors = signal<string[]>([])` — from validate-formula API.
      - `isValidating = signal(false)` — loading spinner during validation.
      - `previewResult = signal<any>(null)` — from preview-formula API.
      - `previewError = signal<string | null>(null)` — error from preview.
      - `isPreviewLoading = signal(false)`.
      - `showHelp = signal(false)` — collapsible formula help panel.
    - Computed signals:
      - `groupedFields = computed(() => ...)` — groups availableFields by category (System, Custom, Formula), filtered by autocompleteFilter.
      - `hasErrors = computed(() => this.validationErrors().length > 0)`.
    - OnInit:
      - Load available fields: `this.fieldService.getFieldRegistry(this.entityType()).subscribe(fields => this.availableFields.set(fields))`.
      - Set initial formula value from input.
      - Subscribe to `formulaControl.valueChanges` with `debounceTime(500)` pipe:
        - Emit `formulaChange` with the new value.
        - If expression is non-empty, call `validateAndPreview()`.
        - If expression is empty, clear validation and preview.
    - `onKeyUp(event: KeyboardEvent)` method:
      - If the character just typed is `[`, set `showAutocomplete(true)` and `autocompleteFilter('')`.
      - If `showAutocomplete()` is true:
        - If `]` is typed or `Escape` pressed, close autocomplete.
        - Otherwise, update `autocompleteFilter` with text between last `[` and cursor.
    - `insertField(field: FieldInfo)` method:
      - Get textarea element and cursor position.
      - Find the last `[` before cursor.
      - Replace from `[` to cursor with `[${field.name}]`.
      - Close autocomplete.
      - Update form control value.
    - `validateAndPreview()` private method:
      - Set `isValidating(true)`.
      - Call `fieldService.validateFormula({ entityType, expression, excludeFieldId })`.
      - On result: set `validationErrors`, emit `validationChange`.
      - If valid, call `fieldService.previewFormula({ entityType, expression })`.
      - On preview result: set `previewResult` or `previewError`.
      - Finally: set `isValidating(false)`, `isPreviewLoading(false)`.
    - `toggleHelp()` method: toggles `showHelp` signal.

    **formula-editor.component.html:**
    ```html
    <div class="formula-editor">
      <!-- Formula textarea -->
      <mat-form-field appearance="outline" class="full-width">
        <mat-label>Formula Expression</mat-label>
        <textarea matInput
                  #formulaTextarea
                  [formControl]="formulaControl"
                  (keyup)="onKeyUp($event)"
                  rows="3"
                  placeholder="e.g. [value] * [probability] / 100"
                  spellcheck="false"></textarea>
        @if (validationErrors().length > 0) {
          <mat-error>{{ validationErrors()[0] }}</mat-error>
        }
        <mat-hint>Type [ to insert a field reference</mat-hint>
      </mat-form-field>

      <!-- Autocomplete dropdown (CDK overlay or absolute-positioned div) -->
      @if (showAutocomplete()) {
        <div class="autocomplete-panel" [style.top.px]="autocompletePosition().top" [style.left.px]="autocompletePosition().left">
          @for (group of ['System', 'Custom', 'Formula']; track group) {
            @if (groupedFields()[group]?.length) {
              <div class="autocomplete-group">
                <div class="group-label">{{ group }} Fields</div>
                @for (field of groupedFields()[group]; track field.name) {
                  <button class="autocomplete-item" (mousedown)="insertField(field)" type="button">
                    <span class="field-name">[{{ field.name }}]</span>
                    <span class="field-label">{{ field.label }}</span>
                    <span class="field-type">{{ field.dataType }}</span>
                  </button>
                }
              </div>
            }
          }
          @if (!groupedFields()['System']?.length && !groupedFields()['Custom']?.length && !groupedFields()['Formula']?.length) {
            <div class="autocomplete-empty">No matching fields</div>
          }
        </div>
      }

      <!-- Validation errors list (when more than one) -->
      @if (validationErrors().length > 1) {
        <div class="validation-errors">
          @for (error of validationErrors(); track error) {
            <div class="validation-error">
              <mat-icon class="error-icon">error</mat-icon>
              <span>{{ error }}</span>
            </div>
          }
        </div>
      }

      <!-- Live Preview panel -->
      <div class="formula-preview">
        <div class="preview-label">Preview</div>
        @if (isValidating() || isPreviewLoading()) {
          <mat-spinner diameter="16"></mat-spinner>
          <span class="preview-loading">Evaluating...</span>
        } @else if (previewError()) {
          <span class="preview-error">#ERR: {{ previewError() }}</span>
        } @else if (previewResult() !== null && previewResult() !== undefined) {
          <span class="preview-result">{{ previewResult() }}</span>
        } @else {
          <span class="preview-placeholder">Enter a formula to see the result</span>
        }
      </div>

      <!-- Collapsible Formula Help -->
      <button type="button" class="help-toggle" (click)="toggleHelp()">
        <mat-icon>{{ showHelp() ? 'expand_less' : 'help_outline' }}</mat-icon>
        {{ showHelp() ? 'Hide' : 'Formula' }} Help
      </button>
      @if (showHelp()) {
        <div class="formula-help">
          <h4>Available Functions</h4>
          <table class="help-table">
            <tr><td><code>+ - * /</code></td><td>Arithmetic operators</td></tr>
            <tr><td><code>IF(condition, true_value, false_value)</code></td><td>Conditional logic</td></tr>
            <tr><td><code>DATEDIFF(date1, date2)</code></td><td>Days between two dates</td></tr>
            <tr><td><code>CONCAT(value1, value2, ...)</code></td><td>Join text values</td></tr>
          </table>
          <h4>Examples</h4>
          <ul class="help-examples">
            <li><code>[value] * [probability] / 100</code> — Weighted deal value</li>
            <li><code>IF([status] == 'won', [value], 0)</code> — Value if won</li>
            <li><code>DATEDIFF([createdAt], [expectedCloseDate])</code> — Days to close</li>
            <li><code>CONCAT([firstName], ' ', [lastName])</code> — Full name</li>
          </ul>
        </div>
      }
    </div>
    ```

    **formula-editor.component.scss:**
    - Style the autocomplete panel as an absolute-positioned dropdown with max-height, scroll, shadow, border-radius.
    - Group labels in bold/muted text, items as rows with hover highlight.
    - Field name in monospace, label in regular, type as small badge.
    - Preview panel: bordered box with result or error styling. Error in red with `#ERR` prefix.
    - Help panel: light background, compact table and list styling.
    - Use CSS custom properties from `src/styles/tokens.css` for colors.

    **Part B: Integrate into custom-field-edit-dialog:**

    **custom-field-edit-dialog.component.ts:**
    - Import `FormulaEditorComponent`.
    - Add to `imports` array.
    - Add computed signal: `showFormula = computed(() => this.selectedFieldType() === CustomFieldType.Formula)`.
    - Add signal: `formulaValid = signal(true)`.
    - Add `resultType` form control to the form group: `formulaResultType: ['number']`.
    - Add result type options: `readonly resultTypes = [{ value: 'number', label: 'Number' }, { value: 'text', label: 'Text' }, { value: 'date', label: 'Date' }]`.
    - Handle `formulaChange` event from editor: update a local `formulaExpression` signal.
    - Handle `validationChange` event: update `formulaValid` signal.
    - In `save()` method:
      - When creating a Formula field, include `formulaExpression` and `formulaResultType` in the request.
      - When updating a Formula field, include `formulaExpression` and `formulaResultType` in the update request.
      - Block save if `formulaValid() === false` and field type is Formula.
    - In `populateForm()`: set formula-specific values from the existing field data.

    **custom-field-edit-dialog.component.html:**
    - Add a new section after existing type-specific sections (after showRelation):
      ```html
      @if (showFormula()) {
        <mat-divider></mat-divider>
        <h3>Formula Configuration</h3>

        <mat-form-field appearance="outline" class="full-width">
          <mat-label>Result Type</mat-label>
          <mat-select formControlName="formulaResultType">
            @for (type of resultTypes; track type.value) {
              <mat-option [value]="type.value">{{ type.label }}</mat-option>
            }
          </mat-select>
          <mat-hint>How the formula result should be displayed</mat-hint>
        </mat-form-field>

        <app-formula-editor
          [entityType]="data.entityType"
          [initialFormula]="data.field?.formulaExpression ?? ''"
          [excludeFieldId]="data.field?.id ?? null"
          (formulaChange)="onFormulaChange($event)"
          (validationChange)="onValidationChange($event)" />
      }
      ```
    - Hide validation settings (required, unique, min/max) when Formula type is selected — formulas don't need validation.
    - Disable save button when `showFormula() && !formulaValid()`.
  </action>
  <verify>
    - `cd globcrm-web && npx ng build --configuration development 2>&1 | head -20` compiles.
    - `formula-editor/` directory exists with component.ts, component.html, component.scss.
    - FormulaEditorComponent is imported and used in custom-field-edit-dialog template.
    - Dialog shows formula section when fieldType is Formula.
    - Dialog save includes formulaExpression and formulaResultType for Formula fields.
  </verify>
  <done>
    FormulaEditorComponent built with textarea, autocomplete triggered by `[`, field grouping by System/Custom/Formula, real-time validation (debounced), live preview, and collapsible help panel. Integrated into custom-field-edit-dialog showing formula configuration when Formula type selected. Result type dropdown (Number/Text/Date) controls display format. Save blocked until formula validates.
  </done>
</task>

</tasks>

<verification>
- `cd globcrm-web && npx ng build --configuration development` succeeds
- FormulaEditorComponent renders textarea with autocomplete functionality
- Custom field edit dialog shows formula section for Formula type
- Formula validation and preview API calls work through the service
- Models include all formula-related types and type guard
</verification>

<success_criteria>
Admin can create a Formula custom field by selecting Formula type in the dialog, entering an expression with autocomplete, selecting a result type, seeing real-time validation errors and live preview. The formula expression and result type are saved to the backend on form submission.
</success_criteria>

<output>
After completion, create `.planning/phases/15-formula-computed-custom-fields/15-03-SUMMARY.md`
</output>
