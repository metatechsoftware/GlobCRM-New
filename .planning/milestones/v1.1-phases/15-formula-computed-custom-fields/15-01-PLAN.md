---
phase: 15-formula-computed-custom-fields
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/GlobCRM.Domain/Enums/CustomFieldType.cs
  - src/GlobCRM.Domain/Entities/CustomFieldDefinition.cs
  - src/GlobCRM.Infrastructure/Persistence/Configurations/CustomFieldDefinitionConfiguration.cs
  - src/GlobCRM.Infrastructure/GlobCRM.Infrastructure.csproj
  - src/GlobCRM.Infrastructure/FormulaFields/FormulaEvaluationService.cs
  - src/GlobCRM.Infrastructure/FormulaFields/FormulaValidationService.cs
  - src/GlobCRM.Infrastructure/FormulaFields/FieldRegistryService.cs
  - src/GlobCRM.Infrastructure/FormulaFields/FormulaFieldServiceExtensions.cs
  - src/GlobCRM.Infrastructure/Persistence/Migrations/App/
  - src/GlobCRM.Api/Controllers/CustomFieldsController.cs
autonomous: true
requirements:
  - FORM-01
  - FORM-02
  - FORM-03
  - FORM-05

must_haves:
  truths:
    - "FormulaEvaluationService can evaluate arithmetic expressions with field references from a parameter dictionary"
    - "FormulaEvaluationService supports IF(), DATEDIFF(), and CONCAT() custom functions"
    - "FormulaValidationService detects syntax errors, unknown field references, and circular dependencies"
    - "Topological sort orders formula fields by dependency for chained evaluation"
    - "CustomFieldType.Formula exists as enum value 10 in both backend domain and database"
    - "CustomFieldDefinition has FormulaExpression, FormulaResultType, and DependsOnFieldIds properties persisted as columns/JSONB"
  artifacts:
    - path: "src/GlobCRM.Domain/Enums/CustomFieldType.cs"
      provides: "Formula = 10 enum value"
      contains: "Formula = 10"
    - path: "src/GlobCRM.Domain/Entities/CustomFieldDefinition.cs"
      provides: "FormulaExpression, FormulaResultType, DependsOnFieldIds properties"
      contains: "FormulaExpression"
    - path: "src/GlobCRM.Infrastructure/FormulaFields/FormulaEvaluationService.cs"
      provides: "Expression evaluation engine with custom functions"
      contains: "EvaluateFormulasForEntity"
    - path: "src/GlobCRM.Infrastructure/FormulaFields/FormulaValidationService.cs"
      provides: "Formula syntax, field reference, and circular dependency validation"
      contains: "ValidateAsync"
    - path: "src/GlobCRM.Infrastructure/FormulaFields/FieldRegistryService.cs"
      provides: "System field registry per entity type + custom field lookup"
      contains: "GetAvailableFields"
  key_links:
    - from: "src/GlobCRM.Infrastructure/FormulaFields/FormulaEvaluationService.cs"
      to: "NCalc Expression class"
      via: "NCalcSync package"
      pattern: "new Expression"
    - from: "src/GlobCRM.Infrastructure/FormulaFields/FormulaValidationService.cs"
      to: "src/GlobCRM.Infrastructure/FormulaFields/FieldRegistryService.cs"
      via: "field reference validation uses registry"
      pattern: "FieldRegistryService"
    - from: "src/GlobCRM.Infrastructure/FormulaFields/FormulaFieldServiceExtensions.cs"
      to: "DI container"
      via: "AddFormulaFieldServices extension method"
      pattern: "AddFormulaFieldServices"
---

<objective>
Build the backend foundation for formula custom fields: extend the domain model with Formula field type and formula-specific properties, create the NCalc-based evaluation engine with custom functions (IF, DATEDIFF, CONCAT), build the validation service (syntax + field refs + circular deps via topological sort), and the field registry service.

Purpose: Establishes all backend services and data model needed for formula fields. This is the foundation that API endpoints (Plan 02) and frontend (Plans 03-04) build on.
Output: Domain model extended, EF migration created, three formula field services (evaluation, validation, registry) with DI registration, NCalc package installed.
</objective>

<execution_context>
@/Users/metatech/.claude/get-shit-done/workflows/execute-plan.md
@/Users/metatech/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/15-formula-computed-custom-fields/15-RESEARCH.md
@.planning/phases/15-formula-computed-custom-fields/15-CONTEXT.md
@src/GlobCRM.Domain/Enums/CustomFieldType.cs
@src/GlobCRM.Domain/Entities/CustomFieldDefinition.cs
@src/GlobCRM.Domain/Interfaces/ICustomFieldRepository.cs
@src/GlobCRM.Infrastructure/Persistence/Configurations/CustomFieldDefinitionConfiguration.cs
@src/GlobCRM.Infrastructure/CustomFields/CustomFieldServiceExtensions.cs
@src/GlobCRM.Infrastructure/EmailTemplates/MergeFieldService.cs
@src/GlobCRM.Api/Controllers/CustomFieldsController.cs
</context>

<tasks>

<task type="auto">
  <name>Task 1: Domain model extension, NCalc package, EF configuration, and migration</name>
  <files>
    src/GlobCRM.Domain/Enums/CustomFieldType.cs
    src/GlobCRM.Domain/Entities/CustomFieldDefinition.cs
    src/GlobCRM.Infrastructure/Persistence/Configurations/CustomFieldDefinitionConfiguration.cs
    src/GlobCRM.Infrastructure/GlobCRM.Infrastructure.csproj
    src/GlobCRM.Infrastructure/Persistence/Migrations/App/ (new migration)
  </files>
  <action>
    1. **Add Formula enum value** to `CustomFieldType.cs`:
       - Add `Formula = 10` with XML doc: "Formula field with computed expression. Read-only, evaluated on-read from other fields."

    2. **Extend CustomFieldDefinition entity** with three new properties:
       - `public string? FormulaExpression { get; set; }` — The NCalc expression string (e.g., `[value] * [probability] / 100`). Only set when FieldType is Formula.
       - `public string? FormulaResultType { get; set; }` — Admin-selected result type: "number", "text", or "date". Controls frontend display formatting.
       - `public List<string>? DependsOnFieldIds { get; set; }` — Cached list of field reference names this formula depends on. Used for topological sorting and circular dependency validation. Stored as JSONB array.

    3. **Install NCalcSync package** on Infrastructure project:
       ```bash
       cd src/GlobCRM.Infrastructure && dotnet add package NCalcSync
       ```

    4. **Update EF Core configuration** in `CustomFieldDefinitionConfiguration.cs`:
       - Add `FormulaExpression` column mapping: `formula_expression`, nullable text, `HasMaxLength(2000)`.
       - Add `FormulaResultType` column mapping: `formula_result_type`, nullable varchar, `HasMaxLength(20)`.
       - Add `DependsOnFieldIds` column mapping: `depends_on_field_ids`, nullable JSONB via `HasColumnType("jsonb")`.

    5. **Create EF Core migration**:
       ```bash
       cd src/GlobCRM.Api && dotnet ef migrations add AddFormulaFields --context ApplicationDbContext --output-dir Persistence/Migrations/App --project ../GlobCRM.Infrastructure
       ```

    6. **Apply migration** (dev database):
       ```bash
       cd src/GlobCRM.Api && dotnet ef database update --context ApplicationDbContext --project ../GlobCRM.Infrastructure
       ```

    7. **Update CustomFieldDefinitionDto** in `CustomFieldsController.cs` to include the three new properties in the DTO and `FromEntity()`:
       - Add `FormulaExpression`, `FormulaResultType`, `DependsOnFieldIds` to `CustomFieldDefinitionDto`.
       - Map them in `FromEntity()`.

    8. **Update CreateCustomFieldRequest** to accept formula-specific fields:
       - Add `FormulaExpression`, `FormulaResultType` to request record.
       - In the `Create` action, map these to the entity when `FieldType == Formula`.

    9. **Update CreateCustomFieldRequestValidator** to validate formula fields:
       - Add rule: When FieldType is Formula, FormulaExpression must not be empty.
       - Add rule: When FieldType is Formula, FormulaResultType must be one of "number", "text", "date".
       - Add rule: When FieldType is Formula, Options must be null (formulas don't have options).

    10. **Update UpdateCustomFieldRequest** to accept formula field updates:
        - Add `FormulaExpression`, `FormulaResultType` to update request.
        - In the `Update` action, allow updating formula expression and result type for Formula fields.
  </action>
  <verify>
    - `cd src/GlobCRM.Api && dotnet build` compiles without errors.
    - Migration file exists in `src/GlobCRM.Infrastructure/Persistence/Migrations/App/`.
    - `CustomFieldType.Formula` is value 10 in the enum.
    - `CustomFieldDefinition` has all three new nullable properties.
    - DTO includes formula fields in `FromEntity()`.
  </verify>
  <done>
    CustomFieldType has Formula = 10. CustomFieldDefinition has FormulaExpression, FormulaResultType, DependsOnFieldIds. EF configuration maps new columns with proper types. Migration created and applied. DTO and request records updated. Validator enforces FormulaExpression required for Formula type.
  </done>
</task>

<task type="auto">
  <name>Task 2: Formula evaluation, validation, and field registry services with DI registration</name>
  <files>
    src/GlobCRM.Infrastructure/FormulaFields/FormulaEvaluationService.cs
    src/GlobCRM.Infrastructure/FormulaFields/FormulaValidationService.cs
    src/GlobCRM.Infrastructure/FormulaFields/FieldRegistryService.cs
    src/GlobCRM.Infrastructure/FormulaFields/FormulaFieldServiceExtensions.cs
    src/GlobCRM.Infrastructure/CustomFields/CustomFieldServiceExtensions.cs
  </files>
  <action>
    Create the `src/GlobCRM.Infrastructure/FormulaFields/` directory with four files:

    **1. FieldRegistryService.cs** — System field registry per entity type:
    - Public record: `FieldInfo(string Name, string Label, string DataType, string Category)` where DataType is "number", "text", "date", "boolean" and Category is "System", "Custom", or "Formula".
    - Method `GetAvailableFields(string entityType, List<CustomFieldDefinition> customFields)` returns `List<FieldInfo>`:
      - First, return system fields for the entity type using a switch expression. System fields use camelCase names matching DTO property names. Cover all CRM entities: Deal (title, value, probability, expectedCloseDate, status, createdAt, updatedAt, description), Contact (firstName, lastName, email, phone, jobTitle, createdAt, updatedAt), Company (name, industry, website, phone, address, createdAt, updatedAt), Lead (firstName, lastName, email, phone, companyName, jobTitle, createdAt, updatedAt), Activity, Quote, Request, Product.
      - Then, append custom fields from the provided list, using the field's `Name` (snake_case) as the reference key, field's `Label` as display label, and mapping FieldType to DataType (Text/Dropdown/MultiSelect -> "text", Number/Currency -> "number", Date -> "date", Checkbox -> "boolean"). Category = "Custom".
      - Then, append formula fields from the provided list (FieldType == Formula), using field's `Name` as reference key. Category = "Formula". DataType from FormulaResultType.
    - Method `ExtractEntityValues(string entityType, object entity)` returns `Dictionary<string, object?>`:
      - Uses reflection (or a switch per entity type for performance) to extract system field values from a domain entity into a string-keyed dictionary with camelCase keys matching the registry.
      - Convert all values to proper .NET types: decimal for numbers, DateTime for dates, string for text/enums, bool for booleans.

    **2. FormulaEvaluationService.cs** — Core NCalc evaluation engine:
    - Constructor injects `ICustomFieldRepository` and `FieldRegistryService`.
    - Main method: `EvaluateFormulasForEntity(string entityType, object entity, Dictionary<string, object?> customFields)`:
      - Load all formula definitions for the entity type from the repository. If none, return customFields unchanged.
      - Topological sort the formulas (call internal TopologicalSort method).
      - Build system field parameters using `FieldRegistryService.ExtractEntityValues()`.
      - Merge custom field values into parameter dictionary, converting JSON values to proper .NET types using a `ConvertJsonValue` helper (handles `System.Text.Json.JsonElement` -> native types).
      - Evaluate each formula in dependency order using NCalc `Expression` class.
      - For each formula: create `new Expression(formula.FormulaExpression)`, set all parameters, register custom functions, call `Evaluate()`.
      - On success: store result in both the return dictionary (keyed by formula field's `Name`) AND the parameter dictionary (so chained formulas can reference it).
      - On failure (any exception): store a `Dictionary<string, object?> { ["__formulaError"] = true, ["message"] = ex.Message }` as the value.
      - Return the enriched custom fields dictionary.
    - Custom function registration method `RegisterCustomFunctions(Expression expr)`:
      - `DATEDIFF(date1, date2)`: Converts both args to DateTime, returns `(date2 - date1).Days` as integer. Handles null gracefully.
      - `CONCAT(args...)`: Variadic — joins all args as strings. Null args treated as empty string.
      - NCalc has built-in `if(condition, trueValue, falseValue)` — no registration needed. Nested IF supported natively.
    - Internal `TopologicalSort(List<CustomFieldDefinition> formulas)` using Kahn's algorithm:
      - Build adjacency graph: for each formula, find which other formulas it references by checking `DependsOnFieldIds` against other formula names/IDs.
      - Compute in-degree for each formula.
      - Process zero-in-degree nodes first, decrement dependents.
      - If result count != input count, throw `InvalidOperationException("Circular reference detected in formula fields")`.
      - Return sorted list.
    - Internal `ConvertJsonValue(object? value, string? expectedType)` helper:
      - If value is `JsonElement`: switch on `ValueKind` — Number -> `decimal`, String -> `string` (try parse DateTime if expectedType is date), True/False -> `bool`, Null -> `null`.
      - If value is already a .NET primitive, return as-is.
      - Null values: for numbers return `0m`, for strings return `""`, for dates return `null` (let formula handle it).

    **3. FormulaValidationService.cs** — Comprehensive formula validation:
    - Constructor injects `ICustomFieldRepository` and `FieldRegistryService`.
    - Main method: `ValidateAsync(string entityType, string expression, Guid? excludeFieldId = null)` returns `List<string>` (error messages):
      - **Step 1 — Syntax validation**: Create `new Expression(expression)`. Check `expression.HasErrors()`. If true, add NCalc error message to errors list.
      - **Step 2 — Field reference validation**: If syntax is valid, extract parameter names using `expression.GetParametersNames()` (returns the bracket references). Load all available fields from FieldRegistryService (system + custom + existing formulas). For each parameter name, check it exists in the available fields list. Unknown fields added as error: "Unknown field reference: [fieldName]".
      - **Step 3 — Circular dependency check**: Load all existing formula fields for this entity type. Add the current formula (or replace it if editing, using excludeFieldId). Build the full dependency graph and attempt topological sort. If it fails, return "Circular reference detected" error.
      - Return the error list.
    - Method `PreviewAsync(string entityType, string expression, Guid? sampleEntityId)` returns `(object? Value, string? Error)`:
      - If sampleEntityId is provided, load the actual entity from DbContext and evaluate the formula against real data.
      - If no sampleEntityId, build a sample parameter dictionary with placeholder values from FieldRegistryService (0 for numbers, "sample" for text, DateTime.Now for dates).
      - Evaluate the formula against the parameter dictionary.
      - Return the result or error message.
    - For the preview with real entity, inject `ApplicationDbContext` via constructor and load the entity by type using a switch (Deal, Contact, Company, Lead).

    **4. FormulaFieldServiceExtensions.cs** — DI registration:
    - `AddFormulaFieldServices(this IServiceCollection services)`:
      - Register `FieldRegistryService` as scoped.
      - Register `FormulaEvaluationService` as scoped.
      - Register `FormulaValidationService` as scoped.
    - Wire this into `CustomFieldServiceExtensions.AddCustomFieldServices()` by calling `services.AddFormulaFieldServices()` at the end, OR register independently in Program.cs. Prefer calling from CustomFieldServiceExtensions for cohesion.
  </action>
  <verify>
    - `cd src/GlobCRM.Api && dotnet build` compiles without errors.
    - All four files exist in `src/GlobCRM.Infrastructure/FormulaFields/`.
    - `FormulaEvaluationService` has `EvaluateFormulasForEntity`, `TopologicalSort`, `RegisterCustomFunctions`, and `ConvertJsonValue` methods.
    - `FormulaValidationService` has `ValidateAsync` and `PreviewAsync` methods.
    - `FieldRegistryService` has `GetAvailableFields` and `ExtractEntityValues` methods.
    - Services are registered in DI via extension method.
  </verify>
  <done>
    Three formula field services created: FormulaEvaluationService (NCalc evaluation with DATEDIFF/CONCAT custom functions and topological sort), FormulaValidationService (syntax + field ref + circular dep validation with preview), FieldRegistryService (system/custom/formula field registry per entity type). All registered in DI. Build succeeds.
  </done>
</task>

</tasks>

<verification>
- `cd src/GlobCRM.Api && dotnet build` succeeds
- CustomFieldType enum has Formula = 10
- CustomFieldDefinition has FormulaExpression, FormulaResultType, DependsOnFieldIds
- Migration exists and can be applied
- FormulaEvaluationService, FormulaValidationService, FieldRegistryService all exist and compile
- DI registration connects all services
</verification>

<success_criteria>
Backend domain model extended with Formula field type, NCalc-based evaluation engine built with arithmetic + IF + DATEDIFF + CONCAT support, validation service handles syntax/field refs/circular deps, field registry provides system + custom field metadata per entity type. All services registered in DI and project builds cleanly.
</success_criteria>

<output>
After completion, create `.planning/phases/15-formula-computed-custom-fields/15-01-SUMMARY.md`
</output>
