---
phase: 14-foundation-infrastructure-email-templates
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/GlobCRM.Infrastructure/GlobCRM.Infrastructure.csproj
  - src/GlobCRM.Infrastructure/BackgroundJobs/HangfireServiceExtensions.cs
  - src/GlobCRM.Infrastructure/BackgroundJobs/TenantJobFilter.cs
  - src/GlobCRM.Infrastructure/BackgroundJobs/TenantScope.cs
  - src/GlobCRM.Infrastructure/DomainEvents/DomainEventInterceptor.cs
  - src/GlobCRM.Infrastructure/DomainEvents/DomainEventDispatcher.cs
  - src/GlobCRM.Infrastructure/DomainEvents/DomainEventServiceExtensions.cs
  - src/GlobCRM.Domain/Interfaces/IDomainEvent.cs
  - src/GlobCRM.Domain/Interfaces/IDomainEventDispatcher.cs
  - src/GlobCRM.Domain/Entities/EmailTemplate.cs
  - src/GlobCRM.Domain/Entities/EmailTemplateCategory.cs
  - src/GlobCRM.Domain/Enums/EntityType.cs
  - src/GlobCRM.Infrastructure/Persistence/Configurations/EmailTemplateConfiguration.cs
  - src/GlobCRM.Infrastructure/Persistence/Configurations/EmailTemplateCategoryConfiguration.cs
  - src/GlobCRM.Infrastructure/Persistence/ApplicationDbContext.cs
  - src/GlobCRM.Infrastructure/EmailTemplates/EmailTemplateRepository.cs
  - src/GlobCRM.Infrastructure/EmailTemplates/TemplateRenderService.cs
  - src/GlobCRM.Infrastructure/EmailTemplates/MergeFieldService.cs
  - src/GlobCRM.Infrastructure/EmailTemplates/EmailTemplateServiceExtensions.cs
  - src/GlobCRM.Infrastructure/MultiTenancy/TenantProvider.cs
  - src/GlobCRM.Infrastructure/DependencyInjection.cs
  - src/GlobCRM.Infrastructure/Authorization/RoleTemplateSeeder.cs
  - scripts/rls-setup.sql
autonomous: true
requirements:
  - ETMPL-02
  - ETMPL-03

must_haves:
  truths:
    - "Hangfire server starts with PostgreSQL storage and 4 named queues (default, emails, webhooks, workflows)"
    - "Background jobs enqueued during an HTTP request carry tenant context and execute with that tenant ID restored"
    - "DomainEventInterceptor captures Added/Modified/Deleted entity states before SaveChanges and dispatches events after successful save"
    - "EmailTemplate and EmailTemplateCategory entities exist with EF configurations, global query filters, and RLS policies"
    - "MergeFieldService returns available merge fields grouped by entity (Contact, Company, Deal, Lead) including custom fields"
    - "TemplateRenderService renders Liquid merge fields using Fluid with fallback value support"
    - "RBAC role templates include EmailTemplate permissions for all four template roles"
  artifacts:
    - path: "src/GlobCRM.Infrastructure/BackgroundJobs/HangfireServiceExtensions.cs"
      provides: "Hangfire DI registration with PostgreSQL storage"
      contains: "AddHangfireServices"
    - path: "src/GlobCRM.Infrastructure/BackgroundJobs/TenantJobFilter.cs"
      provides: "Hangfire job filter for tenant context propagation"
      contains: "IClientFilter"
    - path: "src/GlobCRM.Infrastructure/DomainEvents/DomainEventInterceptor.cs"
      provides: "SaveChangesInterceptor for domain event capture and dispatch"
      contains: "SavedChangesAsync"
    - path: "src/GlobCRM.Domain/Entities/EmailTemplate.cs"
      provides: "Email template entity with DesignJson and HtmlBody"
      contains: "DesignJson"
    - path: "src/GlobCRM.Infrastructure/EmailTemplates/TemplateRenderService.cs"
      provides: "Fluid-based Liquid template rendering"
      contains: "FluidParser"
    - path: "src/GlobCRM.Infrastructure/EmailTemplates/MergeFieldService.cs"
      provides: "Merge field resolution from entity data"
      contains: "GetAvailableFieldsAsync"
  key_links:
    - from: "src/GlobCRM.Infrastructure/BackgroundJobs/TenantJobFilter.cs"
      to: "src/GlobCRM.Infrastructure/MultiTenancy/TenantProvider.cs"
      via: "TenantScope.CurrentTenantId fallback in GetTenantId()"
      pattern: "TenantScope\\.CurrentTenantId"
    - from: "src/GlobCRM.Infrastructure/DomainEvents/DomainEventInterceptor.cs"
      to: "src/GlobCRM.Infrastructure/DomainEvents/DomainEventDispatcher.cs"
      via: "DispatchAsync call in SavedChangesAsync"
      pattern: "_dispatcher\\.DispatchAsync"
    - from: "src/GlobCRM.Infrastructure/DependencyInjection.cs"
      to: "src/GlobCRM.Infrastructure/DomainEvents/DomainEventInterceptor.cs"
      via: "AddInterceptors registration order (Auditable first, DomainEvent second)"
      pattern: "DomainEventInterceptor"
---

<objective>
Set up Hangfire background job infrastructure with PostgreSQL storage and tenant-safe execution, build the DomainEventInterceptor for entity lifecycle event dispatching, and create EmailTemplate/EmailTemplateCategory domain entities with EF configurations, Fluid template rendering, merge field resolution, RBAC permissions, and RLS policies.

Purpose: Establishes the shared backend infrastructure (Hangfire, domain events) needed by downstream phases (webhooks, sequences, workflows) and the complete data layer for email templates including rendering and merge field resolution.

Output: Backend infrastructure operational, EmailTemplate data layer complete, merge field and rendering services ready for API layer.
</objective>

<execution_context>
@/Users/metatech/.claude/get-shit-done/workflows/execute-plan.md
@/Users/metatech/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/14-foundation-infrastructure-email-templates/14-RESEARCH.md
@.planning/phases/14-foundation-infrastructure-email-templates/14-CONTEXT.md
@src/GlobCRM.Infrastructure/DependencyInjection.cs
@src/GlobCRM.Infrastructure/Persistence/Interceptors/AuditableEntityInterceptor.cs
@src/GlobCRM.Infrastructure/MultiTenancy/TenantProvider.cs
@src/GlobCRM.Infrastructure/Authorization/RoleTemplateSeeder.cs
@src/GlobCRM.Domain/Enums/EntityType.cs
@src/GlobCRM.Infrastructure/Persistence/ApplicationDbContext.cs
</context>

<tasks>

<task type="auto">
  <name>Task 1: Hangfire infrastructure + DomainEventInterceptor + TenantProvider fallback</name>
  <files>
    src/GlobCRM.Infrastructure/GlobCRM.Infrastructure.csproj
    src/GlobCRM.Infrastructure/BackgroundJobs/HangfireServiceExtensions.cs
    src/GlobCRM.Infrastructure/BackgroundJobs/TenantJobFilter.cs
    src/GlobCRM.Infrastructure/BackgroundJobs/TenantScope.cs
    src/GlobCRM.Infrastructure/DomainEvents/DomainEventInterceptor.cs
    src/GlobCRM.Infrastructure/DomainEvents/DomainEventDispatcher.cs
    src/GlobCRM.Infrastructure/DomainEvents/DomainEventServiceExtensions.cs
    src/GlobCRM.Domain/Interfaces/IDomainEvent.cs
    src/GlobCRM.Domain/Interfaces/IDomainEventDispatcher.cs
    src/GlobCRM.Infrastructure/MultiTenancy/TenantProvider.cs
    src/GlobCRM.Infrastructure/DependencyInjection.cs
  </files>
  <action>
    **Install NuGet packages** in GlobCRM.Infrastructure.csproj:
    - `Hangfire.AspNetCore` (1.8.x)
    - `Hangfire.PostgreSql` (1.21.x)

    Note: `Fluid.Core` (2.x) is installed in Task 2 where it is first consumed by TemplateRenderService.

    **Create `BackgroundJobs/TenantScope.cs`:**
    - Static class with `AsyncLocal<Guid?>` for `CurrentTenantId`
    - Static `SetCurrentTenant(Guid tenantId)` and `ClearCurrentTenant()` methods

    **Create `BackgroundJobs/TenantJobFilter.cs`:**
    - Implements `IClientFilter` and `IServerFilter`
    - `OnCreating`: reads tenant ID from `ITenantProvider` via service resolution from `CreatingContext`, stores as job parameter `"TenantId"`
    - `OnPerforming`: reads `"TenantId"` job parameter, calls `TenantScope.SetCurrentTenant()`
    - `OnPerformed`: calls `TenantScope.ClearCurrentTenant()`
    - `OnCreated`: no-op

    **Create `BackgroundJobs/HangfireServiceExtensions.cs`:**
    - `AddHangfireServices(this IServiceCollection services, IConfiguration configuration)` extension method
    - Configure Hangfire with `UsePostgreSqlStorage` using `DefaultConnection` connection string
    - Set `SchemaName = "hangfire"`, `PrepareSchemaIfNecessary = true`, `QueuePollInterval = TimeSpan.FromSeconds(15)`
    - `SetDataCompatibilityLevel(CompatibilityLevel.Version_180)`, `UseSimpleAssemblyNameTypeSerializer()`, `UseRecommendedSerializerSettings()`
    - `AddHangfireServer` with queues `["default", "emails", "webhooks", "workflows"]` and `WorkerCount = Environment.ProcessorCount * 2`
    - Register `TenantJobFilter` via `GlobalJobFilters.Filters.Add(new TenantJobFilter())`

    **Modify `MultiTenancy/TenantProvider.cs`:**
    - Add a third fallback in `GetTenantId()` after JWT claim fallback: check `TenantScope.CurrentTenantId` (AsyncLocal). This enables background jobs to resolve tenant context without HttpContext.
    - Order: Finbuckle -> JWT claim -> TenantScope AsyncLocal -> null

    **Create `Domain/Interfaces/IDomainEvent.cs`:**
    - Record class `DomainEvent` with properties: `string EntityName`, `string EventType` (Created/Updated/Deleted), `object Entity`, `Guid? EntityId`, `Dictionary<string, object?>? ChangedProperties`
    - Interface `IDomainEventHandler` with `Task HandleAsync(DomainEvent domainEvent, CancellationToken ct)`

    **Create `Domain/Interfaces/IDomainEventDispatcher.cs`:**
    - Interface with `Task DispatchAsync(DomainEvent domainEvent, CancellationToken ct)`

    **Create `DomainEvents/DomainEventInterceptor.cs`:**
    - Extends `SaveChangesInterceptor` (same pattern as `AuditableEntityInterceptor`)
    - Private `AsyncLocal<List<DomainEvent>>` for pending events
    - `SavingChangesAsync`: iterate `ChangeTracker.Entries()`, for each `Added`/`Modified`/`Deleted` entry, create a `DomainEvent` capturing entity type name, event type, entity reference, entity ID (via reflection for `Id` property), and for `Modified` entries capture changed property names/values. Store in AsyncLocal.
    - `SavedChangesAsync`: read from AsyncLocal, dispatch each event via `IDomainEventDispatcher`, clear AsyncLocal. Wrap dispatch in try/catch — dispatch failures must NOT fail the primary save operation (consistent with existing FeedItem/Notification pattern in codebase).
    - Constructor takes `IDomainEventDispatcher` via DI

    **Create `DomainEvents/DomainEventDispatcher.cs`:**
    - Implements `IDomainEventDispatcher`
    - Constructor takes `IServiceProvider`
    - `DispatchAsync`: resolves all `IDomainEventHandler` instances from DI and calls `HandleAsync` on each. Uses `IServiceProvider.GetServices<IDomainEventHandler>()`. Log errors but don't throw (fire-and-forget pattern matching existing notification dispatch).

    **Create `DomainEvents/DomainEventServiceExtensions.cs`:**
    - `AddDomainEventServices(this IServiceCollection services)` extension method
    - Registers `DomainEventInterceptor` as scoped
    - Registers `DomainEventDispatcher` as `IDomainEventDispatcher` (scoped)

    **Modify `DependencyInjection.cs`:**
    - Add `DomainEventInterceptor` to the scoped services registration
    - Add `DomainEventInterceptor` to `ApplicationDbContext`'s `AddInterceptors` call — AFTER `AuditableEntityInterceptor` (order matters: audit timestamps set first, then domain events capture final state)
    - The interceptor chain becomes: `TenantDbConnectionInterceptor`, `AuditableEntityInterceptor`, `DomainEventInterceptor`
  </action>
  <verify>
    - `cd src/GlobCRM.Api && dotnet build` succeeds
    - Verify Hangfire.AspNetCore and Hangfire.PostgreSql NuGet packages are in .csproj
    - Verify `TenantProvider.GetTenantId()` has 3 fallback levels (Finbuckle, JWT, TenantScope)
    - Verify DomainEventInterceptor is registered after AuditableEntityInterceptor in AddInterceptors
  </verify>
  <done>
    Hangfire infrastructure files exist with PostgreSQL storage, tenant job filter, and 4 named queues. DomainEventInterceptor captures entity states in SavingChangesAsync and dispatches in SavedChangesAsync. TenantProvider falls back to TenantScope.CurrentTenantId for background job context. Build succeeds.
  </done>
</task>

<task type="auto">
  <name>Task 2: EmailTemplate entities, EF config, migration, RLS, RBAC, Fluid services</name>
  <files>
    src/GlobCRM.Domain/Entities/EmailTemplate.cs
    src/GlobCRM.Domain/Entities/EmailTemplateCategory.cs
    src/GlobCRM.Domain/Enums/EntityType.cs
    src/GlobCRM.Infrastructure/Persistence/Configurations/EmailTemplateConfiguration.cs
    src/GlobCRM.Infrastructure/Persistence/Configurations/EmailTemplateCategoryConfiguration.cs
    src/GlobCRM.Infrastructure/Persistence/ApplicationDbContext.cs
    src/GlobCRM.Infrastructure/EmailTemplates/EmailTemplateRepository.cs
    src/GlobCRM.Infrastructure/EmailTemplates/TemplateRenderService.cs
    src/GlobCRM.Infrastructure/EmailTemplates/MergeFieldService.cs
    src/GlobCRM.Infrastructure/EmailTemplates/EmailTemplateServiceExtensions.cs
    src/GlobCRM.Infrastructure/Authorization/RoleTemplateSeeder.cs
    scripts/rls-setup.sql
  </files>
  <action>
    **Install NuGet package** in GlobCRM.Infrastructure.csproj:
    - `Fluid.Core` (2.x) — used by TemplateRenderService below

    **Create `Domain/Entities/EmailTemplate.cs`:**
    - Properties: `Guid Id` (default `Guid.NewGuid()`), `Guid TenantId`, `string Name`, `string? Subject` (email subject line, supports merge fields), `string DesignJson` (Unlayer editor state, default `"{}"`), `string HtmlBody` (compiled HTML, default empty), `Guid? CategoryId` (FK to EmailTemplateCategory), `Guid? OwnerId` (FK to ApplicationUser for RBAC scope), `bool IsShared` (default true — shared templates visible to all with permission; false = personal), `bool IsSeedData`, `DateTimeOffset CreatedAt`, `DateTimeOffset UpdatedAt`
    - Navigation properties: `EmailTemplateCategory? Category`, `ApplicationUser? Owner`

    **Create `Domain/Entities/EmailTemplateCategory.cs`:**
    - Properties: `Guid Id` (default `Guid.NewGuid()`), `Guid TenantId`, `string Name`, `int SortOrder` (default 0), `bool IsSystem` (true for seeded categories — cannot be deleted), `bool IsSeedData`, `DateTimeOffset CreatedAt`, `DateTimeOffset UpdatedAt`
    - Navigation: `ICollection<EmailTemplate> Templates`

    **Add `EmailTemplate` to `EntityType` enum** in `Domain/Enums/EntityType.cs`.

    **Create `Persistence/Configurations/EmailTemplateConfiguration.cs`:**
    - Table name: `email_templates`
    - Snake_case column names: `id`, `tenant_id`, `name`, `subject`, `design_json`, `html_body`, `category_id`, `owner_id`, `is_shared`, `is_seed_data`, `created_at`, `updated_at`
    - `DesignJson` column type `jsonb`
    - `HtmlBody` column type `text`
    - FK to `email_template_categories` on `CategoryId` with `SET NULL` delete behavior
    - FK to `users` on `OwnerId` with `SET NULL` delete behavior
    - Index on `tenant_id`
    - Global query filter: `.HasQueryFilter(e => e.TenantId == _tenantId)` following existing pattern
    - Full-text search: `HasGeneratedTsVectorColumn` on `Name` and `Subject` (if supported, otherwise skip)

    **Create `Persistence/Configurations/EmailTemplateCategoryConfiguration.cs`:**
    - Table name: `email_template_categories`
    - Snake_case columns: `id`, `tenant_id`, `name`, `sort_order`, `is_system`, `is_seed_data`, `created_at`, `updated_at`
    - Index on `tenant_id`
    - Unique index on (`tenant_id`, `name`)
    - Global query filter: `.HasQueryFilter(e => e.TenantId == _tenantId)`

    **Update `ApplicationDbContext`:**
    - Add `DbSet<EmailTemplate> EmailTemplates` and `DbSet<EmailTemplateCategory> EmailTemplateCategories`
    - Apply configurations in `OnModelCreating`

    **Create EF Core migration** (if context budget allows — see note below):
    - Run: `cd src/GlobCRM.Api && dotnet ef migrations add AddEmailTemplates --context ApplicationDbContext --output-dir Persistence/Migrations/App --project ../GlobCRM.Infrastructure`
    - Apply: `dotnet ef database update --context ApplicationDbContext --project ../GlobCRM.Infrastructure`

    **Update `scripts/rls-setup.sql`** (if context budget allows — see note below):
    - Add RLS policies for `email_templates` and `email_template_categories` tables, following existing patterns (e.g., `ALTER TABLE email_templates ENABLE ROW LEVEL SECURITY; CREATE POLICY ...`)

    **Scope note:** This plan has 23 files across 2 tasks, which is above the 15-file guideline. If Task 2 experiences context pressure before completing the EF migration and RLS update, the executor should stop and these two items (EF migration + rls-setup.sql) can be completed as the first action in Plan 14-02 Task 2 (which already depends on 14-01 and touches TenantSeeder).

    **Create `EmailTemplates/EmailTemplateRepository.cs`:**
    - Constructor takes `ApplicationDbContext`
    - Methods: `GetAllAsync(Guid tenantId, Guid? categoryId, bool? isShared, string? search)` with optional filters, `GetByIdAsync(Guid id)`, `CreateAsync(EmailTemplate template)`, `UpdateAsync(EmailTemplate template)`, `DeleteAsync(Guid id)`, `CloneAsync(Guid id, string newName)` (copies entity with new Id, resets audit fields)

    **Create `EmailTemplates/TemplateRenderService.cs`:**
    - Private `FluidParser _parser` (thread-safe, reusable)
    - `Task<string> RenderAsync(string htmlTemplate, Dictionary<string, object?> mergeData)`:
      - Parse template with `_parser.TryParse()`, throw on parse error
      - Create `TemplateContext` with `TemplateOptions`
      - Set each merge data key as value on context (e.g., `context.SetValue("contact", mergeData["contact"])`)
      - Return `await template.RenderAsync(context)`
    - Fluid's built-in `default` filter handles fallback values: `{{ contact.first_name | default: 'there' }}`

    **Create `EmailTemplates/MergeFieldService.cs`:**
    - Constructor takes `ApplicationDbContext`
    - `Task<Dictionary<string, List<MergeFieldDefinition>>> GetAvailableFieldsAsync()`:
      - Hardcoded core fields for Contact (first_name, last_name, email, phone, job_title), Company (name, industry, website, phone, address), Deal (title, value, stage, probability, close_date, description), Lead (first_name, last_name, email, phone, company_name, title)
      - One level of dot notation for related entities: `contact.company.name`, `deal.company.name`, `lead.source.name`
      - Load custom field definitions from DB for Contact, Company, Deal, Lead entity types
      - Add custom fields as `{entity}.custom.{field_name}` with the custom field's Label as display name
      - Return grouped by entity key
    - `Task<Dictionary<string, object?>> ResolveEntityDataAsync(string entityType, Guid entityId)`:
      - Load entity by type and ID with Include for related entities (one level)
      - Build dictionary of field values including custom fields from JSONB `CustomFields` property
      - Handle missing/null fields gracefully (return null values, Fluid's `default` filter handles the rest)
    - Inner record `MergeFieldDefinition(string Key, string Label, string Group, bool IsCustomField)`

    **Create `EmailTemplates/EmailTemplateServiceExtensions.cs`:**
    - `AddEmailTemplateServices(this IServiceCollection services)` extension method
    - Register `EmailTemplateRepository` as scoped
    - Register `TemplateRenderService` as singleton (FluidParser is thread-safe)
    - Register `MergeFieldService` as scoped

    **Update `Authorization/RoleTemplateSeeder.cs`:**
    - The `EntityType` enum now includes `EmailTemplate`. The seeder already iterates `Enum.GetNames<EntityType>()` to create permissions, so `EmailTemplate` permissions (View, Create, Edit, Delete) will be automatically created for all four role templates (Admin=All, Manager=Team, Sales Rep=Team/Own, Viewer=All/None) with no code changes needed — just verify this works correctly after adding the enum value.
    - The `SeedAllTenantsAsync` method's `EnsurePermissionsForNewEntityTypes` logic (if it exists) should pick up the new entity type. If it only seeds new tenants, we may need to add a migration path for existing tenants. Check existing code behavior.
  </action>
  <verify>
    - `cd src/GlobCRM.Api && dotnet build` succeeds
    - Migration file exists in `src/GlobCRM.Infrastructure/Persistence/Migrations/App/`
    - `dotnet ef database update --context ApplicationDbContext --project ../GlobCRM.Infrastructure` succeeds from `src/GlobCRM.Api`
    - `cd src/GlobCRM.Api && dotnet run -- --reseed` succeeds (TenantSeeder still works with new EntityType)
    - RLS policies added to `scripts/rls-setup.sql` for both new tables
  </verify>
  <done>
    EmailTemplate and EmailTemplateCategory entities created with full EF configurations, migration applied, RLS policies written, RBAC permissions auto-created for EmailTemplate entity type. TemplateRenderService renders Liquid templates via Fluid. MergeFieldService returns available merge fields grouped by entity including custom fields. Build and reseed pass.
  </done>
</task>

</tasks>

<verification>
1. `cd src/GlobCRM.Api && dotnet build` — full solution builds without errors
2. Migration applied successfully to PostgreSQL
3. Hangfire service extensions create 4 named queues
4. DomainEventInterceptor registered after AuditableEntityInterceptor
5. TenantProvider.GetTenantId() has 3 fallback levels
6. RLS policies in rls-setup.sql for email_templates and email_template_categories
7. RoleTemplateSeeder creates EmailTemplate permissions for all 4 role templates
</verification>

<success_criteria>
- Backend builds and all existing tests pass
- Hangfire, Fluid, and infrastructure packages installed
- DomainEventInterceptor captures entity lifecycle events
- EmailTemplate data layer complete with repository, render service, and merge field service
- RBAC role templates include EmailTemplate permissions
</success_criteria>

<output>
After completion, create `.planning/phases/14-foundation-infrastructure-email-templates/14-01-SUMMARY.md`
</output>
